<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.9.3" created="2018-02-23 12:59" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>SYCstudio</title>
	<link>http://sycstudio.com</link>
	<description>Hold on the straight to the end with my best and keep fighting until touched by my soul!</description>
	<pubDate>Fri, 23 Feb 2018 12:59:29 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://sycstudio.com</wp:base_site_url>
	<wp:base_blog_url>http://sycstudio.com</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[sycstudio]]></wp:author_login><wp:author_email><![CDATA[1726016246@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[sycstudio]]></wp:author_display_name><wp:author_first_name><![CDATA[宋]]></wp:author_first_name><wp:author_last_name><![CDATA[聿辰]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>13</wp:author_id><wp:author_login><![CDATA[dsl2002]]></wp:author_login><wp:author_email><![CDATA[778315932@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[dsl2002]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>11</wp:author_id><wp:author_login><![CDATA[flashhu]]></wp:author_login><wp:author_email><![CDATA[1258661899@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[flashhu]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>8</wp:author_id><wp:author_login><![CDATA[yyb]]></wp:author_login><wp:author_email><![CDATA[1357828232@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[yyb]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>


	<generator>https://wordpress.org/?v=4.9.3</generator>

<image>
	<url>http://sycstudio.com/wp-content/uploads/2018/02/cropped-head-32x32.png</url>
	<title>SYCstudio</title>
	<link>http://sycstudio.com</link>
	<width>32</width>
	<height>32</height>
</image> 

	<item>
		<title>本站说明&amp;留言版</title>
		<link>http://sycstudio.com/archives/78</link>
		<pubDate>Sun, 07 Jan 2018 06:12:23 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=78</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>本站说明</h1>

本站建于2017.12.23
基于&#92;(wordpress&#92;)搭建，主题采用<a href="http://hzwer.com" title="hzwer">hzwer</a>的主题

<h1>鸣谢</h1>

感谢&#92;(Matt Mullenweg&#92;)及其他作者制作的&#92;(wordpress&#92;)提供自由、开放的博客搭建平台
感谢<a href="http://hzwer.com">hzwer</a>和<a href="http://lianyue.org">lianyue</a>强大的博客主题
感谢<a href="http://ruanx.pw/">阮行止</a>的BZOJ离线题库:&#92;(BZOJCH&#92;)，下面是其<a href="https://github.com/Ruanxingzhi/bzojch">github地址</a>
感谢<a href="https://github.com/CyberZHG?tab=repositories">Zhao HG</a>的2147483647和<a href="https://github.com/gabrielecirulli">gabrielecirulli</a>的2048~~为广大oier提供了简易的颓废工具~~

<h1>本站的一些工具~~和颓废~~的入口</h1>

<a href="http://sycstudio.com/bzojch/">BZOJ离线版</a>
<a href="http://sycstudio.com/game/2048/">2048</a>
<a href="http://sycstudio.com/game/2147483648/">2147483648</a>
<a href="http://sycstudio.com/game/2048-1705/">2048-1705第八搞事小组专版</a>
另：我的旧博客地址:<a href="http://cnblogs.com/sycstudio">cnblogs</a>

<h1>一些说明</h1>

<h2>评论审核</h2>

为了维护和谐的博客环境，拒绝虚伪风气蔓延，本站已开启评论审核，包含以下关键字的评论（包括评论内容，评论人名字等等，只要是你输入的内容）将被审核。为了方便您的交流，请不要使用以下审核关键字
当前审核关键字：（更新于2018.1.19）
Upt：2018.1.22感谢xzz提供了新的审核关键字
Upt：2018.1.24感谢k-xzy提供了新的审核关键字
Upt：2018.1.25感谢hjt提供了新的审核关键字
Upt：2018.1.27介于乱膜现象严重，本站已全面开启评论审核，所有评论均要经过审核才能公开，如果有急事需要询问博主，可以通过邮箱交流

<pre><code>orz
Orz
ORZ
OTZ
蒟蒻
大佬
%
STO
stO
dalao
膜
srO
OΩ
0TZ
ST0
Grz
强无敌
crz
</code></pre>

如果还有新的关键字，会及时更新

<h2>BUG提交</h2>

本站部分文章搬运自我的旧博客，加上本人并不会多少&#92;(html,php,css&#92;)技术，博客很有可能出现奇怪的错误。如果出现问题（特别是数学公式出鬼或是图片加载不了），请在这里回复我。
目前已经发现的问题
1.侧边栏最新评论的评论人会全部变成当前所在文章的最新评论人。（这个BUG是hzwer模板上的，目前没有找到好的解决办法，只能先去掉最新评论）
2.&#92;(2147483648&#92;)会无故&#92;(GameOver&#92;)或者是渲染出错。（感谢&#92;(TPLY&#92;)~~在颓的时候~~找到了这个错误，不过似乎出现概率比较低？）
3.&#92;(markdown&#92;)无法渲染删除线（正在抢修）
4.数字字母加载不出。这个问题主要出现在&#92;(bzojch&#92;)和后台，对阅读影响不大。目测原因是字体文件缺失。（解决办法：如果您在阅读文章时出现了这类错误，可以到浏览器设置中设置不允许页面使用自己的字体）
5.用户注册可能出现注册不成功，请与我联系在后台修改（已经修复完毕，是邮件的错误）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>78</wp:post_id>
		<wp:post_date><![CDATA[2018-01-06 22:12:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-07 06:12:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%9c%ac%e7%ab%99%e8%af%b4%e6%98%8e]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="wordpress"><![CDATA[wordpress]]></category>
		<category domain="category" nicename="wordpress"><![CDATA[wordpress]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>81</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 11:09:17]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 03:09:17]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[萝卜，为什么我在回收站发现了你的评论？？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>76</wp:comment_id>
			<wp:comment_author><![CDATA[iot]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[3057244225@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-03 10:59:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-03 02:59:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[观光]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>24</wp:comment_id>
			<wp:comment_author><![CDATA[k-XZY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://k-xzy.cf</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 16:17:14]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 08:17:14]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[(和谐)太强了mol mol mol
MMP去你的违禁字符QvQ]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>26</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 17:27:30]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 09:27:30]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[违禁字已和谐。
（注意是用户名里面也不能出现违禁字的）
拒绝虚伪风气蔓延，共建和谐博客环境\滑稽]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>24</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>27</wp:comment_id>
			<wp:comment_author><![CDATA[蒟蒻XZY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://k-xzy.cf</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 18:56:58]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 10:56:58]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[啊？
我不是写了（和谐）咩
注意是0
不是O
还有我觉得禁掉了百分号会不会不太好QvQ
万一，，，以后要发代码，里面要取模捏？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>26</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>28</wp:comment_id>
			<wp:comment_author><![CDATA[蒟蒻XZY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://k-xzy.cf</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 18:59:23]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 10:59:23]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[QvQ我怎么提供了新的关键字=。=
QvQ
那干脆还是
(和谐)太强了!]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>26</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>29</wp:comment_id>
			<wp:comment_author><![CDATA[litble]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[litble@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://blog.csdn.net/litble/article/list/1</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 21:02:21]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 13:02:21]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[（和谐） SYC 真是too strong.我等（和谐）难以瞻您后尘啊......
(话说您开了(和谐)真是让人更想（和谐）了呢=w=)]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>30</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-24 22:36:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-24 14:36:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[哦，是的，原来写错啦，已经改好了。
另外提醒您一句，您的名字里面有关键字juruo所以每一次都会被审核。。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>27</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>31</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 08:12:08]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 00:12:08]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你们都这么强，我们这些菜鸡瑟瑟发抖]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>29</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>32</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 08:12:43]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 00:12:43]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我们都太（和谐）了，强无敌呗]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>24</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>33</wp:comment_id>
			<wp:comment_author><![CDATA[TPLY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1727367172@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 08:16:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 00:16:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[太强了！！！
(和谐)(和谐)(和谐)]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>4</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>69</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.3.89]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:59:50]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:59:50]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[哦，我知道了，没有设置权限，现在已经好了
另：权限说明
①订阅者：只有阅读权限，可以修改自己的个人资料，例如昵称、联系信息、密码等。
②投稿者：具有订阅者的所有权限。可以发表文章，但需要经过管理员审核后才能在博客上显示出来；对待审中的文章可以编辑，但对已通过审核的文章不能编辑。
③作者：具有投稿者的所有权限。发布文章不需要审核，并且可以编辑已通过审核的文章，还可以上传文件和使用媒体库。
④编辑：具有作者的所有权限。可以对文章标签、分类进行管理，可以添加或编辑页面，可以管理友情链接、可以上传文件等等。编辑拥有除系统功能设置外的所有权限。
⑤管理员：可以控制用户写文章、创建页面、管理插件、管理主题，以及管理其他用户的权限。管理员可以通过后天分配用户权限。
现在已经全部设置为作者了！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>66</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>68</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.3.89]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:58:25]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:58:25]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[？？？应该是可以的啊？？？
你再试试？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>66</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>66</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.52]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:22:36]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:22:36]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我感觉很迷...,因为那篇文章有问题要改]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>65</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.54]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:15:48]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:15:48]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[为什么我不能编辑我写的文章？？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>46</wp:comment_id>
			<wp:comment_author><![CDATA[lrj124]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1584634848@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/lrj124</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[124.226.40.221]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 22:56:03]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 14:56:03]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<del datetime="2018-01-25T15:21:40+00:00">Θrz</del>
（和谐）]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>82</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.19.67.125]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 11:11:16]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 03:11:16]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[因为有人冒充它人ID
警告这个IP的人：61.187.87.194]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>81</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>83</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 14:04:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 06:04:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这不是机房的IP啊。我记得球爷在机房了发了一个。我自己在机房了在我的文章下发一个试试。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>82</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>86</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.19.5.120]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 14:18:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 06:18:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我严重怀疑是xzz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>85</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>87</wp:comment_id>
			<wp:comment_author><![CDATA[TPLY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1727367172@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-06 07:57:45]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 23:57:45]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[申请友链]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>4</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>85</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 14:08:08]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 06:08:08]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我看了一下，这是机房的IP。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>82</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>88</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.17.3.198]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-06 13:35:38]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-06 05:35:38]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已加！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>87</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>89</wp:comment_id>
			<wp:comment_author><![CDATA[ju蒻XZY]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[konnyakuxzy@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.k-xzy.xyz</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.215.79.234]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-07 11:05:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-07 03:05:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[QvQ
julao%%%%Orz
我的博客更换了地址啦，已经不是k-xzy.cf了
换成了www.k-xzy.xyz
请问能否麻烦您更新一下友链呢？
谢谢您啦！QvQ
（我才不会告诉你我这段换都是复制的呢）]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>90</wp:comment_id>
			<wp:comment_author><![CDATA[WHZ0325]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[wuhaozhong0325@sina.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://whzstudio.coding.me</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[218.77.57.22]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-07 12:24:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-07 04:24:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[来自HA的高一蒟蒻OIer求加友链～～]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>91</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.17.190.129]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-07 14:50:33]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-07 06:50:33]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已更改]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>89</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>92</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.19.6.165]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-07 22:44:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-07 14:44:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已经加了！
互相学习吧！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>90</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>欧拉函数</title>
		<link>http://sycstudio.com/archives/96</link>
		<pubDate>Thu, 11 Jan 2018 16:08:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=96</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>欧拉函数</h1>

<h1>定义</h1>

定义&#92;(\phi(i)&#92;)为<strong>不大于</strong>&#92;(i&#92;)的与&#92;(i&#92;)互质的数的个数，公式表达为
&#92;[\sum&#95;{i=1}^{n-1}[gcd(i,n)==1]&#92;]
规定：&#92;(\phi(1)=1&#92;)

<h2>基本计算公式</h2>

&#92;[\phi(x)=x(1-\frac{1}{p&#95;1})(1-\frac{1}{p&#95;2})...(1-\frac{1}{p&#95;n})&#92;]其中&#92;(p&#95;1,p&#95;2....p&#95;n&#92;)为&#92;(x&#92;)的质因子
这个公式比较直观，即对于数&#92;(x&#92;)来说，有&#92;(x-1&#92;)个比它小的数，枚举&#92;(x&#92;)的因子在这些数中删去它们，最后剩下的就是与&#92;(x&#92;)互质且小于x的数了

<h1>基本性质</h1>

<h2>性质1</h2>

<blockquote>
  对于任意质数&#92;(p&#92;)，&#92;(\phi(p)=p-1&#92;)
</blockquote>

证明：这个比较好想，对于任意一个质数，小于它的数都与它互质

<h2>性质2</h2>

<blockquote>
  对于任意质数$$p$$，$$\phi(p^k)=(p-1)&#42;p^{k-1}$$
</blockquote>

证明：根据基本公式$$\phi(p^k)=p^k&#42;(1-\frac{1}{p})=p^k&#42;\frac{p-1}{p}=p^{k-1}$$

<h2>性质3</h2>

<blockquote>
  $$\phi(xy)=\phi(x)&#42;\phi(y)$$其中$$gcd(x,y)==1$$
</blockquote>

这个可以由欧拉函数是积性函数推出来

#欧拉函数的求法
知道了上面的若干性质，有什么用呢？它们可以用来求解欧拉函数

<h2>单个欧拉函数的求法</h2>

直接运用基本公式求解。对于数$$x$$分解出它的每一个质因子$$p$$，依次计算即可
由于考虑到一个数$$x$$最多只会有一个大于$$\sqrt{x}$$的因子，所以可以只枚举到$$\sqrt{x}$$，那么如果最后还剩下一个非$$1$$的因子，累计到答案里即可

<pre><code class="cpp">ll Phi(ll x)//求φ
{
    ll ret=x;
    for (ll i=2;i*i&lt;=x;i++)
        if (x%i==0)//找到一个质因子
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;//把x除干净
        }
    if (x&gt;1) ret=ret/x*(x-1);
    return ret;
}
</code></pre>

<h2>线性筛求法</h2>

当我们要求$$1...n$$每一个数的欧拉函数时，上面的复杂度就过高了。而我们知道在筛素数的时候有线性素数筛的方法，那么欧拉函数时候有线性筛的算法呢？
有，不过在此之前我们先说一说能线性筛的原理
基本条件：
$$\phi(p)=p-1$$其中$$p$$是质数
$$\phi(p^k)=(p-1)&#42;p^{k-1}$$
欧拉函数是积性函数，即$$\phi(pq)=\phi(p)&#42;\phi(q) [gcd(p,q)==1]$$
这里首先给出线性求欧拉函数的算法

<pre><code class="cpp">//notprime[i]为0表示是质数，为1表示不是质数
//Prime[]存放已经筛出来的质数
//maxNum值域
void GetPhi()
{
    notprime[1]=1;phi[1]=1;//设置初始值
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) phi[i]=i-1,Prime[++pricnt]=i;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)Prime[j]*i&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                phi[i*Prime[j]]=phi[i]*Prime[j];
                break;
            }
            phi[i*Prime[j]]=phi[i]*phi[Prime[j]];
        }
    }
    return;
}
</code></pre>

然后我们现在给出欧拉函数的递推公式（下文中的$$p$$均为质数且保证$$p&lt;=i$$（这个是$$for$$循环从小到大能够保证的））
$$ \phi(i&#42;p)= \begin{cases}p-1 \quad i==1 &#92;&#92; \phi(i)&#42;\phi(p) &#92;quad gcd(i,p)==1 &#92;&#92; \phi(i)&#42;p &#92;quad gcd(i,p)!=1 \end{cases} $$

第一条不需要多解释，根据性质一可以直接得到
第二条同样，由性质三积性函数可以得到
第三条作如下说明
因为$$gcd(i,p)!=1$$且$$p&lt;=i$$，而$$p$$又是质数，所以$$i\ mod\ p==0$$，则可知$$\phi(i)$$中已经有$$(1-\frac{1}{p})$$这一项了，所以可以不用再乘了。同时，执行完这一句后就$$break$$了，这是因为为了保证每一个数$$i&#42;p$$只能由它的最小的质因子$$p$$筛到，这时线性筛的复杂度保证。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>96</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 00:08:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 16:08:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0phii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>博客模板</title>
		<link>http://sycstudio.com/archives/108</link>
		<pubDate>Thu, 11 Jan 2018 16:35:47 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=108</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<h3>Http</h3>

<h3>Tag</h3>

<h2>题目大意</h2>

<h2>解决思路</h2>

<h2>代码</h2>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>108</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 00:35:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 16:35:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%8d%9a%e5%ae%a2%e6%a8%a1%e6%9d%bf]]></wp:post_name>
		<wp:status><![CDATA[private]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU2588]GCD（欧拉函数）</title>
		<link>http://sycstudio.com/archives/110</link>
		<pubDate>Thu, 11 Jan 2018 16:54:47 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=110</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

The greatest common divisor GCD(a,b) of two positive integers a and b,sometimes written (a,b),is the largest divisor common to a and b,For example,(1,2)=1,(12,18)=6.
(a,b) can be easily found by the Euclidean algorithm. Now Carp is considering a little more difficult problem:
Given integers N and M, how many integer X satisfies 1&lt;=X&lt;=N and (X,N)>=M.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-2588">HDU</a>

<h3>Tag</h3>

欧拉函数

<h2>题目大意</h2>

给定数&#92;(N&#92;)，求满足&#92;(gcd(x,N)>=M&#92;)的&#92;(X&#92;)的数量

<h2>解决思路</h2>

考虑&#92;(N=a&#42;b&#92;)，若&#92;(gcd(N=a&#42;b,a&#42;c)==a&#92;)，则$$b$$与$$c$$互质，而可能的$$c$$的数量就是与$$b$$互质的数的个数，即为$$\phi(b)$$，所以可以考虑枚举$$N$$的因子$$a$$，求$$\phi(a)$$之和。
但是考虑到$$N$$的范围，直接枚举会超时。因为对于$$N$$的因数$$a$$，一定存在一个对应的因数$$b$$使得$$N=a&#42;b$$，所以我们只需要枚举到$$\sqrt{n}$$即可，注意判断$$n$$为完全平方数的情况，此时$$\sqrt{n}$$只能算一遍

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

ll Phi(ll x);

int main()
{
    int T;scanf("%d",&amp;T);
    while(T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);
        ll ans=0;
        for (ll i=1;i*i&lt;=n;i++)
            if (n%i==0)
            {
                if (i&gt;=m) ans=ans+Phi(n/i);
                if ((n/i&gt;=m)&amp;&amp;(i*i!=n)) ans=ans+Phi(i);//注意这里不能重复计算完全平方数
            }
        printf("%lld\n",ans);
    }
    return 0;
}

ll Phi(ll x)//求φ
{
    ll ret=x;
    for (ll i=2;i*i&lt;=x;i++)
        if (x%i==0)
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;
        }
    if (x&gt;1) ret=ret/x*(x-1);
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>110</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 00:54:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 16:54:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2588-gcd%ef%bc%88%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_933d88cdaf6eec748c7c1bb98ebf80bc]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[POJ2478]Farey Sequence （欧拉函数）</title>
		<link>http://sycstudio.com/archives/112</link>
		<pubDate>Thu, 11 Jan 2018 17:13:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=112</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

The Farey Sequence Fn for any integer n with n >= 2 is the set of irreducible rational numbers a/b with 0 &lt; a &lt; b &lt;= n and gcd(a,b) = 1 arranged in increasing order. The first few are
F2 = {1/2}
F3 = {1/3, 1/2, 2/3}
F4 = {1/4, 1/3, 1/2, 2/3, 3/4}
F5 = {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5}

You task is to calculate the number of terms in the Farey sequence Fn.

<h3>Http</h3>

<a href="https://vjudge.net/problem/POJ-2478">POJ</a>

<h3>Tag</h3>

欧拉函数

<h2>题目大意</h2>

给定正整数&#92;(N&#92;)，求小于等于&#92;(N&#92;)的互质的数的个数

<h2>解决思路</h2>

求小于等于&#92;(N&#92;)的互质的数的个数，就是求&#92;(\sum \phi(i)&#92;)，线性筛出$$\phi(i)$$即可，但要注意虽然$$\phi(1)==1$$，但这里不能统计进去

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=1000010;
const int inf=2147483647;

ll phi[maxNum];
ll sum[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void Phi();

int main()
{
    Phi();
    sum[1]=0;
    for (int i=2;i&lt;maxNum;i++) sum[i]=sum[i-1]+phi[i];//求前缀和
    int n;
    while (scanf("%d",&amp;n)!=EOF)
    {
        if (n==0) break;
        printf("%lld\n",sum[n]);
    }
    return 0;
}

void Phi()
{
    notprime[1]=1;phi[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,phi[i]=i-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*Prime[j])&lt;maxNum;j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                phi[i*Prime[j]]=phi[i]*Prime[j];
                break;
            }
            phi[i*Prime[j]]=phi[i]*phi[Prime[j]];
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>112</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 01:13:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 17:13:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-2478-farey-sequence-%ef%bc%88%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="category" nicename="poj"><![CDATA[POJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_b28b13d5829a362926ff7c63192379e7]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU3501]Calculation 2 （欧拉函数）</title>
		<link>http://sycstudio.com/archives/115</link>
		<pubDate>Thu, 11 Jan 2018 17:34:26 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=115</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>HDU 3501 Calculation 2</h1>

<h3>Description</h3>

Given a positive integer N, your task is to calculate the sum of the positive integers less than N which are not coprime to N. A is said to be coprime to B if A, B share no common positive divisors except 1.

<h3>Http</h3>

https://vjudge.net/problem/HDU-3501

<h3>Tag</h3>

欧拉函数

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} [gcd(i,n)!=1]&#42;i&#92;)

<h2>解决思路</h2>

考虑若有&#92;(gcd(i,n)==1&#92;)，那一定会有$$gcd(n-i,n)==1$$，那么可以知道，与一个数互质的数一定是一组一组出现的，所以可以知道与$$N$$互质的数的和就是$$N&#42;\phi(N)/2$$。那么根据补集原理，用$$1~N$$的和减去与$$N$$互质的数之和就是与$$N$$不互质的数之和啦。
注意特判1。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const ll Mod=1000000007;

ll Phi(ll x);
ll Inv(ll a,ll b);
void Exgcd(ll a,ll b,ll &amp;x,ll &amp;y);

int main()
{
    ll inv2=Inv(2,Mod);
    ll n;
    while (scanf("%lld",&amp;n))
    {
        if (n==0) break;
        if (n==1) {printf("0\n");continue;}
        printf("%lld\n",(ll)n*(ll)(n-1ll-Phi(n))%Mod*inv2%Mod);
    }
    return 0;
}

ll Phi(ll x)
{
    if (x==1) return 1;
    ll ret=x;
    for (ll i=2;i*i&lt;=x;i++)
        if (x%i==0)
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;
        }
    if (x&gt;1) ret=ret/x*(x-1);
    return ret;
}

ll Inv(ll a,ll b)
{
    ll x,y;
    Exgcd(a,b,x,y);
    return (x%b+b)%b;
}

void Exgcd(ll a,ll b,ll &amp;x,ll &amp;y)
{
    if (b==0)
    {
        x=1;y=0;
        return;
    }
    Exgcd(b,a%b,x,y);
    ll tmp=x;
    x=y;y=tmp-a/b*y;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>115</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 01:34:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 17:34:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-3501-calculation-2-%ef%bc%88%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e8%a1%a5%e9%9b%86"><![CDATA[补集]]></category>
		<category domain="category" nicename="%e8%a1%a5%e9%9b%86%e6%80%9d%e6%83%b3"><![CDATA[补集思想]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_1ea53f370a042a9b1756bf166419b50b]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[SPOJ VLATTICE] Visible Lattice Points（莫比乌斯反演）</title>
		<link>http://sycstudio.com/archives/119</link>
		<pubDate>Thu, 11 Jan 2018 22:44:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=119</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Consider a N&#42;N&#42;N lattice. One corner is at (0,0,0) and the opposite one is at (N,N,N). How many lattice points are visible from corner at (0,0,0) ? A point X is visible from point Y iff no other lattice point lies on the segment joining X and Y.

<h3>Http</h3>

<a href="http://www.spoj.com/problems/VLATTICE/en/" title="http://www.spoj.com/problems/VLATTICE/en/">http://www.spoj.com/problems/VLATTICE/en/</a>

<h3>Tag</h3>

莫比乌斯反演

<h2>题目大意</h2>

求从三维坐标系的原点&#92;((0,0,0)&#92;)朝第一卦限看去，在&#92;(n&#42;n&#42;n&#92;)的范围内能看到多少个不被遮蔽的整点

<h2>解决思路</h2>

把题目化成数学形式就是求&#92;[\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{n} \sum&#95;{k=1}^{n} [gcd(i,j,k)==1]&#92;]
考虑莫比乌斯反演。
设&#92;[F(x)=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{n} \sum&#95;{k=1}^{n} [gcd(i,j,k)==x]&#92;] &#92;[G(x)=\sum&#95;{x|d} F(d)=\sum&#95;{x|d} \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{n} \sum&#95;{k=1}^{n} [gcd(i,j,k)==d]&#92;]
看到第二个式子，由于$$gcd(i,j,k)==d$$，所以有$$d|i,d|j,d|k$$，又因为$$x|d$$，所以计算贡献可以发现$$G(x)={\lfloor \frac{n}{x} \rfloor}^3$$
那么根据莫比乌斯反演，可以得到&#92;[F(x)=\sum&#95;{x|d} \mu (\frac{d}{x})&#42;G(d)&#92;]
把$$x==1$$带进去，得到最终的式子
&#92;[F(x)=\sum&#95;{i=1}^n \mu (i) {\lfloor \frac{n}{i} \rfloor}^3&#92;]
需要注意的是，这是三维的情况，即$$gcd(i,j,k)==1$$，这要求$$i,j,k!=0$$，即没有计算在三个平面的情况。而由我们上面的分析可以知道，三个平面上的答案就是$$\sum&#95;{i=1}^n \mu (i) &#42;3&#42;{\lfloor \frac{n}{i} \rfloor}^2$$要乘三的原因是有三个平面。
当然，相信你也猜到了，我们计算这三个平面的时候，是不包括三根数轴的，所以最后还要答案要加上这三根数轴的贡献，即$$(1,0,0),(0,1,0),(0,0,1)$$，即加上三

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=1000010;
const int inf=2147483647;

int Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();

int main()
{
    GetMu();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int n;scanf("%d",&amp;n);
        ll ans=0;
        for (int i=1;i&lt;=n;i++)
        {
            ll x=n/i;
            ans=ans+(ll)Mu[i]*(ll)x*(ll)x*(ll)(x+3);
        }
        printf("%lld\n",ans+3ll);
    }
    return 0;
}

void GetMu()//线性筛求Mu
{
    Mu[1]=1;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)Prime[j]*(ll)i&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>119</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 06:44:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-11 22:44:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[spoj-vlattice-visible-lattice-points%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[ZOJ3435] Ideal Puzzle Bobble （莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/129</link>
		<pubDate>Fri, 12 Jan 2018 15:33:24 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=129</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Have you ever played Puzzle Bobble, a very famous PC game? In this game, as a very cute bobble dragon, you must keep shooting powerful bubbles to crush all the colorful bubbles upwards. Victory comes when all the bubbles upwards are crushed.

Little Tom is crazy about this game. One day, he finds that all kinds of Puzzle Bobble are 2D Games. To be more excited when playing this game, he comes up with a new idea to design a 3D Puzzle Bobble game! In this game, the bobble dragon is standing in a cubic room with L in length, W in width and H in height. Around him are so many colorful bubbles. We can use 3D Cartesian coordinates (x, y, z) to represent the locations of the bobble dragon and those bubbles. All these coordinates (x, y, z) are triple positive integers ranged from (1, 1, 1) to (L, W, H).

To simplify the problem, let's assume the bobble dragon is standing at (1, 1, 1) in the room. And there is one colorful bubble at every (x, y, z) in the room except (1, 1, 1). The dragon is so strong that he can shoot out a magical bubble to crush all the colorful bubbles in the straight line which the magical bubble flies every single time. Note that bubbles are significantly small with respect to the distances between each two bubbles. Our question remains, how many magical bubbles will the cute dragon shoot before crushing all the colorful bubbles around him?
<img src="https://odzkskevi.qnssl.com/6efa53acbde993696100f15dc519b0e5?v=1515590581" alt="" />

<h3>Http</h3>

<a href="https://vjudge.net/problem/22239/origin">zoj</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

在空间坐标系的第一卦限给定$$L&#42;H&#42;W$$的范围，问从$$(1,1,1)$$这个点看去，能看到多少个不被遮住的整数点？

<h2>解决思路</h2>

与<a href="http://sycstudio.com/archives/119">这一题</a>有些类似，都是求$$\sum&#95;{i}^{L} \sum&#95;{j}^{H} \sum&#95;{k}^{W} [gcd(i,j,k)==1] $$，但本题不同的地方是，这里是从$$(1,1,1)$$看的，所以可以考虑把整个立体空间平移到$$(0,0,0)$$，即把$$L,H,W$$都减一。
那么我们把整个立体空间分为三个部分考虑。
第一部分是三根正轴，我们定义为$$L$$轴,$$H$$轴和$$W$$轴，很容易知道这三根数轴上面的贡献分别是$$1$$。
第二部分是三个平面:$$LoH,HoW,LoR$$，三个平面分别的贡献是$$\sum&#95;{i} \sum&#95;{j} [gcd(i,j)==1]$$。
第三部分就是除去三个平面和三根数轴剩下的$$L&#42;H&#42;W$$的空间，根据上面的式子，我们知道是求$$\sum&#95;{i}^{L} \sum&#95;{j}^{H} \sum&#95;{k}^{W} [gcd(i,j,k)==1] $$
然后我们考虑如何将上面的式子化简，先来看三维的情况
设&#92;[F(x)=\sum&#95;{i}^{L} \sum&#95;{j}^{H} \sum&#95;{k}^{W} [gcd(i,j,k)==x] &#92;] &#92;[G(x)=\sum&#95;{x|d} F(d)=\sum&#95;{x|d} \sum&#95;{i}^{L} \sum&#95;{j}^{H} \sum&#95;{k}^{W} [gcd(i,j,k)==d] &#92;]可以发现，与上面那一题类似的，&#92;[G(x)=\lfloor \frac{L}{x} \rfloor &#42; \lfloor \frac{H}{x} \rfloor &#42; \lfloor \frac{W}{x} \rfloor &#92;]
好，那么根据莫比乌斯反演，可以得到&#92;[F(x)=\sum&#95;{x|d} \mu (\frac{d}{x}) G(d)&#92;] 最终得到&#92;[F(1)=\sum&#95;{i=1}^n \mu (i) \lfloor \frac{L}{i} \rfloor &#42; \lfloor \frac{H}{i} \rfloor &#42; \lfloor \frac{W}{i} \rfloor&#92;]
那么相应的，二维的情况就是&#92;[\sum&#95;{i=1}^n \mu (i) \lfloor \frac{L}{i} \rfloor &#42; \lfloor \frac{H}{i} \rfloor &#92;]
虽然说我们把$$O(n^3)$$的复杂度降到了$$O(n)$$，但是这还不够，因为题目有多组数据。怎么办呢？我们来看到这组例子。
&#92;[\lfloor \frac{100}{20} \rfloor =5 &#92;&#92; \lfloor \frac{100}{21} \rfloor =\lfloor \frac{100}{22} \rfloor =\lfloor \frac{100}{23} \rfloor =\lfloor \frac{100}{24} \rfloor =\lfloor \frac{100}{25} \rfloor =4 \lfloor \frac{100}{26} \rfloor =3 &#92;&#92; ……&#92;]
我们发现，对于$$n==100$$的时候，$$i=21,22,23,24,25$$时的代价是一样的，并且这个相同的区间在$$i$$变大的时候，区间也会越来越大。
这就是<strong>数论分块</strong>的原理：考虑把一样的东西一起做。$$\lfloor \frac{n}{\frac{n}{i}} \rfloor$$这样就可以找到与$$i$$在同一区间（同一个块）的最后一个位置，利用提前计算好的$$\mu(i)$$的前缀和，就可以一个区间一个区间地算了

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=1000010;
const int inf=2147483647;

int n;
ll Mu[maxNum],SumMu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];
int L,W,H;

void GetMu();

int main()
{
    GetMu();
    while (scanf("%d%d%d",&amp;L,&amp;W,&amp;H)!=EOF)
    {
        L--;W--;H--;
        ll ans=3;
        int limit=min(L,min(W,H));
        for (int i=1,last=1;i&lt;=limit;i=last+1)
        {
            ll k1=L/i,k2=W/i,k3=H/i;
            last=min(L/k1,min(W/k2,H/k3));
            ans=ans+(SumMu[last]-SumMu[i-1])*k1*k2*k3;
        }
        limit=min(L,W);
        for (int i=1,last=1;i&lt;=limit;i=last+1)
        {
            ll k1=L/i,k2=W/i;
            last=min(L/k1,W/k2);
            ans=ans+(SumMu[last]-SumMu[i-1])*k1*k2;
        }
        limit=min(L,H);
        for (int i=1,last=1;i&lt;=limit;i=last+1)
        {
            ll k1=L/i,k2=H/i;
            last=min(L/k1,H/k2);
            ans=ans+(SumMu[last]-SumMu[i-1])*k1*k2;
        }
        limit=min(W,H);
        for (int i=1,last=1;i&lt;=limit;i=last+1)
        {
            ll k1=W/i,k2=H/i;
            last=min(W/k1,H/k2);
            ans=ans+(SumMu[last]-SumMu[i-1])*k1*k2;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void GetMu()
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]!=0) Mu[i*Prime[j]]=-Mu[i];
            else break;
        }
    }
    for (int i=1;i&lt;maxNum;i++) SumMu[i]=SumMu[i-1]+Mu[i];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>129</wp:post_id>
		<wp:post_date><![CDATA[2018-01-12 23:33:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-12 15:33:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[zoj-3435-ideal-puzzle-bobble-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="zoj"><![CDATA[ZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>练习计划</title>
		<link>http://sycstudio.com/archives/141</link>
		<pubDate>Sat, 13 Jan 2018 18:23:14 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=141</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>目前计划</h1>

<h2>数论部分</h2>

<h3>莫比乌斯反演：</h3>

[S] HDU 1695 GCD
[S] HDU 4746 Mophues
[S] HDU 5212 Code （备注：此题还可以用容斥做，未实现）
[D] HDU 5321 Beautiful Set
HDU 5663 Hillan and the girl
HDU 6053 TrickGCD
HDU 6134 Battlestation Operational
HDU 4947 GCD Array
[S] BZOJ 2005 [Noi2010]能量采集
[S] BZOJ 2154 Crash的数字表格
[S] BZOJ 2301 [HAOI2011]Problem b
[S] BZOJ 2820 YY的GCD
[S] BZOJ 2440 [中山市选2011]完全平方数
[S] BZOJ 2818 Gcd
[S] BZOJ 3994 [SDOI2015]约数个数和
[S] BZOJ 4407 于神之怒加强版
[S] BZOJ 4816 [Sdoi2017]数字表格
[S] BZOJ 2693 jzptab
[S] CJOJ 2512 【UVA 11426】gcd之和
BZOJ 2186 [Sdoi2008]沙拉公主的困惑
POJ 3904 Sky Code
[S] UVA 11426 GCD - Extreme (II)

<h3>高斯消元</h3>

[S] BZOJ 1013 [JSOI2008]球形空间产生器sphere
BZOJ 3569 DZY Loves Chinese II
BZOJ 1923 [Sdoi2010]外星千足虫
BZOJ 2337 [HNOI2011]XOR和路径
BZOJ 3143 [Hnoi2013]游走
BZOJ 4004 [JLOI2015]装备购买
HDU 4418 Time travel
HDU 3364 Lanterns
HDU 4870 Rating
HDU 4936 Rainbow Island
HDU 4592 Boring仪仗队
BZOJ 1968 [Ahoi2005]COMMON 约数研究
BZOJ 1477 青蛙的约会
BZOJ 1008 [HNOI2008]越狱
BZOJ 2729 [HNOI2012]排队
BZOJ 4804 欧拉心算
BZOJ 1406 [AHOI2007]密码箱
Luogu 1414 又是毕业季II
<a href="https://www.zybuluo.com/l1ll5/note/1027211">参考：随机游走相关</a>

<h3>扩展欧拉定理</h3>

[S] BZOJ 3884 上帝与集合的正确用法
BZOJ 4869 [Shoi2017]相逢是问候
HDU 3221 Brute-force Algorithm
HDU 5895 Mathematician QSC
HDU 3221 Brute-force Algorithm

<h3>多项式exp</h3>

<a href="http://www.mamicode.com/info-detail-1403144.html">参考</a>

<h2>数据结构</h2>

<h3>线段树：</h3>

[S] BZOJ 4071 巴邻旁之桥 
BZOJ 1018 [SHOI2008]堵塞的交通traffic
BZOJ 3295 [Cqoi2011]动态逆序对
BZOJ 4653 [noi2006] 区间
BZOJ 4355 Play with sequence
Luogu 1973 [NOI2011]Noi嘉年华
HDU 5692 Snacks
HDU 4942 Game on S♂play
HDU 4578 Transformation

<h4>线段树合并</h4>

BZOJ 4552 [Tjoi2016&amp;Heoi2016]排序
BZOJ 2212 [Poi2011]Tree Rotations
BZOJ 4756 [Usaco2017 Jan]Promotion Counting
BZOJ 3307 雨天的尾巴
[S] HDU 5709 Claris Loves Painting

<h3>平衡树</h3>

[S] BZOJ 3506 [Cqoi2014]排序机械臂
BZOJ 3196 Tyvj 1730 二逼平衡树
[S] BZOJ 1483 [HNOI2009]梦幻布丁
BZOJ 3110 [Zjoi2013]K大数查询
HDU 5324 Boring Class

<h3>主席树</h3>

[S] BZOJ 4012 [HNOI2015]开店
BZOJ 1926 [Sdoi2010]粟粟的书架
BZOJ 4571 [Scoi2016]美味
[S] BZOJ 3932 [CQOI2015]任务查询系统
BZOJ 3123 [Sdoi2013]森林
[S] BZOJ 2588 Spoj 10628. Count on a tree
BZOJ 1901 Dynamic Ranking
BZOJ 2006 [NOI2010]超级钢琴
SNMOJ 257 训练
[S] HDU 2665 Kth number
[S] HDU 4417 Super Mario
HDU 5919 Sequence II
HDU 4348 To the moon
SPOJ 3267 D-query

<h3>Link-Cut-Tree</h3>

[S] BZOJ 4736 温暖会指引我们前行
[S] BZOJ 4825 [Hnoi2017]单旋
BZOJ 5020 [THUWC 2017]在美妙的数学王国中畅游
[S] BZOJ 3669 [Noi2014]魔法森林
[S] BZOJ 3514 Codechef MARCH14 GERALD07加强版
[S] BZOJ 1969 航线规划
Luogu 3206 [HNOI2010]CITY 城市建设
BZOJ 4817 [Sdoi2017]树点涂色
[S] BZOJ 2959 长跑
[S] BZOJ 4998 星球联盟
[S] BZOJ 4530 [Bjoi2014]大融合
BZOJ 2594 [Wc2006]水管局长数据加强版 
[S] HDU 5398 GCD Tree
HDU 4718 The LCIS on the Tree
HDU 5002 Tree
HDU 5333 Undirected Graph
HDU 5967 小R与手机
HDU 6200 mustedge mustedge mustedge
[S] UOJ 207 共价大爷游长沙
Luogu 3348 [ZJOI2016]大森林

<h3>左偏树</h3>

[S] BZOJ 4003 [JLOI2015]城池攻占
[S] BZOJ 2809 [Apio2012]dispatching
BZOJ 1455 罗马游戏
BZOJ 1367 [Baltic2004]sequence
BZOJ 2333 [SCOI2011]棘手的操作
[S] Luogu 3066 [USACO12DEC]逃跑的BarnRunning Away From…
[S] HDU 5818 Joint Stacks
[S] HDU 3031 To Be Or Not To Be
[S] HDU 1512 Monkey King

<h3>树链剖分</h3>

[S] BZOJ 3626 [LNOI2014]LCA（也可以LCT）
[S] BZOJ 3531 [Sdoi2014]旅行
BZOJ 4196 [Noi2015]软件包管理器
BZOJ 4538 [Hnoi2016]网络
BZOJ 4034 [HAOI2015]树上操作
[S] BZOJ 2157 旅游
Luogu 2243 电路维修
CJOJ 2440 大话

<h3>KD-Tree</h3>

<a href="http://ljqpaper.duapp.com/index.php/archives/177/">jesseliu612</a>

<h3>虚树</h3>

<a href="https://www.cnblogs.com/zzqsblog/p/5560645.html">参考</a>
<a href="http://blog.csdn.net/horizon_smz/article/details/50668658">题集</a>

<h2>算法</h2>

<h3>点分治，动态点分治：</h3>

BZOJ 4372 烁烁的游戏
BZOJ 3730 震波
BZOJ 3924 [Zjoi2015]幻想乡战略游戏
BZOJ 1095 [ZJOI2007]Hide 捉迷藏
[S] BZOJ 2152 聪聪可可
[S] HDU 5977 Garden of Eden
HDU 4812 D Tree
HDU 5909 Tree Cutting
HDU 5469 Antonidas

<h3>CDQ分治</h3>

BZOJ 2726 [SDOI2012]任务安排
Luogu 1393 动态逆序对
各种偏序

<h3>动态规划</h3>

[S] BZOJ 1076 [SCOI2008]奖励关
[S] BZOJ 3675 [Apio2014]序列分割
[S] BZOJ 2748 [HAOI2012]音量调节
[S] BZOJ 1084 [SCOI2005]最大子矩阵
[S] BZOJ 1003 [ZJOI2006]物流运输
[S] BZOJ 4872 [shoi2017]分手是祝愿
[S] BZOJ 1087 [SCOI2005]互不侵犯King
[S] BZOJ 1801 [Ahoi2009]chess 中国象棋
BZOJ 2734 [HNOI2012]集合选数
BZOJ 1207 [HNOI2004]打鼹鼠
BZOJ 1040 [ZJOI2008]骑士
BZOJ 1017 [JSOI2008]魔兽地图DotR
BZOJ 3997 [TJOI2015]组合数学
BZOJ 1037 [ZJOI2008]生日聚会Party
HDU 6170 Two strings
SPOJ - BALNUM Balanced Numbers（数位？）

<h3>三分</h3>

BZOJ 1857 [Scoi2010]传送带
BZOJ 4868 [Shoi2017]期末考试
BZOJ 3330 [BeiJing2013]分数
BZOJ 4014 [FJOI2014]病毒防护带
BZOJ 3874 [Ahoi2014&amp;Jsoi2014]宅男计划
BZOJ 3203 [Sdoi2013]保护出题人
HDU 2438 Turn the corner
HDU 2298 Toxophily

<h3>莫队算法</h3>

[S] BZOJ 1878 [SDOI2009]HH的项链
[S] BZOJ 2120 数颜色
[S] BZOJ 2038 [2009国家集训队]小Z的袜子(hose)
BZOJ 4540 [Hnoi2016]序列
BZOJ 3460 jc的宿舍
Luogu 2709 小B的询问

<h2>字符串</h2>

<h3>后缀数组</h3>

POJ 2774 Long Long Message
Hihocoder 1403 后缀数组一·重复旋律
Hihocoder 1407 后缀数组二·重复旋律2
POJ 1743 Musical Theme
POJ 3261 Milk Patterns
<a href="https://www.cnblogs.com/kuangbin/category/473752.html">参考</a>

<h3>KMP算法</h3>

[S] HDU 6153 A Secret
[S] HDU 2203 亲和串
[S] HDU 4763 Theme Section
[S] HDU 3746 Cyclic Nacklace
[S] BZOJ 3670 [Noi2014]动物园

<h3>AC自动机</h3>

BZOJ 3172 [Tjoi2013]单词
BZOJ 2754 [SCOI2012]喵星球上的点名
BZOJ 3530 [Sdoi2014]数数
BZOJ 1444 [Jsoi2009]有趣的游戏
BZOJ 2434 [Noi2011]阿狸的打字机
BZOJ 2553 [BeiJing2011]禁忌
Luogu 3041 [USACO12JAN]视频游戏的连击Video Game Combos
POJ 1625 Censored!
POJ 3691 DNA repair
POJ 2778 DNA Sequence
HDU 2296 Ring

<h2>图论</h2>

<h3>网络流</h3>

[S] BZOJ 2132 圈地计划
[S] BZOJ 2127 happiness
[S] BZOJ 1189 [HNOI2007]紧急疏散evacuate
[S] BZOJ 4554 [Tjoi2016&amp;Heoi2016]游戏
[S] BZOJ 3993 [SDOI2015]星际战争
[S] BZOJ 3140 [Hnoi2013]消毒
BZOJ 1305 [CQOI2009]dance跳舞
BZOJ 3931 [CQOI2015]网络吞吐量
BZOJ 2324 [ZJOI2011]营救皮卡丘
BZOJ 3144 [Hnoi2013]切糕
BZOJ 2768 [JLOI2010]冠军调查
BZOJ 2756 [SCOI2012]奇怪的游戏
BZOJ 1059 [ZJOI2007]矩阵游戏
BZOJ 3996 [TJOI2015]线性代数
BZOJ 3876 [Ahoi2014&amp;Jsoi2014]支线剧情
BZOJ 5120 [2017国家集训队测试]无限之环
Luogu 2570 [ZJOI2010]贪吃的老鼠
CF 802C Heidi and Library(hard)
<a href="http://blog.csdn.net/jzq233jzq/article/details/73123089">zkw费用流</a>

<h3>传递闭包</h3>

POJ 2594 Treasure Exploration
HDU 1704 Rank

<h3>图论综合</h3>

[S] BZOJ 1064 [Noi2008]假面舞会
BZOJ 3436 小K的农场
BZOJ 2330 [SCOI2011]糖果
[S] BZOJ 1924 [Sdoi2010]所驼门王的宝藏
BZOJ 1922 [Sdoi2010]大陆争霸
[S] BZOJ 1143 [CTSC2008]祭祀river
BZOJ 1027 [JSOI2007]合金（需要计算几何）
BZOJ 2753 [SCOI2012]滑雪与时间胶囊
Luogu 3731 [HAOI2017]新型城市化

<h2>欧拉回路</h2>

UOJ 117 欧拉回路
BZOJ 3303
BZOJ 2095

<h2>其它</h2>

<h3>一些奇怪的科技</h3>

<h4>高维前缀和</h4>

[S] SPOJ TLE - Time Limit Exceeded
CF 449D Jzzhu and Numbers
Hdu 5765 Bonds
BZOJ 5092 分割序列
<a href="http://blog.csdn.net/WeYoungg/article/details/77073140">参考</a>

<h3>真·其它</h3>

BZOJ 4195 [Noi2015]程序自动分析
BZOJ 1216 [HNOI2003]操作系统
BZOJ 1975 [Sdoi2010]魔法猪学院
BZOJ 1875 [SDOI2009]HH去散步
BZOJ 1972 [Sdoi2010]猪国杀
BZOJ 1150 [CTSC2007]数据备份Backup
Luogu 1196 [NOI2002]银河英雄传说
HDU 5242 Game
HDU 5245 Joyful

<a href="https://vjudge.net/article/55">参考</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>141</wp:post_id>
		<wp:post_date><![CDATA[2018-01-14 02:23:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-13 18:23:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b0%b4%e8%a1%a8%e8%ae%b0%e5%bd%95%ef%bc%88%e7%bb%83%e4%b9%a0%e8%ae%a1%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[songyuchen]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="mine"><![CDATA[mine]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>48</wp:comment_id>
			<wp:comment_author><![CDATA[zhoushuyu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[978982520@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-26 12:53:39]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-26 04:53:39]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[BZOJ2333棘手的操作就是左偏树~~毒瘤题~~呀]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>7</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>50</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-27 08:42:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-27 00:42:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已更正]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>48</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>[HDU1695]GCD （莫比乌斯反演）</title>
		<link>http://sycstudio.com/archives/146</link>
		<pubDate>Sat, 13 Jan 2018 21:35:52 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=146</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Given 5 integers: a, b, c, d, k, you're to find x in a...b, y in c...d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you're only required to output the total number of different number pairs.
Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same.

Yoiu can assume that a = c = 1 in all test cases.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-1695">HDU</a>

<h3>Tag</h3>

莫比乌斯反演

<h2>题目大意</h2>

给定&#92;(a,b,K&#92;)求&#92;(\sum&#95;i^a \sum&#95;j^b [gcd(i,j)==K]&#92;)

<h2>解决思路</h2>

设&#92;[F(x)=\sum&#95;i^a \sum&#95;j^b [gcd(i,j)==K]&#92;] &#92;[G(x)=\sum&#95;{x|d} F(d)&#92;]
&#92;[G(x)=\sum&#95;{x|d} \sum&#95;i^a \sum&#95;j^b [gcd(i,j)==d]=\lfloor \frac{a}{x} \rfloor &#42; \lfloor \frac{b}{x} \rfloor &#92;]
那么根据莫比乌斯反演，可以得到
&#92;[F(x)=\sum&#95;{x|d} \mu (\frac{d}{x}) &#42; \lfloor \frac{a}{d} \rfloor &#42; \lfloor \frac{b}{d} \rfloor &#92;]
但是同时要注意到，题目中表明了$$(a,b)$$与$$(b,a)$$是同一种方案，所以接下来考虑如何去重。
我们假定$$a\leq b$$，记包括了重复的答案为$$ans$$。我们知道$$[1,a]$$的方案是被重复算了的，所以我们再算一遍到$$a$$的代价，记为$$sum$$。需要注意的是，这里的$$sum$$中计算的也是计算了两次的，所以最终的答案应该是$$sum-\frac{ans}{2}$$
最后要注意的是，$$K$$可以取到$$0$$，所以要特判

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=100010;
const int inf=2147483647;

int a,b,c,d,k;
ll Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();//线性筛求Mu

int main()
{
    GetMu();
    int T;scanf("%d",&amp;T);
    for (int ti=1;ti&lt;=T;ti++)
    {
        scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);
        if (k==0)
        {
            printf("Case %d: 0\n",ti);
            continue;
        }
        if (d&lt;b) swap(b,d);
        ll ans=0,sum=0;
        for (ll i=k;i&lt;=b;i+=k)//先计算出包括重复的
            if (i%k==0) ans=ans+Mu[i/k]*(ll)(b/i)*(ll)(d/i);
        for (ll i=k;i&lt;=b;i+=k)//求出重复的
            if (i%k==0) sum=sum+Mu[i/k]*(ll)(b/i)*(ll)(b/i);
        printf("Case %d: %lld\n",ti,ans-sum/2);//算出最终答案
    }
    return 0;
}

void GetMu()
{
    Mu[1]=1;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Mu[i]=-1,Prime[++pricnt]=i;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>146</wp:post_id>
		<wp:post_date><![CDATA[2018-01-14 05:35:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-13 21:35:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1695-gcd-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4746] Mophues （莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/156</link>
		<pubDate>Sun, 14 Jan 2018 13:14:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=156</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

As we know, any positive integer C ( C >= 2 ) can be written as the multiply of some prime numbers:
&#92;(C = p&#95;1&#42;p&#95;2&#42;p&#95;3&#42;...&#42;p_k&#92;)
which &#92;(p&#95;1, p&#95;2 ... p&#95;k&#92;)are all prime numbers.For example, if &#92;(C = 24&#92;), then:
&#92;(24 = 2&#42;2&#42;2&#42;3&#92;)
here, &#92;(p&#95;1 = p&#95;2 = p&#95;3 = 2, p&#95;4 = 3, k = 4&#92;)

Given two integers P and C. if k&lt;=P( k is the number of C's prime factors), we call C a lucky number of P.

Now, XXX needs to count the number of pairs (a, b), which 1&lt;=a&lt;=n , 1&lt;=b&lt;=m, and gcd(a,b) is a lucky number of a given P ( "gcd" means "greatest common divisor").

Please note that we define 1 as lucky number of any non-negative integers because 1 has no prime factor.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-4746">HDU</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

设$$Fact(x)$$表示把$$x$$唯一分解后，分解出来的质因子的个数（注意，相同的质因子不算同一个），求&#92;[\sum&#95;{i}^{n} \sum&#95;{j}^{m} [Fact(gcd(i,j))&lt;=P] &#92;]

<h2>解决思路</h2>

首先考虑$$Fact(x)$$这个函数，我们发现它是可以线性筛出来的，具体来说，根据其性质可以这样递推出来
设$$p$$为质数
&#92;[\begin{cases} Fact(p)=1 &#92;&#92; Fact(p^k)=k &#92;&#92; Fact(p&#42;i)=Fact(i)+1 \end{cases}&#92;]
由于对于每一个$$x=gcd(i,j)$$，其$$Fact(x)$$是一定的，所以我们先不考虑这个质因子个数的限制。
设&#92;[f(x)=\sum&#95;{i}^{n} \sum&#95;{j}^{m} [gcd(i,j)==x]&#92;] &#92;[g(x)=\sum&#95;{x|d} f(d)&#92;]
根据我们之前做过的题目（<a href="http://sycstudio.com/archives/119">比如这里</a>），可以知道$$g(x)=\lfloor \frac{n}{x} \rfloor &#42; \lfloor \frac{m}{x} \rfloor$$，根据莫比乌斯反演，可以得到$$f(x)=\sum&#95;{x|d} g(d)$$。
假定我们最后要求的是$$\sum&#95;{i} f(i)$$（也就是不考虑$$P$$的限制时的方案数），那么我们现在得到了一种$$O(n&#42;\sqrt{n})$$的办法，就是枚举$$i$$算出每一个$$f(i)$$求和，而算$$f(i)$$的过程可以通过数论分块降到$$O(\sqrt{n})$$的复杂度。
很明显，对于题目的数据范围，这样的复杂度是不行的。考虑到是求和操作，我们来看一看每一个$$g(x)$$最后给答案贡献了多少次。
&#92;[f(1)=\mu(\frac{1}{1})&#42;g(1)+\mu(\frac{2}{1})&#42;g(2)+\mu(\frac{3}{1})&#42;g(3)...... &#92;&#92; f(2)=\mu(\frac{2}{2})&#42;g(2)+\mu(\frac{4}{2})&#42;g(4)+\mu(\frac{6}{2})&#42;g(6)...... &#92;&#92; f(3)=\mu(\frac{3}{3})&#42;g(3)+\mu(\frac{6}{3})&#42;g(6)+\mu(\frac{9}{3})&#42;g(9)...... &#92;&#92; ...... &#92;&#92; f(x)=\mu(\frac{1&#42;x}{x})&#42;g(1&#42;x)+\mu(\frac{2&#42;x}{x})&#42;g(2&#42;x)+\mu(\frac{3&#42;x}{x})&#42;g(3&#42;x)......&#92;&#92; =\mu(1)&#42;g(1&#42;x)+\mu(2)&#42;g(2&#42;x)+\mu(3)&#42;g(3&#42;x).....&#92;]
可以发现，每一个数$$x$$给它的倍数$$d=kx$$的$$g(d)$$贡献了$$\mu(j)$$的莫比乌斯系数，所以我们可以考虑线性推出这个系数的和。设$$F[d]$$表示$$g(d)$$前面莫比乌斯系数的和，那么枚举$$x$$的倍数$$d=kx$$，$$F[d]+=\mu (\frac{d}{x})$$。
最后我们把对质因子个数的条件放进去。先考虑要求质因子个数一定等于$$P$$的。这时候也就是说对于一个数$$x$$，它只能在给定的$$P$$与它的质因子个数相同的时候才能贡献，所以考虑把$$F[d]$$加一维变成$$F&#91;d&#93;&#91;p&#93;$$，表示$$x$$分解质因子个数为$$p$$时对$$x$$的倍数$$d=kx$$的$$g(d)$$的贡献，那么就是$$F&#91;d&#93;&#91;Fact(x)]+=\mu(\frac{d}{x})$$。
最后把条件再放宽，即质因子个数小于等于$$P$$的，那么求$$[p]$$这一维的前缀和即可。由于我们需要数论分块将复杂度，需要求$$[d]$$这一维的前缀和，所以我们求二维前缀和即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=500010;
const int maxP=20;
const int inf=2147483647;

int n,m,P,Q;
ll Mu[maxNum];
ll Fact[maxNum];//每一个数分解后有多少个质因子
ll pricnt=0,Prime[maxNum];
bool notprime[maxNum];
ll F[maxNum][maxP];

void GetMu();

int main()
{
    GetMu();
    for (int i=1;i&lt;maxNum;i++)//求F[d][p]
        for (int j=i;j&lt;maxNum;j+=i)
            F[j][Fact[i]]+=Mu[j/i];
    for (int i=0;i&lt;maxNum;i++)//求前缀和，注意因为要累加0的前缀和，所以把行和列分开考虑
        for (int j=1;j&lt;maxP;j++)
            F[i][j]+=F[i][j-1];
    for (int i=1;i&lt;maxNum;i++)
        for (int j=0;j&lt;maxP;j++)
            F[i][j]+=F[i-1][j];
    scanf("%d",&amp;Q);
    while (Q--)
    {
        scanf("%d%d%d",&amp;n,&amp;m,&amp;P);
        if (P&gt;=maxP)
        {
            printf("%lld\n",(ll)n*(ll)m);
            continue;
        }
        ll ans=0;
        if (m&lt;n) swap(n,m);
        for (int i=1,last;i&lt;=n;i=last+1)//数论分块求解
        {
            last=min(n/(int)(n/i),m/(int)(m/i));
            ans=ans+(F[last][P]-F[i-1][P])*(ll)(n/i)*(ll)(m/i);
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void GetMu()//线性筛
{
    notprime[1]=1;Mu[1]=1;Fact[1]=0;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1,Fact[i]=1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            Fact[i*Prime[j]]=Fact[i]+1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>156</wp:post_id>
		<wp:post_date><![CDATA[2018-01-14 21:14:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-14 13:14:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-4746-mophues-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5212]Code （莫比乌斯反演）</title>
		<link>http://sycstudio.com/archives/169</link>
		<pubDate>Sun, 14 Jan 2018 19:26:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=169</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

WLD likes playing with codes.One day he is writing a function.Howerver,his computer breaks down because the function is too powerful.He is very sad.Can you help him?

The function:

<pre><code class="cpp">int calc
{
  int res=0;
  for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=n;j++)
    {
      res+=gcd(a[i],a[j])*(gcd(a[i],a[j])-1);
      res%=10007;
    }
  return res;
} 
</code></pre>

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5212">HDU</a>

<h3>Tag</h3>

莫比乌斯反演

<h2>题目大意</h2>

求&#92;[\sum&#95;{i}^{n} \sum&#95;{j}^{n} gcd(A[i],A[j])&#42;(gcd(A[i],A[j])-1)&#92;]

<h2>解决思路</h2>

换一个思路，考虑到值域直到&#92;(10000&#92;)，所以可以开桶统计每一个数出现了多少次，记&#92;(Cnt[i]&#92;)表示数&#92;(i&#92;)出现了多少次。在值域里枚举，那么答案就是&#92;[Ans=\sum&#95;{i}^{10000} \sum&#95;{j}^{10000} Cnt[i]&#42;Cnt[j]&#42;gcd(i,j)&#42;(gcd(i,j)-1)&#92;]
令&#92;(f(x)=x&#42;(x-1)&#92;)，构造$$g(x)$$，使$$f(x)=\sum&#95;{d|x} g(d)$$，则根据莫比乌斯反演，可以得到$$g(x)=\sum&#95;{d|x}\mu(\frac{x}{d}) f(d)$$。
这样有什么用呢？根据我们得到的$$g(x)$$，我们可以把对答案的求解式化成这个形式
&#92;[Ans=\sum&#95;{i}^{10000} \sum&#95;{j}^{10000} Cnt[i]&#42;Cnt[j]&#42;\sum&#95;{d|i,d|j} g(d)&#92;]
为什么可以这样化呢？因为$$d|i,d|j$$保证了$$d$$一定是$$i,j$$的因子，而$$\sum&#95;{d|x} g(d)=f(x)$$，所以就可以直接替换原来的$$gcd$$
那么接着我们把原来枚举$$i,j$$换成枚举$$d$$，即把后面的$$\sum$$换到前面来。考虑每一对$$i,j$$对$$d$$的贡献，那么式子可以这样列
&#92;[Ans=\sum&#95;{d}^{10000} \sum&#95;{d|i}^{10000} \sum&#95;{d|j}^{10000} Cnt[i]&#42;Cnt[j] &#42;g(d)&#92;]
重新观察一下这个式子，既然我们把$$d$$已经提到外面了，那么里面枚举的$$i$$和$$j$$其实是一样的，那么我们可以把两次枚举合二为一
&#92;[Ans=\sum&#95;{d}^{10000} g(d) &#42; {(\sum&#95;{d|i} Cnt[i])}^2&#92;]
这样，计算的复杂度就降到$$O(n\sqrt{n})$$

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=10010;
const int Mod=10007;
const int inf=2147483647;

int Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];
int n,Cnt[maxNum];
ll G[maxNum];

void GetMu();//线性筛莫比乌斯函数

int main()
{
    GetMu();
    for (int i=1;i&lt;maxNum;i++)//得到我们构造的函数G
    {
        int j;
        for (j=1;j*j&lt;i;j++)
            if (i%j==0)
                G[i]=((G[i]+Mu[i/j]*j%Mod*(j-1)%Mod+Mu[i/(i/j)]*(i/j)%Mod*(i/j-1)%Mod)%Mod+Mod)%Mod;
        if (j*j==i) G[i]=((G[i]+Mu[i/j]*j%Mod*(j-1)%Mod)%Mod+Mod)%Mod;
    }
    while (scanf("%d",&amp;n)!=EOF)
    {
        mem(Cnt,0);//桶
        for (int i=1;i&lt;=n;i++)
        {
            int x;scanf("%d",&amp;x);
            Cnt[x]++;//桶计数
        }
        ll ans=0;
        for (int i=1;i&lt;maxNum;i++)//这里就是按照那个式子求解了
        {
            ll sum=0;
            for (int j=i;j&lt;maxNum;j=j+i) sum=(sum+Cnt[j])%Mod;
            sum=sum*sum%Mod;
            ans=((ans+sum*G[i]%Mod)%Mod+Mod)%Mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void GetMu()//线性筛
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j])&lt;maxNum;j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>169</wp:post_id>
		<wp:post_date><![CDATA[2018-01-15 03:26:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-14 19:26:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-5212-code-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[杜少龙]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://blog.csdn.net/DSL_HN_2002/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-16 02:54:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-16 10:54:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[求交换友链]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[UVA11426]GCD - Extreme (II) （莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/180</link>
		<pubDate>Mon, 15 Jan 2018 19:43:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=180</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Given the value of N, you will have to find the value of G. The definition of G is given below:

Here GCD(i,j) means the greatest common divisor of integer i and integer j.

For those who have trouble understanding summation notation, the meaning of G is given in the following code:

<pre><code class="cpp">G=0;
for(i=1;i&lt;N;i++)
    for(j=i+1;j&lt;=N;j++)
    {
        G+=gcd(i,j);
    }
/*Here gcd() is a function that finds the greatest common divisor of the two input numbers*/
</code></pre>

<h3>Http</h3>

<a href="https://vjudge.net/problem/UVA-11426">UVA</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

给定&#92;(N&#92;)，求&#92;(\sum&#95;{i=1}^{N} \sum&#95;{j=i+1}^{N} gcd(i,j)&#92;)

<h2>解决思路</h2>

先不考虑&#92;(j=i+1&#92;)的限制，假设&#92;(j&#92;)也是&#92;([1,n]&#92;)，则有
&#92;[Ans=\sum&#95;{i=1}^{N} \sum&#95;{j=1}^{N} gcd(i,j) &#92;]
我们设&#92;(gcd(i,j)==d&#92;)，把&#92;(d&#92;)提出来
&#92;[Ans=\sum&#95;{d}^{N} d &#42; \sum&#95;{i}^{N} \sum&#95;{j}^{N} [gcd(i,j)==d]=\sum&#95;{d}^{N} d &#42; \sum&#95;{i}^{N/d} \sum&#95;{j}^{N/d} [gcd(i,j)==1]&#92;]
观察里面这一部分，就是莫比乌斯反演的经典例子。根据前面的题，可以得到
&#92;[\sum&#95;{i}^{N/d} \sum&#95;{j}^{N/d} [gcd(i,j)==1]=\sum&#95;{i}^{N/d} \mu(i) &#42;\lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor &#42; \lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor&#92;]
把这个等式代回去，可以得到
&#92;[Ans=\sum&#95;{d=1}^{N} d&#42; \sum&#95;{i=1}^{n/d} \mu(i) &#42; \lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor &#42; \lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor&#92;]
这样直接算的复杂度是$$O(n&#42;n)=O(n^2)$$的。考虑数论分块降低复杂度。由于对于外面的&#92;(d&#92;)，&#92;(n/d&#92;)对于多个连续的&#92;(d&#92;)的取值是一样的，外面可以数论分块。同理，&#92;(\lfloor \frac{\lfloor \frac{N}{d} \rfloor }{i} \rfloor&#92;)也是可以分块做的。所以复杂度就降为&#92;(O(\sqrt{n}&#42;\sqrt{n})=O(n)&#92;)。
最后我们把&#92;(j=i+1&#92;)的条件加上，其实意思就是不能重复计算&#92;(gcd(i,j)&#92;)和&#92;(gcd(j,i)&#92;)。考虑我们上面的&#92;(Ans&#92;)计算出来的，它是把每一个&#92;(gcd(i,i)&#92;)都计算了一遍，再加上对于&#92;(i &lt; j&#92;)，&#92;(gcd(i,j)&#92;)计算了两边，即既计算了&#92;(gcd(i,j)&#92;)，又计算了&#92;(gcd(j,i)&#92;)。所以我们可以在&#92;(Ans&#92;)中先减去&#92;(gcd(i,i)&#92;)这一类的贡献（其实就是&#92;(1..n&#92;)的等差数列），再除以二。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=4000010;
const int inf=2147483647;

ll Mu[maxNum];
ll Musum[maxNum];
ll pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();//线性筛求mu
ll Calc(ll n);//内层线性筛

int main()
{
    GetMu();
    ll n;
    while (scanf("%lld",&amp;n)!=EOF)
    {
        if (n==0) break;
        ll ans=0;
        for (ll i=1,last;i&lt;=n;i=last+1)//外层线性筛
        {
            last=n/(n/i);
            ans=ans+(last+i)*(last-i+1)/2*Calc(n/i);
        }
        printf("%lld\n",(ans-n*(n+1)/2)/2);
    }
    return 0;
}

void GetMu()
{
    Mu[1]=1;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i];
    return;
}

ll Calc(ll n)//内层线性筛
{
    ll ret=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=n/(n/i);
        ret=ret+(Musum[last]-Musum[i-1])*(ll)(n/i)*(ll)(n/i);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>180</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 03:43:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-15 19:43:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[uva-11426-gcd-extreme-ii-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="uva"><![CDATA[UVA]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="uva"><![CDATA[UVA]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2005/Luogu1447][NOI2010]能量采集（莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/186</link>
		<pubDate>Mon, 15 Jan 2018 21:36:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=186</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。 栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。 由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。 能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。 下面给出了一个能量采集的例子，其中n = 5，m = 4，一共有20棵植物，在每棵植物上标明了能量汇集机器收集它的能量时产生的能量损失。 在这个例子中，总共产生了36的能量损失。
<img src="http://sycstudio.com/wp-content/uploads/2018/01/bzoj2005.jpg" alt="BZOJ2005" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2005">BZOJ</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

求&#92;[\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} (2&#42;gcd(i,j)-1)&#92;]

<h2>解决思路</h2>

&#92;[Ans=2&#42; \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j) -n&#42;m&#92;]
那么就是关键是求&#92;[\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j)&#92;]
提取&#92;(gcd(i,j)==d&#92;)，假设&#92;(n &lt; m&#92;)，那么有
&#92;[\sum&#95;{d=1}^{n} d &#42; \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==d]=\sum&#95;{d=1}^{n} \sum&#95;{i=1}^{n/i} \sum&#95;{j=1}^{m/d} [gcd(i,j)==1]&#92;]
后面那一部分可以莫比乌斯反演一下，根据&#92;[\sum&#95;{i}^{n} \sum&#95;{j}^{m} [gcd(i,j)==1] =\sum&#95;{i=1}^{n} \mu(i) \lfloor \frac{n}{i} \rfloor &#42; \lfloor \frac{m}{i} \rfloor &#92;]，式子可以化为
&#92;[\sum&#95;{d=1}^{n} d &#42; \sum&#95;{i=1}^{n/d} \mu(i) &#42; \lfloor \frac{n/d}{i} \rfloor &#42; \lfloor \frac{m/d}{i} \rfloor&#92;]
这样，可以外层与内层两次数论分块计算，复杂度为&#92;(O(\sqrt{n}&#42;\sqrt{n})=O(n)&#92;)

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=100010;
const int inf=2147483647;

int Mu[maxNum];
ll Musum[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();
ll Calc(ll n,ll m);//内层数论分块求

int main()
{
    GetMu();
    ll n,m;
    scanf("%lld%lld",&amp;n,&amp;m);if (m&lt;n) swap(n,m);
    ll ans=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));//外层数论分块
        ans=ans+(ll)(last+i)*(ll)(last-i+1)/2ll*Calc(n/i,m/i);
    }
    printf("%lld\n",ans*2-n*m);
    return 0;
}

void GetMu()//线性筛求mu
{
    Mu[1]=1;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i];
    return;
}

ll Calc(ll n,ll m)
{
    if (n&gt;m) swap(n,m);
    ll ret=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));
        ret=ret+(Musum[last]-Musum[i-1])*(ll)(n/i)*(ll)(m/i);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>186</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 05:36:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-15 21:36:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj-2005-noi2010%e8%83%bd%e9%87%8f%e9%87%87%e9%9b%86%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2154/Luogu1829 ]Crash的数字表格（莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/201</link>
		<pubDate>Tue, 16 Jan 2018 14:18:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=201</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

今天的数学课上，Crash小朋友学习了最小公倍数(Least Common Multiple)。对于两个正整数a和b，LCM(a, b)表示能同时被a和b整除的最小正整数。例如，LCM(6, 8) = 24。回到家后，Crash还在想着课上学的东西，为了研究最小公倍数，他画了一张N&#42;M的表格。每个格子里写了一个数字，其中第i行第j列的那个格子里写着数为LCM(i, j)。一个4&#42;5的表格如下： 1 2 3 4 5 2 2 6 4 10 3 6 3 12 15 4 4 12 4 20 看着这个表格，Crash想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当N和M很大时，Crash就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，Crash只想知道表格里所有数的和mod 20101009的值。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2154">BZOJ</a>
<a href="https://www.luogu.org/record/show?rid=5368858">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

求&#92;(\sum&#95;{i}^{n} \sum&#95;{j}^{m} lcm(i,j)&#92;)，其中&#92;(lcm(i,j)&#92;)表示&#92;(i,j&#92;)的最小公倍数

<h2>解决思路</h2>

根据&#92;(lcm(i,j)=\frac{ij}{gcd(i,j)}&#92;)，式子可以化为
&#92;[Ans=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} \frac{ij}{gcd(i,j)}&#92;]
令&#92;(d=gcd(i,j)&#92;)，把&#92;(d&#92;)提出来，即变成枚举&#92;(d&#92;)。
&#92;[Ans=\sum&#95;{d=1}^{n} \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==d] &#42; \frac{ij}{d}&#92;]
<code>[  ]</code>里面有&#92;(d&#92;)，把它提出来。后面的&#92;(i,j&#92;)相当于都提取出一个公因子&#92;(d&#92;)，变成&#92;(\frac{i}{d},\frac{j}{d}&#92;)
&#92;[Ans=\sum&#95;{d=1}^{n} \sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [gcd(i,j)==1] &#42; dij &#92;&#92; Ans=\sum&#95;{d=1}^{n} d &#42; \sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [gcd(i,j)==1] &#42; ij&#92;]
前面先不管它，先看后面这一部分
设&#92;[f(x)=\sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [gcd(i,j)==x] &#42; ij&#92;]。设&#92;[g(x)=\sum&#95;{x|t} f(t)&#92;]
&#92;[g(x)=\sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [x|gcd(i,j)]&#42; ij &#92;]
提一个&#92;(x&#92;)出来
&#92;[g(x)=\sum&#95;{i=1}^{n/d/x} \sum&#95;{j=1}^{m/d/x} [1|gcd(i,j)] i&#42;x &#42;j&#42;x&#92;]
&#92;([1|gcd(i,j)]&#92;)是显然成立的。所以
&#92;[g(x)=x^2&#42;\sum&#95;{i=1}^{n/d/x} \sum&#95;{j=1}^{m/d/x} ij&#92;]
那么这就是两个等差数列相乘了，可以&#92;(O(1)&#92;)地做
根据莫比乌斯反演
&#92;[f(x)=\sum&#95;{x|t}^{n/d} \mu(\frac{t}{x}) g(t) &#92;&#92; = \sum&#95;{x|t}^{n/d} \mu(\frac{t}{x}) t^2 \sum&#95;{i=1}^{n/d/t} \sum&#95;{j=1}^{m/d/t} ij&#92;]
由于我们要求的是&#92;(f(1)&#92;)
所以得到&#92;[f(1)=\sum&#95;{k=1}^{n/d} \mu(k) k^2 \sum&#95;{i=1}^{n/d/k} \sum&#95;{j=1}^{m/d/k} ij&#92;]
把&#92;(f(1)&#92;)代回到&#92;(Ans&#92;)
&#92;[Ans=\sum&#95;{d=1}^{n} \sum&#95;{k=1}^{n/d} \mu(k) &#42; k^2 \sum&#95;{i=1}^{n/d/k} \sum&#95;{j=1}^{m/d/k} ij&#92;]
内外两层数论分块，可以做到总复杂度&#92;(O(n)&#92;)

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=10000010;
const int inf=2147483647;
const ll Mod=20101009;

int Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];
ll Sum[maxNum];

void GetMu();//计算mu
ll Calc(ll n,ll m);//内层数论分块

int main()
{
    GetMu();
    ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
    ll ans=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));//外层数论分块
        ll s=(last+i)*(last-i+1)/2;
        ans=(ans+s%Mod*Calc(n/i,m/i)%Mod)%Mod;
    }
    printf("%lld\n",ans);
    return 0;
}

void GetMu()//线性筛
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Sum[i]=((Sum[i-1]+(ll)Mu[i]*(ll)i*(ll)i)%Mod+Mod)%Mod;
    return;
}

ll Calc(ll n,ll m)
{
    if (n&gt;m) swap(n,m);
    ll ret=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));
        ll l1=n/i,l2=m/i;
        ll s1=(1+l1)*l1/2%Mod,s2=(1+l2)*l2/2%Mod;
        ret=(ret+((Sum[last]-Sum[i-1])+Mod)%Mod*s1%Mod*s2%Mod)%Mod;
    }
    return (ret%Mod+Mod)%Mod;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>201</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 22:18:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-16 14:18:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj-2154-luogu-1829-crash%e7%9a%84%e6%95%b0%e5%ad%97%e8%a1%a8%e6%a0%bc%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2693] jzptab （莫比乌斯反演，积性函数，线性筛）</title>
		<link>http://sycstudio.com/archives/208</link>
		<pubDate>Tue, 16 Jan 2018 14:54:40 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=208</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

<img src="http://sycstudio.com/bzojch/file/2693_0.jpg" alt="BZOJ2693" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2693">BZOJ</a>
权限题，提供本站离线版本：<a href="http://sycstudio.com/bzojch/p/2693.html">bzojch</a>

<h3>Tag</h3>

莫比乌斯反演，线性筛，积性函数

<h2>题目大意</h2>

与<a href="http://sycstudio.com/archives/201">这道题</a>一样，但变成了多组数据。

<h2>解决思路</h2>

前面的式子到<a href="http://sycstudio.com/archives/201">这道题</a>查看，我们直接从那一道题的结尾开始推。
在那道题的最后，我们得到
&#92;[Ans=\sum&#95;{d=1}^{n} d &#42; \sum&#95;{x=1}^{n/d} \mu(x) &#42; x^2 &#42; \sum&#95;{i=1}^{n/d/x} \sum&#95;{j=1}^{m/d/x} ij&#92;]
由于后面是两个等差数列求和，所以我们设&#92;(S(i)=\frac{(i+1)&#42;i}{2}&#92;)，那么就有
&#92;[Ans=\sum&#95;{d=1}^{n} d&#42; \sum&#95;{x=1}^{n/d} \mu(x) &#42; x^2 &#42; S(\frac{n}{dx}) &#42; S(\frac{m}{dx})&#92;]
设&#92;(T=x&#42; d&#92;)，则
&#92;[Ans=\sum&#95;{d=1}^{n} d&#42; \sum&#95;{x=1}^{n/d} \mu(x) &#42; x^2 &#42; S(\frac{n}{T}) &#42; S(\frac{m}{T})&#92;]
现在我们考虑枚举&#92;(T&#92;)，那么因为&#92;(T=x&#42;d&#92;)，所以对于每一个&#92;(d|T&#92;)，&#92;(d&#92;)都有&#92;(\mu(x)&#42;d&#42;x^2&#92;)的贡献。又因为&#92;(x=\frac{T}{d}&#92;)，所以，式子就化为
&#92;[Ans=\sum&#95;{T=1}^{n} S(\frac{n}{T}) &#42; S(\frac{m}{T}) &#42; \sum&#95;{d|T} \mu(d) Td&#92;]
后面这一部分是积性函数，可以线性筛出来的，具体讨论一下。
设&#92;(p&#92;)为质数，设&#92;[f(x)=\sum&#95;{d|T} \mu(d) T&#42;d=T&#42;\sum&#95;{d|T} \mu(d) &#42; d&#92;]
那么就有
&#92;[\begin{cases} f(p)=p&#42;(\mu(1)&#42;1+\mu(p)&#42;p)=p-p^2 &#92;&#92; f(p&#42;i)=f(p)&#42;f(i) \quad \quad \quad \quad \quad \quad \quad gcd(i,p)==1 &#92;&#92; f(p&#42;i)=p&#42;f(i) \quad \quad \quad \quad \quad \quad \quad \quad gcd(i,p)==p \end{cases}&#92;]
线性筛出&#92;(f(i)&#92;)，求前缀和数论分块，就可以把单次询问的复杂度降到&#92;(O(\sqrt{n})&#92;)

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=10000100;
const ll Mod=100000009;
const int inf=2147483647;

ll Sum[maxNum];
ll pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void Sieve();//线性筛求f(i)

int main()
{
    Sieve();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=0;
        for (ll i=1,last;i&lt;=n;i=last+1)
        {
            last=min(n/(n/i),m/(m/i));//数论分块
            ll l1=n/i,l2=m/i;
            ll s1=l1*(1ll+l1)/2%Mod,s2=l2*(1ll+l2)/2%Mod;//这里计算出来的是两个等差数列的和
            ans=((ans+(((Sum[last]-Sum[i-1])%Mod+Mod)%Mod)*s1%Mod*s2%Mod)%Mod+Mod)%Mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void Sieve()//线性筛
{
    notprime[1]=1;Sum[1]=1;
    for (ll i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Sum[i]=(i-i*i+Mod)%Mod;
        for (ll j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                Sum[i*Prime[j]]=Sum[i]*Prime[j]%Mod;break;
            }
            Sum[i*Prime[j]]=Sum[i]*Sum[Prime[j]]%Mod;
        }
    }
    for (int i=1;i&lt;maxNum;i++) Sum[i]=((Sum[i]+Sum[i-1])%Mod+Mod)%Mod;//计算前缀和
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>208</wp:post_id>
		<wp:post_date><![CDATA[2018-01-16 22:54:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-16 14:54:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2693-jzptab-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0%ef%bc%8c%e7%ba%bf%e6%80%a7%e7%ad%9b%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0"><![CDATA[积性函数]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0"><![CDATA[积性函数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[POJ2480/Luogu2303/BZOJ2705] [SDOI2012]Longge的问题（欧拉函数）</title>
		<link>http://sycstudio.com/archives/230</link>
		<pubDate>Wed, 17 Jan 2018 14:57:34 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=230</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Longge的数学成绩非常好，并且他非常乐于挑战高难度的数学问题。现在问题来了：给定一个整数N，你需要求出∑gcd(i, N)(1&lt;=i &lt;=N)。

<h3>Http</h3>

<a href="https://vjudge.net/problem/POJ-2480">POJ</a>
<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2705">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2303">Luogu</a>

<h3>Tag</h3>

欧拉函数

<h2>题目大意</h2>

求&#92;[\sum&#95;{i=1}^{n} gcd(i,n)&#92;]

<h2>解决思路</h2>

与<a href="http://sycstudio.com/archives/110">这一题</a>类似，设&#92;(n=a&#42;b&#92;)，那么若有&#92;(gcd(a&#42;b,a&#42;c)==a&#92;)，则&#92;(gcd(b,c)==1&#92;)，那么题目变成求&#92;(\phi(n/a)&#92;)。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

ll Phi(ll x);

int main()
{
    ll n;
    while (scanf("%lld",&amp;n)!=EOF)
    {
        ll ans=0;
        for (ll i=1;(ll)i*(ll)i&lt;=n;i++)
            if (n%i==0)
            {
                ans=ans+(ll)i*(ll)Phi(n/i);
                if (i*i!=n) ans=ans+(ll)(n/i)*(ll)Phi(i);
            }
        printf("%lld\n",ans);
    }
    return 0;
}

ll Phi(ll x)
{
    //cout&lt;&lt;"Phi:"&lt;&lt;x&lt;&lt;" ";
    ll ret=x;
    for (ll i=2;(ll)i*(ll)i&lt;=x;i++)
        if (x%i==0)
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;
        }
    if (x!=1) ret=ret/x*(x-1);
    //cout&lt;&lt;ret&lt;&lt;endl;
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>230</wp:post_id>
		<wp:post_date><![CDATA[2018-01-17 22:57:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-17 14:57:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[poj2480-luogu2303-bzoj2705-sdoi2012longge%e7%9a%84%e9%97%ae%e9%a2%98%ef%bc%88%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="poj"><![CDATA[POJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2301/Luogu2522][HAOI2011]Problem b（莫比乌斯反演，容斥原理，数论分块）</title>
		<link>http://sycstudio.com/archives/233</link>
		<pubDate>Wed, 17 Jan 2018 15:17:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=233</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y) = k，gcd(x,y)函数为x和y的最大公约数。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2301">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2522">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，容斥原理，数论分块

<h2>题目大意</h2>

求&#92;[\sum&#95;{i=a}^{b} \sum&#95;{j=c}^{d} [gcd(i,j)==K]&#92;]

<h2>解决思路</h2>

先考虑求解&#92;[Ans=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j)==K&#92;]
这个式子可以化成&#92;[Ans=\sum&#95;{i=1}^{n/K} \sum&#95;{j=1}^{m/K} [gcd(i,j)==1]&#92;]
由莫比乌斯反演可得（具体推导可以参考<a href="http://sycstudio.com/archives/146">这里</a>）
&#92;[Ans=\sum&#95;{i=1}^{n/K} \mu(i) \lfloor \frac{n/K}{i} \rfloor &#42; \lfloor \frac{m/K}{i} \rfloor&#92;]
那么再考虑&#92;(i&#92;)从&#92;(a&#92;)开始，&#92;(j&#92;)从&#92;(c&#92;)开始。可以像求二维前缀和一样简单容斥一下，设&#92;[Calc(n,m)=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==1]&#92;]，那么最后的答案就是
&#92;[Ans=Calc(b,d)-Calc(a-1,d)-Calc(b,c-1)+Calc(a-1,c-1)&#92;]

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=50010;
const int inf=2147483647;

int Mu[maxNum];
int Musum[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();//线性筛求mu
int Calc(int n,int m);//计算子问题

int main()
{
    GetMu();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int a,b,c,d,K;scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;K);
        printf("%d\n",Calc(b/K,d/K)-Calc((a-1)/K,d/K)-Calc(b/K,(c-1)/K)+Calc((a-1)/K,(c-1)/K));
    }
    return 0;
}

void GetMu()
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j])&lt;maxNum;j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i];
    return;
}

int Calc(int n,int m)
{
    int ret=0;if (n&gt;m) swap(n,m);
    for (int i=1,last;i&lt;=n;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));
        ret=ret+(Musum[last]-Musum[i-1])*(n/i)*(m/i);
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>233</wp:post_id>
		<wp:post_date><![CDATA[2018-01-17 23:17:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-17 15:17:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2301-luogu2522haoi2011problem-b%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%ae%b9%e6%96%a5"><![CDATA[容斥]]></category>
		<category domain="category" nicename="%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86"><![CDATA[容斥原理]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1257/Luogu2261][CQOI2007]余数求和（数论分块）</title>
		<link>http://sycstudio.com/archives/239</link>
		<pubDate>Wed, 17 Jan 2018 15:35:13 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=239</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给出正整数n和k，计算G(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值，其中k mod i表示k除以i的余数。例如G(10, 5)=5 mod 1 + 5 mod 2 + 5 mod 3 + 5 mod 4 + 5 mod 5 …… + 5 mod 10=0+1+2+1+0+5+5+5+5+5=29

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1257">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2261">Luogu</a>

<h3>Tag</h3>

数论分块

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} K\ mod\ i &#92;)

<h2>解决思路</h2>

由于&#92;(a%b=a-b&#42;\lfloor \frac{a}{b} \rfloor&#92;)，所以式子可以化为
&#92;[\sum&#95;{i=1}^{n} (K-i&#42;\lfloor \frac{K}{i} \rfloor ) &#92;&#92; =n&#42;K-\sum&#95;{i=1} \lfloor \frac{K}{i} \rfloor&#92;]
后面这个式子可以数论分块做。
需要注意&#92;(n &lt; K&#92;)的情况，此时分块会浮点溢出（除&#92;(0&#92;)错误），所以要控制循环上界

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

int main()
{
    ll n,K;scanf("%lld%lld",&amp;n,&amp;K);
    ll ans=0;
    ans=n*K;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        if ((ll)(K/i)==0) break;//及时退出，防止除0
        last=min(K/((ll)(K/i)),n);
        ll s1=(last+i)*(last-i+1)/2;
        //cout&lt;&lt;s1&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;
        ans=ans-s1*(ll)((K/i));
    }
    printf("%lld\n",ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>239</wp:post_id>
		<wp:post_date><![CDATA[2018-01-17 23:35:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-17 15:35:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1257-luogu2261cqoi2007%e4%bd%99%e6%95%b0%e6%b1%82%e5%92%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>常用跟踪博客</title>
		<link>http://sycstudio.com/archives/334</link>
		<pubDate>Sun, 21 Jan 2018 06:26:50 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=334</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>一级跟踪</h2>

<a href="http://blog.csdn.net/popoqqq">popoqqq</a>
<a href="http://www.cnblogs.com/Zars19/">Zars19</a>
<a href="http://www.cnblogs.com/GXZlegend/">GXZlegend</a>
<a href="http://www.cnblogs.com/MashiroSky/">MashiroSky</a>
<a href="http://www.cnblogs.com/candy99/">Candy?</a>
<a href="http://www.yhzq-blog.cc/">yzzq</a>
<a href="http://blog.csdn.net/maxwei_wzj">maxwei_wzj</a>
<a href="http://www.cnblogs.com/hzoier/">Antileaf</a>
<a href="http://www.cnblogs.com/Skyminer">Skyminer</a>

<h2>二级跟踪</h2>

<a href="https://ahackh.ac.cn/">ahackh</a>
<a href="https://www.zgz233.xyz/">zgz233</a>
<a href="http://www.cnblogs.com/ljh2000-jump/">ljh</a>
<a href="http://blog.csdn.net/clover_hxy">clover_hxy</a>
<a href="http://www.cnblogs.com/DMoon">DMoon</a>
<a href="http://seter.is-programmer.com/">Seter</a>
<a href="http://www.cnblogs.com/zcysky">zcysky</a>
<a href="https://blog.sengxian.com/">sengxian</a>

<h2>三级跟踪</h2>

<a href="http://blog.godofthefallen.win/">gtf</a>
<a href="http://www.cnblogs.com/LCF-2000">lcf</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>334</wp:post_id>
		<wp:post_date><![CDATA[2018-01-21 14:26:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-21 06:26:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%b8%b8%e7%94%a8%e8%b7%9f%e8%b8%aa%e5%8d%9a%e5%ae%a2]]></wp:post_name>
		<wp:status><![CDATA[private]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3994/Luogu3327][SDOI2015]约数个数和（莫比乌斯反演，数论分块，线性筛）</title>
		<link>http://sycstudio.com/archives/244</link>
		<pubDate>Wed, 17 Jan 2018 17:03:44 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=244</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

设d(x)为x的约数个数，给定N、M，求
 <img src="http://sycstudio.com/bzojch/file/3994_0.jpg" alt="BZOJ3994" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3994">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3327">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块，线性筛

<h2>题目大意</h2>

求&#92;( \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} d(ij) &#92;)，其中&#92;( d(x) &#92;)表示&#92;( x &#92;)的约数个数

<h2>解决思路</h2>

首先观察&#92;( d(ij) &#92;)，这个式子我们不好处理。假设我们枚举&#92;( u|i,v|j &#92;)，那么&#92;( u&#42;\frac{m}{v} &#92;)就一定对&#92;( d(ij) &#92;)有&#92;( 1 &#92;)的贡献。
那么式子是不是就变成
&#92;[ \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} \sum&#95;{u|i} \sum&#95;{v|i} &#92;]
显然不是的。这样会算重。具体来说，设$$p$$为质数，若&#92;( u'=u&#42;p &#92;)，&#92;( v'=v&#42;p&#92;)，那么&#92;( u'&#92;)与&#92;(v'&#92;)对答案的贡献会与&#92;(u&#92;)和&#92;(v&#92;)重复，即&#92;(u'&#42; \frac{m}{v'}=u&#42;p &#42; \frac{m}{v&#42;p}=u&#42;\frac{m}{v}&#92;)
所以我们发现，对于这个式子，应该要求$$u,v$$互质，即&#92;(gcd(u,v)==1&#92;)
结合上面的分析，我们可以得到这个初始式子
&#92;[Ans=\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} \sum&#95;{u|i} \sum&#95;{v|j} [gcd(i,j)==1]&#92;]
把&#92;(u,v&#92;)提到前面来，因为&#92;(i&#92;)是&#92;(u&#92;)的倍数，在&#92;([1..n]&#92;)内一共有&#92;(\lfloor \frac{n}{u} \rfloor&#92;)这么多个&#92;(u&#92;)的倍数，那么也就有这么多个给&#92;(u&#92;)的代价，&#92;(v&#92;)的分析也是同理，所以得到
&#92;[Ans=\sum&#95;{u=1}^{n} \sum&#95;{v=1}^{m} \lfloor \frac{n}{u} \rfloor &#42; \lfloor \frac{m}{v} \rfloor [gcd(u,v)==1]&#92;]
接下来莫比乌斯反演
设&#92;[f(x)=\sum&#95;{u=1}^{n} \sum&#95;{v=1}^{m} \lfloor \frac{n}{u} \rfloor &#42; \lfloor \frac{m}{v} \rfloor [gcd(u,v)==x]&#92;]
设&#92;[g(x)=\sum&#95;{x|d}^{n} f(d) &#92;&#92; =\sum&#95;{u=1}^{n} \sum&#95;{v=1}^{m} \lfloor \frac{n}{u} \rfloor &#42; \lfloor \frac{m}{v} \rfloor [x|gcd(u,v)] &#92;&#92; =\sum&#95;{u=1}^{n/x} \sum&#95;{v=1}^{m/x} \lfloor \frac{n/x}{u} \rfloor &#42; \lfloor \frac{m/x}{v} \rfloor [1|gcd(u,v)]&#92;]
&#92;([1|gcd(u,v)]&#92;)显然成立，所以
&#92;[g(x)=\sum&#95;{u=1}^{n/x} \sum&#95;{v=1}^{m/x} \lfloor \frac{n/x}{u} \rfloor &#42; \lfloor \frac{m/x}{v} \rfloor&#92;]
现在的问题就变成，如何快速地求&#92;(\sum&#95;{i=1}^{n} \lfloor \frac{n}{i} \rfloor&#92;) ？
考虑&#92;(\lfloor \frac{n}{i} \rfloor&#92;)的概念，它就是&#92;(n&#92;)内有多少个&#92;(i&#92;)的因数。而把这些次数累加起来，是不是就是&#92;(1&#92;)到&#92;(n&#92;)的约数个数和？
形式化的，设&#92;(F(x)&#92;)表示数&#92;(x&#92;)有多少个约数，则有&#92;(\sum&#95;{i=1}^{n} \lfloor \frac{n}{i} \rfloor=\sum&#95;{i=1}^{n} F(i)&#92;)。非常巧妙。
而&#92;(F(x)&#92;)是积性函数，可以线性筛，这样我们就把求解&#92;(\sum \lfloor \frac{n}{i} \rfloor&#92;)的复杂度由&#92;(O(n&#42;\sqrt{n})&#92;)降到了&#92;(O(n)&#92;)。
具体来说，&#92;(F(x)&#92;)可以这样求。
根据唯一分解定理&#92;(x=\prod p&#95;{i}^{a^i}&#92;)，其中&#92;(p&#92;)为质数。
那么我们可以得到求解单个&#92;(F(x)&#92;)的方法，即&#92;(F(x)=\prod ({a^i}+1)&#92;)。知道这个式子，对于我们下面的推导有帮助。
接下来分类讨论，设&#92;(p&#92;)为质数
首先&#92;(F(p)&#92;)很好求，它就是&#92;(2&#92;)
再来考虑&#92;(F(p&#42;i)\ [gcd(p,i)==1]&#92;)，这个也很好求，根据积性函数的性质，&#92;(F(p&#42;i)=F(p)&#42;F(i)&#92;)
关键是&#92;(F(p&#42;i)\ [gcd(p,i)==p]&#92;)的情况。由于&#92;(i&#92;)中已经有了&#92;(p&#92;)，形式化地，设&#92;(i=i'&#42;p^k&#92;)，那么在&#92;(F(i)&#92;)中已经乘进去了&#92;((k+1)&#92;)这一项。我们若想得到&#92;(F(p&#42;i)&#92;)，那么就把&#92;(F(i)&#92;)除掉&#92;((k+1)&#92;)这一项再乘以&#92;((k+2)&#92;)。具体来说，我们对于每一个&#92;(i&#92;)再记录一个&#92;(Low(i)&#92;)表示把&#92;(i&#92;)唯一分解后最小的质因子&#92;(p&#95;1&#92;)的指数，那么&#92;(F(p&#42;i)=F(i)/(Low[i]+1)&#42;(Low[i]+2)&#92;)
现在，我们就可以&#92;(O(1)&#92;)地求&#92;(g(x)&#92;)了。回到莫比乌斯反演。
&#92;[f(x)=\sum&#95;{x|d} \mu(\frac{d}{x}) g(d) &#92;&#92; = \sum&#95;{x|d} \mu(\frac{d}{x}) \sum&#95;{u=1}^{n/d} \lfloor \frac{\frac{n}{d}}{u} \rfloor \sum&#95;{v=1}^{m/d} \lfloor \frac{\frac{m}{d}}{v} \rfloor&#92;]
最后把我们要求的$$f(1)$$带进去
&#92;[f(1)=\sum&#95;{i=1}^{n} \mu(i) \sum&#95;{u=1}^{n/i} \lfloor \frac{\frac{n}{i}}{u} \rfloor \sum&#95;{v=1}^{m/i} \lfloor \frac{\frac{m}{i}}{v} \rfloor&#92;]
后面一块是可以&#92;(O(1)&#92;)求的，那么我们把前面分块，预处理&#92;(\mu(i)&#92;)的前缀和就可以了。
预处理复杂度&#92;(O(n)&#92;)
单次询问复杂度&#92;(O(\sqrt{n})&#92;)

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=50010;
const int inf=2147483647;

ll Mu[maxNum],Low[maxNum];//莫比乌斯函数，唯一分解的最小质因子个数
ll Musum[maxNum],F[maxNum];//mu前缀和，约数个数和前缀和
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void Init();//线性筛求mu和约数个数

int main()
{
    Init();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=0;
        for (ll i=1,last;i&lt;=n;i=last+1)
        {
            last=min(n/(n/i),m/(m/i));//数论分块
            ans=ans+(Musum[last]-Musum[i-1])*F[n/i]*F[m/i];
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void Init()
{
    notprime[1]=1;Mu[1]=1;Low[1]=1;F[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1,Low[i]=1,F[i]=2;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                Low[i*Prime[j]]=Low[i]+1;
                F[i*Prime[j]]=F[i]/(Low[i]+1)*(Low[i]+2);
                break;
            }
            Mu[i*Prime[j]]=-Mu[i];
            F[i*Prime[j]]=F[i]*F[Prime[j]];
            Low[i*Prime[j]]=1;
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i],F[i]+=F[i-1];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>244</wp:post_id>
		<wp:post_date><![CDATA[2018-01-18 01:03:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-17 17:03:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3994-luogu3327sdoi2015%e7%ba%a6%e6%95%b0%e4%b8%aa%e6%95%b0%e5%92%8c%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0"><![CDATA[积性函数]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e7%a7%af%e6%80%a7%e5%87%bd%e6%95%b0"><![CDATA[积性函数]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2818/Luogu2568] gcd （莫比乌斯反演）</title>
		<link>http://sycstudio.com/archives/294</link>
		<pubDate>Fri, 19 Jan 2018 23:45:07 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=294</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的
数对(x,y)有多少对.

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2818">BZOJ</a>
<a href="https://www.luogu.org/recordnew/lists?uid=21377">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)\ is\ a\ prime]&#92;)

<h2>解决思路</h2>

设&#92;( f(d)=\begin{cases} 1 \quad d\ is\ a\ prime &#92;&#92; 0 \quad\ d\ is\ not\ a\ prime\end{cases}&#92;)
提取$$gcd(i,j)==d$$，得到
&#92;[Ans=\sum&#95;{d=1}^{n} f(d)&#42;\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==1]&#92;]
根据以前（<a href="http://sycstudio.com/archives/146">这里</a>）推出的式子，由莫比乌斯反演得
&#92;[Ans=\sum&#95;{d=1}^{n} f(d)&#42;\sum&#95;{i=1}^{n/d} \mu(i) \lfloor \frac{n}{id} \rfloor^2&#92;]
那么记一下质数个数的前缀和以及&#92;(\mu()&#92;)的前缀和前后两层数论分块即可

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=10000010;
const int inf=2147483647;

int Mu[maxNum],Musum[maxNum];
int Prisum[maxNum];
int pricnt=0,Prime[maxNum/1000];
bool notprime[maxNum];

void Init();//线性筛求mu
ll Calc(int n);//内层分块

int main()
{
    Init();
    int n;scanf("%d",&amp;n);
    ll ans=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=n/(n/i);//外层分块
        ans=ans+(Prisum[last]-Prisum[i-1])*Calc(n/i);
    }
    printf("%lld\n",ans);
    return 0;
}

void Init()
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1,Prisum[i]=1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) Musum[i]=Musum[i-1]+Mu[i],Prisum[i]+=Prisum[i-1];
    return;
}

ll Calc(int n)
{
    ll ret=0;
    for (ll i=1,last;i&lt;=n;i=last+1)
    {
        last=n/(n/i);
        ret=ret+(Musum[last]-Musum[i-1])*(ll)((n/i))*(ll)((n/i));
    }
    //cout&lt;&lt;n&lt;&lt;" "&lt;&lt;ret&lt;&lt;endl;
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>294</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 07:45:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-19 23:45:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2818-luogu2568-gcd-%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2820/Luogu2257]YY的GCD（莫比乌斯反演，数论分块，线性筛）</title>
		<link>http://sycstudio.com/archives/314</link>
		<pubDate>Sat, 20 Jan 2018 00:08:35 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=314</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

神犇YY虐完数论后给傻×kAc出了一题给定N, M,求1&lt;=x&lt;=N, 1&lt;=y&lt;=M且gcd(x, y)为质数的(x, y)有多少对kAc这种
傻×必然不会了，于是向你来请教……多组输入

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2820">BZOJ</a>
权限题，提供本站离线版本<a href="http://sycstudio.com/bzojch/p/2820.html">BZOJch</a>
<a href="https://www.luogu.org/problemnew/show/P2257">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块，线性筛

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)\ is\ a\ prime]&#92;)

<h2>解决思路</h2>

与<a href="http://sycstudio.com/archives/294">这一题</a>类似，但是有多组数据。
直接从那一题的结尾开始推
&#92;[Ans=\sum&#95;{d=1}^{n} f(d)&#42;\sum&#95;{i=1}^{n/d} \mu(i) \lfloor \frac{n}{id} \rfloor^2&#92;]
另&#92;(T=id&#92;)，变枚举&#92;(d&#92;)为枚举&#92;(T&#92;)
&#92;[Ans=\sum&#95;{T=1}^{n} \lfloor \frac{n}{T} \rfloor ^2 \sum&#95;{d|T} [d\ is\ a\ prime]&#42;\mu(\frac{T}{d})&#92;]
后面这个东西&#92;(\sum&#95;{d|T} [d\ is\ a\ prime]&#42;\mu(\frac{T}{d})&#92;)虽然不是积性函数，但是可以线性筛的，具体来说，设&#92;(h(x)=\sum&#95;{d|T} [d\ is\ a\ prime]&#42;\mu(\frac{T}{d})&#92;)，那么有
设&#92;(p&#92;)为质数
&#92;(h(p)=1&#92;)，这个很容易得到
&#92;(h(p&#42;i)=\mu(i) \quad [gcd(p,i)==p]&#92;)。这个的原理是如果乘进去一个质数&#92;(p&#92;)，并且这个&#92;(p&#92;)在&#92;(i&#92;)中已经出现过了，那么在&#92;(\mu(x)&#92;)中就必定有大于等于&#92;(2&#92;)个质因子&#92;(p&#92;)，根据莫比乌斯函数的定义&#92;(\mu(x)==0&#92;)，所以就只剩&#92;(\mu(i))&#92;)自己的贡献
&#92;(h(p&#42;i)=\mu(i)-h(i) \quad [gcd(p,i)==1]&#92;)。原因是由于乘进去一个互质质数&#92;(p&#92;)，原来的莫比乌斯函数要变号，再加上&#92;(mu(i)&#92;)的贡献。
那么结合数论分块，可以做到&#92;(O(n)&#92;)预处理，&#92;(O(\sqrt{n})&#92;)单次询问

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=10000010;
const int inf=2147483647;

ll F[maxNum];
int Mu[maxNum];
int pricnt=0,Prime[maxNum/100];
bool notprime[maxNum];

void Init();

int main()
{
    Init();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int n,m;scanf("%d%d",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=0;
        for (int i=1,last;i&lt;=n;i=last+1)
        {
            last=min(n/(n/i),m/(m/i));
            ans=ans+(F[last]-F[i-1])*(ll)((n/i))*(ll)((m/i));
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void Init()
{
    Mu[1]=1;F[1]=0;notprime[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Mu[i]=-1,F[i]=1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                F[i*Prime[j]]=Mu[i];
                break;
            }
            Mu[i*Prime[j]]=-Mu[i];
            F[i*Prime[j]]=Mu[i]-F[i];
        }
    }
    for (int i=1;i&lt;maxNum;i++) F[i]+=F[i-1];
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>314</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 08:08:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-20 00:08:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2820-luogu2257yy%e7%9a%84gcd%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%8c%e7%ba%bf%e6%80%a7%e7%ad%9b%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4407]于神之怒加强版（莫比乌斯反演，数论分块，线性筛）</title>
		<link>http://sycstudio.com/archives/316</link>
		<pubDate>Sat, 20 Jan 2018 13:02:35 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=316</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给下N,M,K.求&#92;(\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j)^k \mod (10^9+7) &#92;)

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4407">BZOJ</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

求&#92;(\sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} gcd(i,j)^k&#92;)

<h2>解决思路</h2>

先提取&#92;(gcd(i,j)==d&#92;)
&#92;[\sum&#95;{d=1}^{n} d^k \sum&#95;{i=1}^{n} \sum&#95;{j=1}^{m} [gcd(i,j)==d]&#92;]
继续化为
&#92;[\sum&#95;{d=1}^{n} d^k \sum&#95;{i=1}^{n/d} \sum&#95;{j=1}^{m/d} [gcd(i,j)==1]&#92;]
根据莫比乌斯反演，后面部分可以化简，所以得到
&#92;[\sum&#95;{d=1}^{n} d^k \sum&#95;{i=1}^{n/d} \lfloor \frac{n}{id} \rfloor \lfloor \frac{m}{id} \rfloor &#92;]
令&#92;(T=id&#92;)，则有
&#92;[\sum&#95;{d=1}^{n} d^k \sum&#95;{i=1}^{n/d} \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor &#92;]
把枚举&#92;(d&#92;)变成枚举&#92;(T&#92;)，考虑每一个&#92;(\mu(i)&#92;)的贡献，可以得到
&#92;[\sum&#95;{T=1}^{n} \lfloor \frac{n}{T} \rfloor \lfloor \frac{n}{T} \rfloor \sum&#95;{d|T} d^k \mu(\frac{T}{d}) &#92;]
后面一块东西是积性函数，可以线性筛，具体来说，设&#92;(g(x)=\sum&#95;{d|x} d^k \mu(\frac{x}{d})&#92;)，则分情况讨论
设&#92;(p&#92;)为质数
&#92;[g(p)=p^k-1&#92;]
这个比较好理解，&#92;(p&#92;)是质数那么&#92;(d&#92;)就只有两种取值，一个得到&#92;(p^k&#42;\mu(1)=p^k&#92;)，另一个得到&#92;(1^k&#42;\mu(p)=-1&#92;)。
&#92;[g(p&#42;i)=g(p)&#42;g(i) \quad [gcd(i,p)==1]&#92;]
这个直接由积性函数性质得到
&#92;[g(p&#42;i)=g(i)&#42;p^k \quad [gcd(i,p)==p]&#92;]
这个的话，考虑加进去一个原来已经存在的质因子&#92;(p&#92;)，那么只会影响&#92;(d^k&#92;)变成&#92;((d&#42;p)^k&#92;)，所以补一个&#92;(p^k&#92;)进去就可以了
那么求出后面那一块之后，前缀和数论分块即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=5000010;
const ll Mod=1e9+7;
const int inf=2147483647;

int pricnt=0,Prime[maxNum];
bool notprime[maxNum];
ll H[maxNum];
ll Pow[maxNum];

int K;

void Init();
int QPow(ll x,int cnt);

int main()
{
    int T;
    scanf("%d%d",&amp;T,&amp;K);
    Init();//线性筛初始化
    while (T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=0;
        for (ll i=1,last;i&lt;=n;i=last+1)
        {//数论分块
            last=min(n/(n/i),m/(m/i));
            ans=(ans+(H[last]-H[i-1]+Mod)%Mod*(ll)((n/i))%Mod*(ll)((m/i))%Mod)%Mod;
        }
        printf("%lld\n",ans%Mod);
    }
    return 0;
}

void Init()
{
    notprime[1]=1;H[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Prime[++pricnt]=i,Pow[pricnt]=QPow(i,K),H[i]=Pow[pricnt]-1;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0)
            {
                H[i*Prime[j]]=H[i]*Pow[j]%Mod;
                break;
            }
            H[i*Prime[j]]=H[i]*H[Prime[j]]%Mod;
        }
    }
    for (int i=1;i&lt;maxNum;i++) H[i]=(H[i]+H[i-1])%Mod;
    return;
}

int QPow(ll x,int cnt)
{
    ll ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>316</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 21:02:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-20 13:02:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4407%e4%ba%8e%e7%a5%9e%e4%b9%8b%e6%80%92%e5%8a%a0%e5%bc%ba%e7%89%88%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%8c%e7%ba%bf]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1013/Luogu4035][JSOI2008]球形空间产生器sphere（高斯消元）</title>
		<link>http://sycstudio.com/archives/324</link>
		<pubDate>Sat, 20 Jan 2018 13:57:17 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=324</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P4035">Luogu</a>

<h3>Tag</h3>

高斯消元

<h2>题目大意</h2>

求解方程组

<h2>解决思路</h2>

根据题目给出的计算&#92;(n&#92;)维空间的两点坐标公式，我们可以列出&#92;(n+1&#92;)个连等式，随便选择一个作为基准，其它的都与它相消，便可以去掉所有的未知数的平方项，然后高斯消元即可

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ld long double

const int maxN=20;
const int inf=2147483647;

int n;
ld Mat[maxN][maxN];
ld Input[maxN][maxN];
ld Ans[maxN];

void Guess();

int main()
{
    scanf("%d",&amp;n);//读入数据
    for (int i=0;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) scanf("%LF",&amp;Input[i][j]);
    for (int i=1;i&lt;=n;i++)//构造n个方程
    {
        for (int j=1;j&lt;=n;j++) Mat[i][j]=(ld)2*(Input[i][j]-Input[0][j]);
        ld s1=0,s2=0;
        for (int j=1;j&lt;=n;j++) s1=s1+Input[i][j]*Input[i][j],s2=s2+Input[0][j]*Input[0][j];
        Mat[i][n+1]=s1-s2;
    }
    Guess();//高斯消元
    printf("%.3LF",Ans[1]);
    for (int i=2;i&lt;=n;i++) printf(" %.3LF",Ans[i]);
    return 0;
}

void Guess()//从上到下消元
{
    for (int i=1;i&lt;=n;i++)
        for (int j=i+1;j&lt;=n;j++)
        {
            ld ret=Mat[j][i]/Mat[i][i];
            for (int k=i;k&lt;=n+1;k++)
                Mat[j][k]-=Mat[i][k]*ret;
        }
    Ans[n]=Mat[n][n+1]/Mat[n][n];
    for (int i=n-1;i&gt;=1;i--)//从下到上得到答案
    {
        ld sum=0;
        for (int j=i;j&lt;=n;j++) sum=sum+Mat[i][j]*Ans[j];
        Ans[i]=(Mat[i][n+1]-sum)/Mat[i][i];
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>324</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 21:57:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-20 13:57:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1013-luogu4035jsoi2008%e7%90%83%e5%bd%a2%e7%a9%ba%e9%97%b4%e4%ba%a7%e7%94%9f%e5%99%a8sphere%ef%bc%88%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3626][LNOI2014]LCA（树链剖分，线段树）</title>
		<link>http://sycstudio.com/archives/328</link>
		<pubDate>Sat, 20 Jan 2018 15:04:34 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=328</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。有q次询问，每次询问给出l r z，求&#92;(\sum&#95;{l&lt;=i&lt;=r}dep[LCA(i,z)]&#92;)。（即，求在[l,r]区间内的每个节点i与z的最近公共祖先的深度之和）

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3626">BZOJ</a>

<h3>Tag</h3>

树链剖分，离线

<h2>解决思路</h2>

先考虑单次询问，如果我们对于点&#92;(i \in [l,r]&#92;)，都把&#92;(i&#92;)到根的路径加一，那么从我们询问的点到根的路径权值之和就是此次询问的答案。
处理路径覆盖，我们可以采用树链剖分+线段树的方式实现。
现在考虑多组数据，我们可以离线操作，把输入读进来排序，记录左端点和右端点分别处理，这样就可以回答多组询问了。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=60010;
const int maxM=maxN*2;
const int Mod=201314;
const int inf=2147483647;

class Question//每一个询问
{
public:
    int pos,id;//位置，询问的编号
    int lr;//是id这个询问的左区间还是右区间
};

bool operator &lt; (Question A,Question B)//排序区间方便离线
{
    return A.pos&lt;B.pos;
}

int n;
int edgecnt=-1,Head[maxN],Next[maxM],V[maxM];//图
int Depth[maxN],Fa[maxN],Size[maxN],Hson[maxN],Top[maxN];//树链剖分
int idcnt=0,Id[maxN];
int Seg[maxN*8],Lazy[maxN*8];//线段树
Question Qn[maxN*4];//询问
int QPos[maxN],Ans[maxN];//答案

void Add_Edge(int u,int v);
void dfs1(int u);
void dfs2(int u,int nowtop);
void TCAdd(int pos);
int TCQuery(int pos);
void SegModify(int now,int l,int r,int ql,int qr,int delta);
int SegQuery(int now,int l,int r,int ql,int qr);
void PushDown(int now,int l,int r);
void SegOutp(int now,int l,int r);

int main()
{
    mem(Head,-1);int Q;
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=1;i&lt;n;i++){ int fa;scanf("%d",&amp;fa);Add_Edge(fa+1,i+1);Fa[i+1]=fa+1; }
    //树链剖分预处理
    Depth[1]=1;
    dfs1(1);
    dfs2(1,1);
    //读入询问
    int qtot=0;
    for (int i=1;i&lt;=Q;i++)
    {
        int l,r;scanf("%d%d%d",&amp;l,&amp;r,&amp;QPos[i]);l++;r++;QPos[i]++;
        if (l!=1) {Qn[++qtot].id=i;Qn[qtot].pos=l-1;Qn[qtot].lr=0;}//注意这里的-1
        Qn[++qtot].id=i;Qn[qtot].pos=r;Qn[qtot].lr=1;
    }
    sort(&amp;Qn[1],&amp;Qn[qtot+1]);//排序询问
    int nowr=0;
    for (int i=1;i&lt;=qtot;i++)
    {
        while (nowr&lt;Qn[i].pos)
        {
            nowr++;TCAdd(nowr);//插入
        }
        //得到询问
        if (Qn[i].lr==0) Ans[Qn[i].id]-=TCQuery(QPos[Qn[i].id]);
        else Ans[Qn[i].id]+=TCQuery(QPos[Qn[i].id]);
    }
    for (int i=1;i&lt;=Q;i++)
        printf("%d\n",(Ans[i]%Mod+Mod)%Mod);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void dfs1(int u)
{
    Size[u]=1;
    int mxsz=0;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        Depth[V[i]]=Depth[u]+1;
        dfs1(V[i]);
        Size[u]+=Size[V[i]];
        if (Size[V[i]]&gt;Size[Hson[u]]) Hson[u]=V[i];
    }
    return;
}

void dfs2(int u,int nowtop)
{
    Top[u]=nowtop;
    Id[u]=++idcnt;
    if (Hson[u]!=0) dfs2(Hson[u],nowtop);
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=Hson[u])
            dfs2(V[i],V[i]);
    return;
}

void TCAdd(int pos)//将pos到根的路径上的每一条边+1
{
    while (Top[pos]!=1)
    {
        SegModify(1,1,n,Id[Top[pos]],Id[pos],1);
        pos=Fa[Top[pos]];
    }
    SegModify(1,1,n,1,Id[pos],1);
    return;
}

int TCQuery(int pos)//询问pos到根的路径上的权值之和
{
    int ret=0;
    while (Top[pos]!=1)
    {
        ret=(ret+SegQuery(1,1,n,Id[Top[pos]],Id[pos])%Mod)%Mod;
        pos=Fa[Top[pos]];
    }
    ret=(ret+SegQuery(1,1,n,1,Id[pos])%Mod)%Mod;
    return ret;
}

void SegModify(int now,int l,int r,int ql,int qr,int delta)//线段树区间修改
{
    PushDown(now,l,r);
    if ((l==ql)&amp;&amp;(r==qr))
    {
        Seg[now]=(Seg[now]+(ll)(r-l+1)*(ll)delta%Mod)%Mod;
        Lazy[now]+=delta;
        return;
    }
    int mid=(l+r)/2;
    if (qr&lt;=mid) SegModify(now*2,l,mid,ql,qr,delta);
    else if (ql&gt;mid) SegModify(now*2+1,mid+1,r,ql,qr,delta);
    else
    {
        SegModify(now*2,l,mid,ql,mid,delta);
        SegModify(now*2+1,mid+1,r,mid+1,qr,delta);
    }
    Seg[now]=(Seg[now*2]+Seg[now*2+1])%Mod;
    return;
}

int SegQuery(int now,int l,int r,int ql,int qr)//线段树区间查询
{
    PushDown(now,l,r);
    if ((ql==l)&amp;&amp;(qr==r))
        return Seg[now]%Mod;
    int mid=(l+r)/2;
    if (qr&lt;=mid) return SegQuery(now*2,l,mid,ql,qr)%Mod;
    if (ql&gt;=mid+1) return SegQuery(now*2+1,mid+1,r,ql,qr)%Mod;
    return (SegQuery(now*2,l,mid,ql,mid)+SegQuery(now*2+1,mid+1,r,mid+1,qr))%Mod;
}

void PushDown(int now,int l,int r)//下放操作
{
    if (Lazy[now]==0) return;
    int mid=(l+r)/2;
    Seg[now*2]=(Seg[now*2]+(ll)Lazy[now]*(ll)(mid-l+1))%Mod;
    Seg[now*2+1]=(Seg[now*2+1]+(ll)Lazy[now]*(ll)(r-mid)%Mod);
    Lazy[now*2]=(Lazy[now*2]+Lazy[now])%Mod;
    Lazy[now*2+1]=(Lazy[now*2+1]+Lazy[now])%Mod;
    Lazy[now]=0;
    return;
}

void SegOutp(int now,int l,int r)
{
    PushDown(now,l,r);
    printf("[%d,%d] %d\n",l,r,Seg[now]);
    if (l==r) return;
    int mid=(l+r)/2;
    SegOutp(now*2,l,mid);
    SegOutp(now*2+1,mid+1,r);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>328</wp:post_id>
		<wp:post_date><![CDATA[2018-01-20 23:04:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-20 15:04:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3626lnoi2014lca%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2440][中山市选2011]完全平方数（莫比乌斯反演，二分）</title>
		<link>http://sycstudio.com/archives/342</link>
		<pubDate>Sun, 21 Jan 2018 10:11:33 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=342</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。
这天是小X的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小X讨厌的数。他列出了所有小X不讨厌的数，然后选取了第 K个数送给了小X。小X很开心地收下了。
然而现在小 W 却记不起送给小X的是哪个数了。你能帮他一下吗？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2440">BZOJ</a>

<h3>Tag</h3>

莫比乌斯反演，二分

<h2>解决思路</h2>

先考虑二分，把题目变成判定问题，即询问在某个范围内，不包含完全平方数因子的数有多少个。
一个数不包含完全平方数，那么就是说唯一分解后没有任何一个质数的质数超过&#92;(1&#92;)。
容斥一下，那么答案就是
Ans-至少一个质因子个数大于1+至少两个质因子个数大于1-至少三个质因子个数大于1-至少四个质因子个数大于1
考虑每一个数对这个式子的贡献，呃，不就是&#92;(\mu()&#92;)吗？
那么线性筛出&#92;(\mu&#92;)，二分答案求解就可以啦！

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long

const int maxNum=1000010;
const int inf=2147483647;

int Mu[maxNum];
int pricnt=0,Prime[maxNum];
bool notprime[maxNum];

void GetMu();
ll Check(ll n);

int main()
{
    GetMu();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int n;scanf("%d",&amp;n);
        ll l=1,r=1e10,ans;
        do
        {
            ll mid=(l+r)/2;
            if (Check(mid)&gt;=n)//二分判定
                ans=mid,r=mid-1;
            else l=mid+1;
        }
        while (l&lt;=r);
        printf("%lld\n",ans);
    }
    return 0;
}

void GetMu()//线性筛求mu
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)
    {
        if (notprime[i]==0) Mu[i]=-1,Prime[++pricnt]=i;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    return;
}

ll Check(ll n)
{
    ll ret=0;
    for (ll i=1;i*i&lt;=n;i++) ret=ret+Mu[i]*n/i/i;
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>342</wp:post_id>
		<wp:post_date><![CDATA[2018-01-21 18:11:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-21 10:11:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2440%e4%b8%ad%e5%b1%b1%e5%b8%82%e9%80%892011%e5%ae%8c%e5%85%a8%e5%b9%b3%e6%96%b9%e6%95%b0%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="post_tag" nicename="%e5%ae%b9%e6%96%a5"><![CDATA[容斥]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e5%ae%b9%e6%96%a5%e5%8e%9f%e7%90%86"><![CDATA[容斥原理]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4816/Luogu3704][Sdoi2017]数字表格（莫比乌斯反演，数论分块）</title>
		<link>http://sycstudio.com/archives/347</link>
		<pubDate>Sun, 21 Jan 2018 12:40:39 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=347</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Doris刚刚学习了fibonacci数列。用f[i]表示数列的第i项，那么
f[0]=0
f[1]=1
f[n]=f[n-1]+f[n-2],n>=2
Doris用老师的超级计算机生成了一个n×m的表格，第i行第j列的格子中的数是f[gcd(i,j)]，其中gcd(i,j)表示i,j的最大公约数。Doris的表格中共有n×m个数，她想知道这些数的乘积是多少。答案对10^9+7取模。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4816">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3704">Luogu</a>

<h3>Tag</h3>

莫比乌斯反演，数论分块

<h2>题目大意</h2>

求&#92;(\prod&#95;{i=1}^{n} \prod&#95;{j=1}^{m} fab(gcd(i,j))&#92;)

<h2>解决思路</h2>

依照惯例，提取出&#92;(d=gcd(i,j)&#92;)，则
&#92;[Ans=\prod&#95;{d=1}^{n} fab(d)^{\sum&#95;{i=1}^{n} \sum{j=1}^{m} [gcd(i,j)==1]}&#92;]
&#92;(fab(d)&#92;)的指数可以根据莫比乌斯反演变成
&#92;[Ans=\prod&#95;{d=1}^{n} fab(d)^{\sum&#95;{i=1}^{n/d} \mu(i) \lfloor \frac{n}{id} \rfloor \lfloor \frac{m}{id} \rfloor }&#92;]
令&#92;(T=id&#92;)，把&#92;(T&#92;)提出来，得到
&#92;[ Ans=\prod&#95;{T=1}^{n} [\prod&#95;{i|T} fab(\frac{T}{i})^{\mu(i)}]^{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor} &#92;]
里面这个东西并不是积性函数，怎么办呢？
考虑到&#92;(n&#92;)只有&#92;(10^6&#92;)，可以&#92;(O(n&#42;log&#95;{2}n)&#92;)暴力算，提前处理好斐波那契数列和其逆元即可。
那么设&#92;(H(x)=\prod&#95;{i|x} f(\frac{x}{i})^{\mu(i)}&#92;)，求出它的前缀积和前缀积的逆元即可数论分块了

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxNum=1000010;
const int Mod=1e9+7;
const int inf=2147483647;

int Mu[maxNum];
int pricnt=0,Prime[maxNum/100];
bool notprime[maxNum];
int Fab[maxNum],InvFab[maxNum];
int H[maxNum],InvH[maxNum];

void Init();//线性筛求mu，以及预处理Fab，H及其逆元
int QPow(ll x,ll cnt,ll Mod);//快速幂
int Inv(ll x,ll Mod);//求逆元

int main()
{
    Init();
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        ll n,m;scanf("%lld%lld",&amp;n,&amp;m);if (n&gt;m) swap(n,m);
        ll ans=1;
        for (ll i=1,last;i&lt;=n;i=last+1)
        {
            last=min(n/(n/i),m/(m/i));
            ans=ans*QPow((ll)H[last]*(ll)InvH[i-1]%Mod,(ll)(n/i)*(ll)(m/i)%(Mod-1),Mod)%Mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}

void Init()
{
    notprime[1]=1;Mu[1]=1;
    for (int i=2;i&lt;maxNum;i++)//线性筛出mu
    {
        if (notprime[i]==0) Mu[i]=-1,Prime[++pricnt]=i;
        for (int j=1;(j&lt;=pricnt)&amp;&amp;((ll)i*(ll)Prime[j]&lt;maxNum);j++)
        {
            notprime[i*Prime[j]]=1;
            if (i%Prime[j]==0) break;
            Mu[i*Prime[j]]=-Mu[i];
        }
    }
    Fab[0]=0;Fab[1]=1;H[0]=InvH[0]=1;
    //递推出fab
    for (int i=2;i&lt;maxNum;i++) Fab[i]=(Fab[i-1]+Fab[i-2])%Mod;
    //求出fab的逆元
    for (int i=1;i&lt;maxNum;i++) InvFab[i]=Inv(Fab[i],Mod),H[i]=1;
    for (int i=1;i&lt;maxNum;i++)//求H
        if (Mu[i]!=0)
            for (int j=i;j&lt;maxNum;j=j+i)
                H[j]=(ll)H[j]*(ll)((Mu[i]==1)?(Fab[j/i]):(InvFab[j/i]))%Mod;
    //求H的逆元
    for (int i=1;i&lt;maxNum;i++) InvH[i]=Inv(H[i],Mod);
    //求前缀积
    for (int i=2;i&lt;maxNum;i++) H[i]=(ll)H[i]*(ll)H[i-1]%Mod,InvH[i]=(ll)InvH[i]*(ll)InvH[i-1]%Mod;
    return;
}

int QPow(ll x,ll cnt,ll Mod)
{
    ll ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret%Mod;
}

int Inv(ll x,ll Mod)
{
    return QPow(x,Mod-2,Mod)%Mod;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>347</wp:post_id>
		<wp:post_date><![CDATA[2018-01-21 20:40:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-21 12:40:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4816-luogu3704sdoi2017%e6%95%b0%e5%ad%97%e8%a1%a8%e6%a0%bc%ef%bc%88%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94%ef%bc%8c%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%80%a7%e7%ad%9b"><![CDATA[线性筛]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%8f%8d%e6%bc%94"><![CDATA[莫比乌斯反演]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba%e5%88%86%e5%9d%97"><![CDATA[数论分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4998]星球联盟（LCT，并查集）</title>
		<link>http://sycstudio.com/archives/354</link>
		<pubDate>Sun, 21 Jan 2018 14:41:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=354</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在遥远的S星系中一共有N个星球，编号为1…N。其中的一些星球决定组成联盟，以方便相互间的交流。但是，组成联盟的首要条件就是交通条件。初始时，在这N个星球间有M条太空隧道。每条太空隧道连接两个星球，使得它们能够相互到达。若两个星球属于同一个联盟，则必须存在一条环形线路经过这两个星球，即两个星球间存在两条没有公共隧道的路径。为了壮大联盟的队伍，这些星球将建设P条新的太空隧道。这P条新隧道将按顺序依次建成。一条新轨道建成后，可能会使一些星球属于同一个联盟。你的任务是计算出，在一条新隧道建设完毕后，判断这条新轨道连接的两个星球是否属于同一个联盟，如果属于同一个联盟就计算出这个联盟中有多少个星球。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4998">BZOJ</a>

<h3>Tag</h3>

LCT，并查集

<h2>题目大意</h2>

简单一句话，动态维护边双联通分量

<h2>解决思路</h2>

在线做法
用并查集1维护连通性，并用LCT维护在同一个联通块（注意这里还不是双联通）的点。
如果遇到加入一条边时，两个端点已经在同一个联通块了，说明新形成了一个双联通分量，找出这两点之间的路径，把这个环缩成一个点（这个用并查集2维护），环上所有点都指向一个编号，&#92;(dfs&#92;)一遍可以遍历所有这些点，把它们的&#92;(size&#92;)累加。
要注意，因为我们有缩点的操作，所以在&#92;(LCT&#92;)的各种操作中都要注意及时&#92;(find&#92;)找到编号。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200110;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int rev;
};

int n,m,P;
Splay_Data S[maxN];
int Stack[maxN];
int Set1[maxN],Set2[maxN];
int Size[maxN];

bool Isroot(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
void Link(int x,int y);
int Add_Edge(int u,int v);
int Find(int *f,int x);
void dfs(int now,int fa);

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;P);
    for (int i=1;i&lt;=n;i++) Size[i]=1,Set1[i]=Set2[i]=i;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        u=Find(Set2,u);v=Find(Set2,v);//注意及时Find
        Add_Edge(u,v);
    }
    for (int i=1;i&lt;=P;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        u=Find(Set2,u);v=Find(Set2,v);
        int ret=Add_Edge(u,v);
        if (ret==-1) printf("No\n");
        else printf("%d\n",ret);
    }
    return 0;
}

bool Isroot(int x)
{
    if ((S[Find(Set2,S[x].fa)].ch[0]==x)||(S[Find(Set2,S[x].fa)].ch[1]==x)) return 0;
    return 1;
}

void PushDown(int x)
{
    if (S[x].rev==1)
    {
        S[x].rev=0;
        if (S[x].ch[0]) S[S[x].ch[0]].rev^=1,swap(S[S[x].ch[0]].ch[0],S[S[x].ch[0]].ch[1]);
        if (S[x].ch[1]) S[S[x].ch[1]].rev^=1,swap(S[S[x].ch[1]].ch[0],S[S[x].ch[1]].ch[1]);
    }
    return;
}

void Rotate(int x)
{
    int y=Find(Set2,S[x].fa);int z=Find(Set2,S[y].fa);
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;S[y].ch[sx]=S[x].ch[sx^1];
    S[y].fa=x;S[x].ch[sx^1]=y;
    return;
}

void Splay(int x)
{
    int stacktop=1;Stack[1]=x;
    int now=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=Find(Set2,S[now].fa);
        now=Find(Set2,S[now].fa);
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=Find(Set2,S[x].fa);int z=Find(Set2,S[y].fa);
        if (Isroot(y)==0)
            ((S[y].ch[0]==x)^(S[z].ch[0]==y))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;S[lastx].fa=x;
        lastx=x;x=Find(Set2,S[x].fa);
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);
    S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

int Add_Edge(int u,int v)
{
    if (Find(Set1,u)!=Find(Set1,v))//若u，v还不在同一个联通块，则先联通
    {
        Set1[Find(Set1,u)]=Find(Set1,v);
        Link(u,v);
        return -1;
    }
    else
    {
        Makeroot(u);Access(v);Splay(v);//否则找出u,v的路径，并把整个环的信息压缩到v上
        dfs(v,v);
        S[v].ch[0]=S[v].ch[1]=0;//这里就把整棵子树丢掉了
        return Size[v];
    }
}

int Find(int *f,int x)
{
    if (f[x]!=x) f[x]=Find(f,f[x]);
    return f[x];
}

void dfs(int now,int fa)//dfs fa的子树，把所有信息全部累加到fa中，完成缩点
{
    if (now!=fa) Size[fa]+=Size[now],Set2[now]=fa;
    if (S[now].ch[0]) dfs(S[now].ch[0],fa);
    if (S[now].ch[1]) dfs(S[now].ch[1],fa);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>354</wp:post_id>
		<wp:post_date><![CDATA[2018-01-21 22:41:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-21 14:41:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4998%e6%98%9f%e7%90%83%e8%81%94%e7%9b%9f%ef%bc%88lct%ef%bc%8c%e5%b9%b6%e6%9f%a5%e9%9b%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4530/LOJ2230][Bjoi2014]大融合（LCT）</title>
		<link>http://sycstudio.com/archives/356</link>
		<pubDate>Mon, 22 Jan 2018 08:29:08 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=356</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小强要在 N个孤立的星球上建立起一套通信系统。这套通信系统就是连接 N 个点的一个树。这个树的边是一条一条添加上去的。在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。
<img src="http://sycstudio.com/bzojch/file/4530_0.png" alt="BZOJ4530" />
例如，在上图中，现在一共有了5条边。其中，(3,8)这条边的负载是6，因
为有六条简单路径2-3-8,2-3-8-7,3-8,3-8-7,4-3-8,4-3-8-7路过了(3,8)。
现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的
询问。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4530">BZOJ</a>
权限题，本站离线版本：<a href="http://sycstudio.com/bzojch/p/4530.html">bzojch</a>
<a href="https://loj.ac/problem/2230">LOJ</a>

<h3>Tag</h3>

LCT

<h2>题目大意</h2>

动态维护子树和

<h2>解决思路</h2>

根据乘法原理，就是动态求每一次两边的子树和。
那么由于&#92;(LCT&#92;)的&#92;(size&#92;)只能维护它实儿子的&#92;(size&#92;)之和，对于虚儿子没有办法处理，所以我们对于每一个点再记一个其虚儿子的大小记为&#92;(vsize&#92;)。那么修改这个虚儿子大小的地方就是&#92;(LCT&#92;)中修改边的虚实关系的时候，即&#92;(Link&#92;)操作和&#92;(Access&#92;)操作，在相应的地方修改即可

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int size,vsize;
    int rev;
};

int n;
Splay_Data S[maxN];
int Stack[maxN];

bool Isroot(int x);
void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Split(int x,int y);
void Link(int x,int y);
void Cut(int x,int y);

int main()
{
    int Q;
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=1;i&lt;=n;i++) S[i].size=1,S[i].vsize=0;
    while (Q--)
    {
        char opt;cin&gt;&gt;opt;
        int x,y;scanf("%d%d",&amp;x,&amp;y);
        if (opt=='A') Link(x,y);
        if (opt=='Q')
        {
            Split(x,y);
            printf("%lld\n",1ll*(ll)(S[y].size-S[x].size)*(ll)S[x].size);
        }
    }
    return 0;
}

bool Isroot(int x)
{
    if ((S[S[x].fa].ch[0]==x)||(S[S[x].fa].ch[1]==x)) return 0;
    return 1;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+1+S[x].vsize;
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);
    return;
}

void Splay(int x)
{
    int now=x;
    int stacktop=1;Stack[stacktop]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;
        now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);
    return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].vsize=S[x].vsize+S[S[x].ch[1]].size-S[lastx].size;//注意这里对vsize的操作
        S[x].ch[1]=lastx;S[lastx].fa=x;
        Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    int now=x;
    while (S[now].ch[0]) now=S[now].ch[0];
    return now;
}

void Split(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    return;
}

void Link(int x,int y)
{
    Makeroot(x);Makeroot(y);//注意这里也要makeroot(y)
    S[x].fa=y;S[y].vsize+=S[x].size;
    Update(y);
    return;
}

void Cut(int x,int y)
{
    Split(x,y);
    if (S[y].ch[0]!=x) return;
    S[y].size-=S[x].size;
    S[x].fa=S[y].ch[0]=0;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>356</wp:post_id>
		<wp:post_date><![CDATA[2018-01-22 16:29:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-22 08:29:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4530-loj2230bjoi2014%e5%a4%a7%e8%9e%8d%e5%90%88%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="loj"><![CDATA[LOJ]]></category>
		<category domain="category" nicename="loj"><![CDATA[LOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>20</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-22 21:15:11]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-22 13:15:11]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[因为要把x连到y上面去，如果y不是y所在的splay的根，那么还要修改y的父亲，y的父亲的父亲....等等。那么为了方便起见，把y也转成它所在的splay的根，这样只需要修改y的值就可以了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>18</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>18</wp:comment_id>
			<wp:comment_author><![CDATA[smyjr]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[smyjr@cnblogs.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://cnblogs.com/smyjr/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-22 19:23:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-22 11:23:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[请问博主，Link那里为什么要makeroot(y)啊?]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ2959]长跑（LCT，并查集）</title>
		<link>http://sycstudio.com/archives/360</link>
		<pubDate>Mon, 22 Jan 2018 12:40:46 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=360</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加3000米长跑运动。一时间操场上熙熙攘攘，摩肩接踵，盛况空前。
　　为了让同学们更好地监督自己，学校推行了刷卡机制。
　　学校中有n个地点，用1到n的整数表示，每个地点设有若干个刷卡机。
　　有以下三类事件：
　　1、修建了一条连接A地点和B地点的跑道。
　　2、A点的刷卡机台数变为了B。
　　3、进行了一次长跑。问一个同学从A出发，最后到达B最多可以刷卡多少次。具体的要求如下：
　　当同学到达一个地点时，他可以在这里的每一台刷卡机上都刷卡。但每台刷卡机只能刷卡一次，即使多次到达同一地点也不能多次刷卡。
　　为了安全起见，每条跑道都需要设定一个方向，这条跑道只能按照这个方向单向通行。最多的刷卡次数即为在任意设定跑道方向，按照任意路径从A地点到B地点能刷卡的最多次数。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2959">BZOJ</a>

<h3>Tag</h3>

LCT，并查集

<h2>解决思路</h2>

算是<a href="http://sycstudio.com/archives/354">这题</a>的强化板。
先看题目中关于单向方向的设置，讲得那么复杂，其实就是要求不能走一条边再反向返回，那么说白了就是从&#92;(u&#92;)到&#92;(v&#92;)的话可以走环和直接路径，不能走到一棵子树中去再原路返回。
看到环一定是可以走的，所以我们可以把环缩成一个点，那么就直接动态求两点之间的路径点权和即可。
综上，并查集维护缩点，&#92;(LCT&#92;)维护动态路径点权和。
需要注意的是，第二个操作是修改某一个点上的机器数量，而我们缩点后并没有统计单个点的贡献，所以要在另外存一下原来每一个点的机器数，方便修改。
最后就是与<a href="http://sycstudio.com/archives/354">这题</a>一样需要注意，因为我们缩了点，所以在&#92;(LCT&#92;)中每一步都要&#92;(find&#92;)一下缩点后的编号

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=150010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int key,size;//key代表的是这个点上的机器数（包括缩点后id是它的点），size则是子树的
    int rev;
};

int n;
Splay_Data S[maxN];
int UFS[maxN],Id[maxN];//UFS是标记是否在同一联通块，ID是标记缩点后的编号，这两个都是并查集
int Stack[maxN];
int Mach[maxN];//存放每一个点机器数，注意这里不是缩点后的编号

int Find(int *f,int x);
bool Isroot(int x);
void PushDown(int x);
void Update(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
int Findroot(int x);
void Makeroot(int x);
void Link(int x,int y);
void Cut(int x,int y);
void Add_Edge(int u,int v);
void dfs(int now,int fa);

int main()
{
    int Q;
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;Mach[i]);
        S[i].key=S[i].size=Mach[i],UFS[i]=i,Id[i]=i;
    }
    while (Q--)
    {
        int opt,x,y;scanf("%d%d%d",&amp;opt,&amp;x,&amp;y);
        if (opt==1) Add_Edge(Find(Id,x),Find(Id,y));
        if (opt==2)
        {
            int xx=Find(Id,x);//注意这里，要先减去原来的机器数再加上现在的机器数
            Makeroot(xx);S[xx].key+=y-Mach[x];Update(xx);Mach[x]=y;
        }
        if (opt==3)
        {
            x=Find(Id,x);y=Find(Id,y);
            if (Find(UFS,x)!=Find(UFS,y)) printf("-1\n");
            else
            {
                Makeroot(x);Access(y);Splay(y);
                printf("%d\n",S[y].size);
            }
        }
    }
    return 0;
}

int Find(int *f,int x)
{
    if (f[x]!=x) f[x]=Find(f,f[x]);
    return f[x];
}

bool Isroot(int x)
{
    int fa=Find(Id,S[x].fa);
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+S[x].key;
    return;
}

void Rotate(int x)
{
    int y=Find(Id,S[x].fa),z=Find(Id,S[y].fa);
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);
    return;
}

void Splay(int x)
{
    int now=x;int stacktop=1;Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=Find(Id,S[now].fa);
        now=Find(Id,S[now].fa);
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=Find(Id,S[x].fa);int z=Find(Id,S[y].fa);
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);
    return;
}

void Access(int x)
{
    int lastx=0;
    while(x)
    {
        Splay(x);S[x].ch[1]=lastx;
        Update(x);lastx=x;x=Find(Id,S[x].fa);
    }
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    int now=x;
    while (S[now].ch[0]) now=S[now].ch[0];
    return now;
}

void Makeroot(int x)
{
    Access(x);Splay(x);
    S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[x].fa=S[y].ch[0]=0;Update(y);
    return;
}

void Add_Edge(int u,int v)
{
    if (Find(UFS,u)!=Find(UFS,v))
    {
        UFS[Find(UFS,u)]=Find(UFS,v);
        Link(u,v);
        return;
    }
    else
    {
        Makeroot(u);Access(v);Splay(v);
        dfs(v,v);//把整棵v的所在的splay都缩到v上，把信息都压缩到v中
        S[v].ch[0]=S[v].ch[1]=0;
    }
    return;
}

void dfs(int now,int fa)
{
    if (now!=fa) S[fa].key+=S[now].key,Id[now]=fa;
    if (S[now].ch[0]) dfs(S[now].ch[0],fa);
    if (S[now].ch[1]) dfs(S[now].ch[1],fa);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>360</wp:post_id>
		<wp:post_date><![CDATA[2018-01-22 20:40:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-22 12:40:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2959%e9%95%bf%e8%b7%91%ef%bc%88lct%ef%bc%8c%e5%b9%b6%e6%9f%a5%e9%9b%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1969/Luogu2542][Ahoi2005]LANE 航线规划（LCT，离线操作，并查集）</title>
		<link>http://sycstudio.com/archives/375</link>
		<pubDate>Mon, 22 Jan 2018 14:21:48 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=375</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

对Samuel星球的探险已经取得了非常巨大的成就，于是科学家们将目光投向了Samuel星球所在的星系——一个巨大的由千百万星球构成的Samuel星系。 星际空间站的Samuel II巨型计算机经过长期探测，已经锁定了Samuel星系中许多星球的空间坐标，并对这些星球从1开始编号1、2、3……。 一些先遣飞船已经出发，在星球之间开辟探险航线。 探险航线是双向的，例如从1号星球到3号星球开辟探险航线，那么从3号星球到1号星球也可以使用这条航线。 例如下图所示：
<img src="http://sycstudio.com/bzojch/file/1969_0.jpg" alt="BZOJ1969" />
在5个星球之间，有5条探险航线。 A、B两星球之间，如果某条航线不存在，就无法从A星球抵达B星球，我们则称这条航线为关键航线。 显然上图中，1号与5号星球之间的关键航线有1条：即为4-5航线。 然而，在宇宙中一些未知的磁暴和行星的冲撞，使得已有的某些航线被破坏，随着越来越多的航线被破坏，探险飞船又不能及时回复这些航线，可见两个星球之间的关键航线会越来越多。 假设在上图中，航线4-2（从4号星球到2号星球）被破坏。此时，1号与5号星球之间的关键航线就有3条：1-3，3-4，4-5。 小联的任务是，不断关注航线被破坏的情况，并随时给出两个星球之间的关键航线数目。现在请你帮助完成。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1969">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2542">Luogu</a>

<h3>Tag</h3>

LCT，离线操作，并查集

<h2>解决思路</h2>

把询问倒过来，变成加边，那么就变成动态求图中两点之间桥的个数。而图中两点之间桥的个数，就是把图中的环全部缩点后，两点之间的距离。所以可以用LCT动态维护，遇到环则全部缩成一个点。
需要注意的是，由于有缩点操作，所以在&#92;(LCT&#92;)的每一步跳父亲的时候都要寻找一下缩点后的编号，这个可以用并查集维护。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010;
const int maxM=600010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int size;
    int rev;
};

class Question//把询问离线下来
{
public:
    int c,u,v;
    int ans;
};

int n,m;
Splay_Data S[maxN];
int Id[maxN];
int Stack[maxN];
set&lt;int&gt; Exi[maxN];
Question Qn[maxN];

int Find(int *f,int x);
bool Isroot(int x);
void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Link(int x,int y);
void Add_Edge(int x,int y);
void dfs(int u,int fa);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) Id[i]=i;
    for (int i=1;i&lt;=m;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        if (u&gt;v) swap(u,v);
        Exi[u].insert(v);
    }
    int Q=0;
    {
        int c,u,v;
        while (scanf("%d",&amp;c)!=EOF)
        {
            if (c==-1) break;
            scanf("%d%d",&amp;u,&amp;v);
            if (u&gt;v) swap(u,v);
            Q++;Qn[Q]=(Question){c,u,v};
            if (c==0) Exi[u].erase(v);
        }
    }
    for (int i=1;i&lt;=n;i++)
        for (set&lt;int&gt;::iterator j=Exi[i].begin();j!=Exi[i].end();j++)
            Add_Edge(i,*j);
    for (int i=Q;i&gt;=1;i--)
    {
        if (Qn[i].c==0) Add_Edge(Qn[i].u,Qn[i].v);
        if (Qn[i].c==1)
        {
            int u=Find(Id,Qn[i].u);
            int v=Find(Id,Qn[i].v);
            Makeroot(u);Access(v);Splay(v);
            Qn[i].ans=S[v].size-1;
        }
    }
    for (int i=1;i&lt;=Q;i++) if (Qn[i].c==1) printf("%d\n",Qn[i].ans);
}

int Find(int *f,int x)
{
    if (f[x]!=x) f[x]=Find(f,f[x]);
    return f[x];
}

bool Isroot(int x)
{
    int fa=Find(Id,S[x].fa);
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+1;
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        S[lson].rev^=1;S[rson].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=Find(Id,S[x].fa);int z=Find(Id,S[y].fa);
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);
    return;
}

void Splay(int x)
{
    int now=x;
    int stacktop=1;Stack[1]=now;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=Find(Id,S[now].fa);
        now=Find(Id,S[now].fa);
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=Find(Id,S[x].fa);int z=Find(Id,S[y].fa);
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;Update(x);
        lastx=x;x=Find(Id,S[x].fa);
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);
    S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    int now=x;
    while (S[now].ch[0]) now=S[now].ch[0];
    return now;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

void Add_Edge(int u,int v)
{
    u=Find(Id,u);v=Find(Id,v);
    if (Findroot(u)!=Findroot(v)) Link(u,v);
    else
    {
        Makeroot(u);Access(v);Splay(v);
        dfs(v,v);
        S[v].size=1;S[v].ch[0]=S[v].ch[1]=0;//剩下的点就不要啦
    }
    return;
}

void dfs(int u,int fa)//dfs把所有子树的点的编号修改为根
{
    if (u!=fa) Id[u]=fa;
    if (S[u].ch[0]) dfs(S[u].ch[0],fa);
    if (S[u].ch[1]) dfs(S[u].ch[1],fa);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>375</wp:post_id>
		<wp:post_date><![CDATA[2018-01-22 22:21:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-22 14:21:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1969-luogu2542ahoi2005lane-%e8%88%aa%e7%ba%bf%e8%a7%84%e5%88%92%ef%bc%88lct%ef%bc%8c%e7%a6%bb%e7%ba%bf%e6%93%8d%e4%bd%9c%ef%bc%8c%e5%b9%b6%e6%9f%a5%e9%9b%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e9%87%8d%e8%a6%81%e6%80%9d%e6%83%b3"><![CDATA[重要思想]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5398] GCD Tree（LCT）</title>
		<link>http://sycstudio.com/archives/394</link>
		<pubDate>Wed, 24 Jan 2018 00:56:34 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=394</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Teacher Mai has a graph with n vertices numbered from 1 to n. For every edge(u,v), the weight is gcd(u,v). (gcd(u,v) means the greatest common divisor of number u and v).
You need to find a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is maximized. Print the total weight of these edges.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5398">HDU</a>

<h3>Tag</h3>

LCT

<h2>题目大意</h2>

给定一个&#92;(n&#92;)个点的完全图，两点之间的边的边权为两点的&#92;(gcd&#92;)，求最大生成树

<h2>解决思路</h2>

首先肯定是不能把边都建出来的，所以考虑动态加边。但有一些边是完全没有必要的，一个点只向它的因数连边，因为非因数的边不会更优，这样就把加边的数量降到&#92;(O(n\sqrt{n})&#92;)。
如何动态维护最大生成树呢？我们每加入一条边，它的两端点必然已经在树中有一条路径相连啦，那么找出这条路经上的最小边，如果这个最小边小于要加入的边权，那么删除着一条最小边而插入新的这一条边。
为了维护路径上的最小边编号，我们可以把边变成点插入&#92;(LCT&#92;)，这个点的点权即为边权，而真正的点的点权为无限大。在&#92;(LCT&#92;)中维护一个&#92;(mnid&#92;)，表示最小的边权的编号。那么每次找到这样的一个点代表的边，删掉这一条边即可。
但由于&#92;(LCT&#92;)中会变化点与点的位置关系，所以为了方便删除边，我们要在加边的时候记录它真实连着的是哪个点，这样就可以直接删除啦。
最后需要注意的是，因为边数有&#92;(On\sqrt{n})&#92;)，而实际上是开不了这么大的，但考虑到在任意时刻，生成树中最多只有&#92;(n-1&#92;)条，所以实际有用的边只有&#92;(O(n)&#92;)个，所以可以考虑重复使用，用一个栈作为垃圾栈，存放当期空出来的编号，每次新建点的时候，优先从这个栈中取即可。
请注意常数因子对程序时间效率的影响。另：由于只有合并操作，查找两个点是否在统一联通快可以用并查集，减少&#92;(findroot&#92;)的时间开销。在一些地方可以不&#92;(Update&#92;)

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register
#define IL inline

const int maxNum=100000;
const int maxN=500010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int key;
    int mnid;
    int rev;
    int d1,d2;//如果这个点是边的话，记录下这条边原本连的点是哪两个
};

int n;
Splay_Data S[maxN];
int Stack[maxN];
int nodecnt=maxNum,Rubtop=0,Rub[maxN];//回收
int Ansmst=0;
int Ans[maxNum+10],Fact[maxN];
int UFS[maxN];

IL int GetMin(RG int a,RG int b);
IL bool Isroot(RG int x);
IL void Update(RG int x);
IL void PushDown(RG int x);
IL void Rotate(RG int x);
IL void Splay(RG int x);
IL void Access(RG int x);
IL void Makeroot(RG int x);
IL int Findroot(RG int x);
IL void Link(RG int x,RG int y);
IL void Cut(RG int x,RG int y);
IL int NewNode();
IL bool Delete(RG int u,RG int v,RG int w);
IL void Add_Edge(RG int u,RG int v);
IL int gcd(RG int u,RG int v);
IL void Outp();
int Find(int x);

int main()
{
    for (RG int i=0;i&lt;=maxNum;i++) S[i].key=maxNum+10,UFS[i]=i;
    for (RG int i=2;i&lt;=maxNum;i++)
    {
        RG int fcnt=0;
        for (RG int j=1;(ll)j*(ll)j&lt;=i;j++)
            if (i%j==0)
            {
                Fact[++fcnt]=j;
                if ((ll)j*(ll)j!=i) Fact[++fcnt]=i/j;
            }
        sort(&amp;Fact[1],&amp;Fact[fcnt+1]);
        for (RG int j=1;j&lt;=fcnt;j++) Add_Edge(i,Fact[j]);
        Ans[i]=Ansmst;
    }
    RG int n;
    while (scanf("%d",&amp;n)!=EOF)
        printf("%d\n",Ans[n]);
    return 0;
}

IL int GetMin(RG int a,RG int b)
{
    return ((S[a].key&lt;S[b].key)?(a):(b));
}

IL bool Isroot(RG int x)
{
    RG int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

IL void Update(RG int x)
{
    S[x].mnid=GetMin(x,GetMin(S[S[x].ch[0]].mnid,S[S[x].ch[1]].mnid));
    return;
}

IL void PushDown(RG int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        RG int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

IL void Rotate(RG int x)
{
    RG int y=S[x].fa,z=S[y].fa;
    RG int sx=(x==S[y].ch[1]);
    RG int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);
    return;
}

IL void Splay(RG int x)
{
    RG int stacktop=1,now=x;
    Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;
        now=S[now].fa;
    }
    for (RG int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        RG int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);
    return;
}

IL void Access(RG int x)
{
    RG int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;
        Update(x);lastx=x;x=S[x].fa;
    }
    return;
}

IL void Makeroot(RG int x)
{
    Access(x);Splay(x);S[x].rev^=1;
    swap(S[x].ch[0],S[x].ch[1]);
    return;
}

IL int Findroot(RG int x)
{
    Access(x);Splay(x);
    RG int now=x;
    while (S[now].ch[0]) now=S[now].ch[0];
    return now;
}

IL void Link(RG int x,RG int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

IL void Cut(RG int x,RG int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[x].fa=S[y].ch[0]=0;//Update(y);
    return;
}

IL int NewNode()
{
    RG int pos;
    if (Rubtop!=0) pos=Rub[Rubtop--];
    else pos=++nodecnt;
    S[pos].fa=S[pos].ch[0]=S[pos].ch[1]=0;
    return pos;
}

IL bool Delete(RG int u,RG int v,RG int w)
{
    Makeroot(u);Access(v);Splay(v);
    RG int eid=S[v].mnid;
    if (S[eid].key&gt;w) return 0;
    Ansmst-=S[eid].key;
    Cut(eid,S[eid].d1);Cut(eid,S[eid].d2);
    Rub[++Rubtop]=eid;
    return 1;
}

IL void Add_Edge(RG int u,RG int v)
{
    RG int w=gcd(u,v);
    if (Find(u)==Find(v))
        if (Delete(u,v,w)==0) return;
    UFS[Find(u)]=Find(v);
    RG int eid=NewNode();
    Makeroot(u);Makeroot(v);
    S[u].fa=S[v].fa=eid;
    S[eid].key=w;
    Ansmst+=w;
    S[eid].d1=u;S[eid].d2=v;
    return;
}

IL int gcd(RG int u,RG int v)
{
    RG int t;
    while (v) {t=u;u=v;v=t%v;}
    return u;
}

int Find(int x)
{
    if (UFS[x]!=x) UFS[x]=Find(UFS[x]);
    return UFS[x];
}

void Outp()
{
    printf("id fa ls rs mnid    key\n");
    for (int i=1;i&lt;=nodecnt;i++) printf("%2d%3d%3d%3d%5d [%6d]%12d\n",i,S[i].fa,S[i].ch[0],S[i].ch[1],S[i].mnid,S[S[i].mnid].key,S[i].key);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>394</wp:post_id>
		<wp:post_date><![CDATA[2018-01-24 08:56:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-24 00:56:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5398-gcd-tree%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3669/Luogu2387][Noi2014]魔法森林（LCT）</title>
		<link>http://sycstudio.com/archives/396</link>
		<pubDate>Wed, 24 Jan 2018 01:14:56 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=396</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

为了得到书法大家的真传，小E同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含个N节点M条边的无向图，节点标号为1..N，边标号为1..M。初始时小E同学在号节点1，隐士则住在号节点N。小E需要通过这一片魔法森林，才能够拜访到隐士。
魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在号节点住着两种守护精灵：A型守护精灵与B型守护精灵。小E可以借助它们的力量，达到自己的目的。
只要小E带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边Ei包含两个权值Ai与Bi。若身上携带的A型守护精灵个数不少于Ai，且B型守护精灵个数不少于Bi，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小E发起攻击，他才能成功找到隐士。
由于携带守护精灵是一件非常麻烦的事，小E想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为A型守护精灵的个数与B型守护精灵的个数之和。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3669">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2387">Luogu</a>

<h3>Tag</h3>

LCT

<h2>题目大意</h2>

求一条&#92;(1&#92;)到&#92;(n&#92;)的路径使得路径中最大的&#92;(a&#92;)和&#92;(b&#92;)之和最小

<h2>解决思路</h2>

把边权按照&#92;(a&#92;)排序，从小到大依此插入，动态维护最小生成树。
关于&#92;(LCT&#92;)维护最小生成树，可以参考<a href="http://sycstudio.com/archives/394">这里</a>

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010+100010;
const int maxM=100010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int rev;
    int key,mxid;
    int d1,d2;
};

class Edge
{
public:
    int u,v,a,b;
};

bool operator &lt; (Edge A,Edge B)
{
    return A.a&lt;B.a;
}

int n,m;
int nodecnt;
Splay_Data S[maxN];
int Stack[maxN];
int UFS[maxN];
Edge E[maxM];

bool Isroot(int x);
void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Link(int x,int y);
void Cut(int x,int y);
int GetMax(int a,int b);
int Find(int x);
void Add_Edge(int u,int v,int w);
bool Delete(int u,int v,int w);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    nodecnt=n+1;
    for (int i=1;i&lt;=n;i++) S[i].key=0,UFS[i]=i;
    for (int i=1;i&lt;=m;i++) scanf("%d%d%d%d",&amp;E[i].u,&amp;E[i].v,&amp;E[i].a,&amp;E[i].b);
    sort(&amp;E[1],&amp;E[m+1]);//排序边
    int Ans=inf;
    for (int i=1;i&lt;=m;i++)//依此插入边权
    {
        if (E[i].u==E[i].v) continue;
        Add_Edge(E[i].u,E[i].v,E[i].b);
        if (Find(1)==Find(n))
        {
            Makeroot(1);Access(n);Splay(n);
            Ans=min(Ans,E[i].a+S[S[n].mxid].key);
        }
    }
    if (Ans!=inf) printf("%d\n",Ans);
    else printf("-1\n");
    return 0;
}

bool Isroot(int x)
{
    int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void Update(int x)
{
    S[x].mxid=GetMax(x,GetMax(S[S[x].ch[0]].mxid,S[S[x].ch[1]].mxid));
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[x].ch[sx^1]=y;S[y].fa=x;
    Update(y);
    return;
}

void Splay(int x)
{
    int now=x,stacktop=1;Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;
        now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[1])^(y==S[z].ch[1]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;
    swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    while (S[x].ch[0]) x=S[x].ch[0];
    return x;
}

void Link(int x,int y)
{
    Makeroot(x);Makeroot(y);S[x].fa=y;
    return;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[y].ch[0]=S[x].fa=0;
    return;
}

int GetMax(int a,int b)
{
    return (S[a].key&lt;S[b].key)?(b):(a);
}

int Find(int x)
{
    if (UFS[x]!=x) UFS[x]=Find(UFS[x]);
    return UFS[x];
}

bool Delete(int u,int v,int w)
{
    Makeroot(u);Access(v);Splay(v);
    int eid=S[v].mxid;
    if (S[eid].key&lt;=w) return 0;
    Cut(eid,S[eid].d1);Cut(eid,S[eid].d2);
    return 1;
}

void Add_Edge(int u,int v,int w)
{
    if (Find(u)==Find(v))
        if (Delete(u,v,w)==0) return;
    UFS[Find(u)]=Find(v);
    int eid=++nodecnt;
    Makeroot(u);Makeroot(v);
    S[u].fa=S[v].fa=eid;
    S[eid].d1=u;S[eid].d2=v;
    S[eid].key=w;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>396</wp:post_id>
		<wp:post_date><![CDATA[2018-01-24 09:14:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-24 01:14:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3669-luogu2387noi2014%e9%ad%94%e6%b3%95%e6%a3%ae%e6%9e%97%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2157/Luogu1505][国家集训队]旅游（树链剖分，线段树）</title>
		<link>http://sycstudio.com/archives/400</link>
		<pubDate>Wed, 24 Jan 2018 09:40:06 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=400</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Ray 乐忠于旅游，这次他来到了T 城。T 城是一个水上城市，一共有 N 个景点，有些景点之间会用一座桥连接。为了方便游客到达每个景点但又为了节约成本，T 城的任意两个景点之间有且只有一条路径。换句话说， T 城中只有N − 1 座桥。
Ray 发现，有些桥上可以看到美丽的景色，让人心情愉悦，但有些桥狭窄泥泞，令人烦躁。于是，他给每座桥定义一个愉悦度w，也就是说，Ray 经过这座桥会增加w 的愉悦度，这或许是正的也可能是负的。有时，Ray 看待同一座桥的心情也会发生改变。
现在，Ray 想让你帮他计算从u 景点到v 景点能获得的总愉悦度。有时，他还想知道某段路上最美丽的桥所提供的最大愉悦度，或是某段路上最糟糕的一座桥提供的最低愉悦度。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2157">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1505">Luogu</a>

<h3>Tag</h3>

树链剖分，线段树

<h2>解决思路</h2>

把边权下放到它下面的点上维护，树链剖分后，线段树维护区间和、区间最大值、区间最小值，&#92;(Lazy&#92;)维护区间是否全部取负数。
思路不难，但代码量较大

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=30010;
const int maxM=maxN*2;
const int inf=2147483647;

class SegmentData
{
public:
    int sum;
    int mn,mx;
    int mega;
};

int n;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int Fa[maxN],Size[maxN],Hson[maxN],Top[maxN],Faedge[maxN],Depth[maxN];
int idcnt=0,Id[maxN];
SegmentData S[maxN*6];

void Add_Edge(int u,int v,int w);
void _Add(int u,int v,int w);
void dfs1(int u);
void dfs2(int u,int top);
int QC_max(int u,int v);//查询路径最大值
int QC_min(int u,int v);//查询路径最小值
int QC_sum(int u,int v);//查询路径和
void QC_nega(int u,int v);//把路径上所有边权取负
void PushDown(int now);//线段树下放标记
void Update(int now);//线段树更新
void Modify(int now,int l,int r,int pos,int key);//线段树单点修改
void Makenega(int now,int l,int r,int ql,int qr);//线段树区间取负
int Query_max(int now,int l,int r,int ql,int qr);//线段树区间最大
int Query_min(int now,int l,int r,int ql,int qr);//线段树区间最小
int Query_sum(int now,int l,int r,int ql,int qr);//线段树区间求和

int main()
{
    mem(Head,-1);
    scanf("%d",&amp;n);
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);u++;v++;
        Add_Edge(u,v,w);
    }
    Depth[1]=1;
    dfs1(1);
    dfs2(1,1);
    int Q;scanf("%d",&amp;Q);
    char opt[10];
    while (Q--)
    {
        scanf("%s",opt);
        if (opt[0]=='C')
        {
            int pos,key;scanf("%d%d",&amp;pos,&amp;key);pos++;
            pos=Id[pos];
            Modify(1,1,n,pos,key);
        }
        if (opt[0]=='N')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            QC_nega(u,v);
        }
        if (opt[0]=='S')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            printf("%d\n",QC_sum(u,v));
        }
        if (opt[1]=='A')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            printf("%d\n",QC_max(u,v));
        }
        if (opt[1]=='I')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            printf("%d\n",QC_min(u,v));
        }
    }
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    _Add(u,v,w);_Add(v,u,w);return;
}

void _Add(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void dfs1(int u)
{
    Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=Fa[u])
        {
            Fa[V[i]]=u;Faedge[V[i]]=W[i];
            Depth[V[i]]=Depth[u]+1;
            dfs1(V[i]);
            Size[u]+=Size[V[i]];
            if (Size[V[i]]&gt;Size[Hson[u]]) Hson[u]=V[i];
        }
    return;
}

void dfs2(int u,int top)
{
    Id[u]=++idcnt;
    Modify(1,1,n,idcnt,Faedge[u]);
    Top[u]=top;
    if (Hson[u]==0) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=Fa[u])&amp;&amp;(V[i]!=Hson[u])) dfs2(V[i],V[i]);
    return;
}

int QC_max(int u,int v)
{
    int ret=-inf;
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=max(ret,Query_max(1,1,n,Id[Top[u]],Id[u]));
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    if (u!=v) ret=max(ret,Query_max(1,1,n,Id[u]+1,Id[v]));
    return ret;
}

int QC_min(int u,int v)
{
    int ret=inf;
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=min(ret,Query_min(1,1,n,Id[Top[u]],Id[u]));
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    if (u!=v) ret=min(ret,Query_min(1,1,n,Id[u]+1,Id[v]));
    return ret;
}

int QC_sum(int u,int v)
{
    int ret=0;
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=ret+Query_sum(1,1,n,Id[Top[u]],Id[u]);
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    if (u!=v) ret=ret+Query_sum(1,1,n,Id[u]+1,Id[v]);
    return ret;
}

void QC_nega(int u,int v)
{
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        Makenega(1,1,n,Id[Top[u]],Id[u]);
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    if (u!=v) Makenega(1,1,n,Id[u]+1,Id[v]);
    return;
}

void PushDown(int now)
{
    if (S[now].mega)
    {
        S[now].mega=0;
        int lson=now*2,rson=now*2+1;
        swap(S[lson].mx,S[lson].mn);swap(S[rson].mx,S[rson].mn);
        S[lson].mx=-S[lson].mx;S[lson].mn=-S[lson].mn;
        S[rson].mx=-S[rson].mx;S[rson].mn=-S[rson].mn;
        S[lson].sum=-S[lson].sum;S[rson].sum=-S[rson].sum;
        S[lson].mega^=1;S[rson].mega^=1;
    }
    return;
}

void Update(int now)
{
    int lson=now*2,rson=now*2+1;
    S[now].mx=max(S[lson].mx,S[rson].mx);
    S[now].mn=min(S[lson].mn,S[rson].mn);
    S[now].sum=S[lson].sum+S[rson].sum;
    return;
}

void Modify(int now,int l,int r,int pos,int key)
{
    PushDown(now);
    if (l==r)
    {
        S[now].mx=S[now].mn=S[now].sum=key;
        return;
    }
    int mid=(l+r)/2;
    if (pos&lt;=mid) Modify(now*2,l,mid,pos,key);
    if (pos&gt;=mid+1) Modify(now*2+1,mid+1,r,pos,key);
    Update(now);return;
}

void Makenega(int now,int l,int r,int ql,int qr)
{
    PushDown(now);
    if ((l==ql)&amp;&amp;(r==qr))
    {
        S[now].mega^=1;swap(S[now].mx,S[now].mn);
        S[now].mx=-S[now].mx;S[now].mn=-S[now].mn;
        S[now].sum=-S[now].sum;
        return;
    }
    int mid=(l+r)/2;
    if (qr&lt;=mid) Makenega(now*2,l,mid,ql,qr);
    else if (ql&gt;=mid+1) Makenega(now*2+1,mid+1,r,ql,qr);
    else
    {
        Makenega(now*2,l,mid,ql,mid);Makenega(now*2+1,mid+1,r,mid+1,qr);
    }
    Update(now);return;
}

int Query_max(int now,int l,int r,int ql,int qr)
{
    PushDown(now);
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].mx;
    int mid=(l+r)/2;
    if (qr&lt;=mid) return Query_max(now*2,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query_max(now*2+1,mid+1,r,ql,qr);
    else return max(Query_max(now*2,l,mid,ql,mid),Query_max(now*2+1,mid+1,r,mid+1,qr));
}

int Query_min(int now,int l,int r,int ql,int qr)
{
    PushDown(now);
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].mn;
    int mid=(l+r)/2;
    if (qr&lt;=mid) return Query_min(now*2,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query_min(now*2+1,mid+1,r,ql,qr);
    else return min(Query_min(now*2,l,mid,ql,mid),Query_min(now*2+1,mid+1,r,mid+1,qr));
}

int Query_sum(int now,int l,int r,int ql,int qr)
{
    PushDown(now);
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].sum;
    int mid=(l+r)/2;
    if (qr&lt;=mid) return Query_sum(now*2,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return Query_sum(now*2+1,mid+1,r,ql,qr);
    else return Query_sum(now*2,l,mid,ql,mid)+Query_sum(now*2+1,mid+1,r,mid+1,qr);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>400</wp:post_id>
		<wp:post_date><![CDATA[2018-01-24 17:40:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-24 09:40:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2157-luogu1505%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9f%e6%97%85%e6%b8%b8%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4825/Luogu3721][AH2017/HNOI2017]单旋（LCT）</title>
		<link>http://sycstudio.com/archives/405</link>
		<pubDate>Thu, 25 Jan 2018 02:00:15 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=405</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

H国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了H国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数”来企图毁灭H国。“卡”给H国的人洗脑说，splay如果写成单旋的，将会更快。“卡”称“单旋splay”为“spaly”。虽说他说的很没道理，但还是有H国的人相信了，小H就是其中之一，spaly马上成为他的信仰。而H国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由m（不超过10^5）个操作构成，他知道这样的数据肯定打垮spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作
所需要的实际代价的任务就交给你啦。数据中的操作分为5种：
插入操作：向当前非空spaly中插入一个关键码为key的新孤立节点。插入方法为，先让key和根比较，如果key比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，key比当前子树根x小，而x的左子树为空，那就让key成为x的左孩子；或者key比当前子树根x大，而x的右子树为空，那就让key成为x的右孩子。该操作的代价为：插入后，key的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度”的解释见末尾对spaly的描述。）
单旋最小值:将spaly中关键码最小的元素xmin单旋到根。操作代价为：单旋前xmin的深度。（对于单旋操作的解释见末尾对spaly的描述。）
单旋最大值:将spaly中关键码最大的元素xmax单旋到根。操作代价为：单旋前xmax的深度。
单旋删除最小值：先执行2号操作，然后把根删除。由于2号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同2号操作。
单旋删除最大值：先执行3号操作，然后把根删除。操作代价同3号操作。
对于不是H国的人，你可能需要了解一些spaly的知识，才能完成国王的任务：
spaly是一棵二叉树，满足对于任意一个节点x，它如果有左孩子lx，那么lx的关键码小于x的关键码。如果有右孩子rx，那么rx的关键码大于x的关键码。
  一个节点在spaly的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。
  单旋操作是对于一棵树上的节点x来说的。一开始，设f为x在树上的父亲。如果x为f的左孩子，那么执行zig(x)操作（如上图中，左边的树经过zig(x)变为了右边的树）,否则执行zag(x)操作（在上图中，将右边的树经过zag(f)就变成了左边的树）。每当执行一次zig(x)或者zag(x),x的深度减小1，如此反复，直到x为根。总之，单旋x就是通过反复执行zig和zag将x变为根。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4825">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3721">Luogu</a>

<h3>Tag</h3>

LCT

<h2>解决思路</h2>

肯定不能按照题目的意思写一棵&#92;(spaly&#92;)，那么我们观察题目的性质，发现每一次都只是修改最小值和最大值。以最小值为例，把最小值&#92;(x&#92;)旋转到根其实只会修改&#92;(x&#92;)、&#92;(x&#92;)的右儿子（如果存在）、&#92;(x&#92;)的父亲和根这四个点，所以直接用&#92;(LCT&#92;)在相应的地方&#92;(Link&#92;)和&#92;(Cut&#92;)即可。而每一次的代价就是这个点到根的距离，在&#92;(LCT&#92;)中&#92;(Split\ x&#92;)和&#92;(spaly&#92;)的根就可以得到啦。
为了方便操作，我们可以在每一个点上在维护&#92;(LCT&#92;)的信息的基础上，维护一下它在&#92;(spaly&#92;)中的左右儿子和父亲，这样就可以直接修改啦。
至于插入的话，因为每一次插入都是插入到&#92;(spaly&#92;)中它的前驱的右儿子或是后继的左儿子，并且可以保证这两个位置一定有一个是空的。那么寻找前驱后继可以用&#92;(Set&#92;)维护值，每一次二分查找出第一个比它大的值，再用&#92;(Map&#92;)维护每一个值对应在&#92;(LCT&#92;)中的编号。
需要注意的是，每一个操作都要特殊判断一下当前点是否为&#92;(spaly&#92;)的根，否则会出错

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int size,rev;
    int sls,srs,sfa;//这三个值分别是spaly中的左右儿子和父亲
};

int root,nodecnt=0;//root记录当前spaly的根
Splay_Data S[maxN];
int Stack[maxN];
set&lt;int&gt; Set;//Set维护前驱后继
map&lt;int,int&gt; Map;//Map维护一个值key对应的点的编号是多少

bool Isroot(int x);
void PushDown(int x);
void Update(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Cut(int x,int y);
void Link(int x,int y);
void Insert(int key);
void Splay_min();
void Splay_max();
void Delete_min();
void Delete_max();

int main()
{
    int Q;scanf("%d",&amp;Q);
    while (Q--)
    {
        int c,key;scanf("%d",&amp;c);
        if (c==1) {scanf("%d",&amp;key);Insert(key);}
        if (c==2) Splay_min();
        if (c==3) Splay_max();
        if (c==4) Delete_min();
        if (c==5) Delete_max();
        //cout&lt;&lt;"finish!"&lt;&lt;endl;
    }
    return 0;
}

bool Isroot(int x)
{
    int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int ls=S[x].ch[0],rs=S[x].ch[1];
        swap(S[ls].ch[0],S[ls].ch[1]);swap(S[rs].ch[0],S[rs].ch[1]);
        if (ls) S[ls].rev^=1;
        if (rs) S[rs].rev^=1;
    }
    return;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+1;
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);return;
}

void Splay(int x)
{
    int now=x,stacktop=1;Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    while (S[x].ch[0]) x=S[x].ch[0];
    return x;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    if (S[y].ch[0]!=x) return;
    S[x].fa=S[y].ch[0]=0;
    return;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

void Insert(int key)
{
    nodecnt++;S[nodecnt].size=1;Map[key]=nodecnt;
    if (Set.empty())//若set为空，说明树空，直接插入即可
    {
        Set.insert(key);root=nodecnt;printf("1\n");
        return;
    }
    set&lt;int&gt;::iterator pos=Set.lower_bound(key);//由于题目保证了关键码不重复，所以lower_bound找到的是第一个大于key的位置，即key的后继
    if ((pos==Set.end())||(S[Map[*pos]].sls!=0))//到了最后一个，或者是后继的左儿子非空，那么放到前驱的右儿子
    {
        pos--;//找到前驱
        S[Map[*pos]].srs=nodecnt;S[nodecnt].sfa=Map[*pos];
        Link(nodecnt,Map[*pos]);
    }
    else//否则放到后继的左儿子
    {
        S[Map[*pos]].sls=nodecnt;S[nodecnt].sfa=Map[*pos];
        Link(nodecnt,Map[*pos]);
    }
    Set.insert(key);
    Makeroot(nodecnt);Access(root);Splay(root);
    printf("%d\n",S[root].size);
    return;
}

void Splay_min()
{
    int key=*Set.begin();//找到最小值
    int pos=Map[key];//找到最小值在LCT中的编号
    if (root==pos) {printf("1\n");return;}
    Makeroot(pos);Access(root);Splay(root);//查询代价
    printf("%d\n",S[root].size);
    Cut(pos,S[pos].sfa);if (S[pos].srs) Cut(pos,S[pos].srs);//把pos与pos的父亲、pos的右儿子断开
    Link(pos,root);if (S[pos].srs) Link(S[pos].sfa,S[pos].srs);//把pos与root连接，把pos的右儿子和pos的原父亲接上
    S[root].sfa=pos;//更新spaly中的信息
    S[S[pos].sfa].sls=S[pos].srs;if (S[pos].srs) S[S[pos].srs].sfa=S[pos].sfa;
    S[pos].sfa=0;S[pos].srs=root;
    root=pos;return;
}

void Splay_max()
{
    int key=*(--Set.end());
    int pos=Map[key];
    if (root==pos) {printf("1\n");return;}
    Makeroot(pos);Access(root);Splay(root);
    printf("%d\n",S[root].size);
    Cut(S[pos].sfa,pos);if (S[pos].sls) Cut(S[pos].sls,pos);
    Link(pos,root);if (S[pos].sls) Link(S[pos].sfa,S[pos].sls);
    S[root].sfa=pos;
    S[S[pos].sfa].srs=S[pos].sls;if (S[pos].sls) S[S[pos].sls].sfa=S[pos].sfa;
    S[pos].sfa=0;S[pos].sls=root;
    root=pos;return;
}

void Delete_min()
{
    int key=*Set.begin();
    int pos=Map[key];
    Set.erase(Set.begin());
    if (pos==root)
    {
        printf("1\n");
        S[S[pos].srs].sfa=0;
        if (S[pos].srs) Cut(pos,S[pos].srs);
        root=S[pos].srs;
        return;
    }
    Makeroot(pos);Access(root);Splay(root);
    printf("%d\n",S[root].size);
    Cut(pos,S[pos].sfa);if (S[pos].srs) Cut(pos,S[pos].srs);
    if (S[pos].srs) Link(S[pos].sfa,S[pos].srs);
    S[S[pos].sfa].sls=S[pos].srs;if (S[pos].srs) S[S[pos].srs].sfa=S[pos].sfa;
    return;
}

void Delete_max()
{
    int key=*(--Set.end());
    int pos=Map[key];
    Set.erase(--Set.end());
    if (pos==root)
    {
        printf("1\n");
        S[S[pos].sls].sfa=0;
        if (S[pos].sls) Cut(pos,S[pos].sls);
        root=S[pos].sls;
        return;
    }
    Makeroot(pos);Access(root);Splay(root);
    printf("%d\n",S[root].size);
    Cut(pos,S[pos].sfa);if (S[pos].sls) Cut(pos,S[pos].sls);
    if (S[pos].sls) Link(S[pos].sls,S[pos].sfa);
    S[S[pos].sfa].srs=S[pos].sls;if (S[pos].sls) S[S[pos].sls].sfa=S[pos].sfa;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>405</wp:post_id>
		<wp:post_date><![CDATA[2018-01-25 10:00:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-25 02:00:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4825-luogu3721ah2017-hnoi2017%e5%8d%95%e6%97%8b%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4736/UOJ274]温暖会指引我们前行（LCT）</title>
		<link>http://sycstudio.com/archives/414</link>
		<pubDate>Thu, 25 Jan 2018 12:52:38 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=414</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

虽然小R住的宿舍楼早已来了暖气，但是由于某些原因，宿舍楼中的某些窗户仍然开着（例如厕所的窗户），这就使得宿舍楼中有一些路上的温度还是很低。

小R的宿舍楼中有nn个地点和一些路，一条路连接了两个地点，小R可以通过这条路从其中任意一个地点到达另外一个地点。但在刚开始，小R还不熟悉宿舍楼中的任何一条路，所以他会慢慢地发现这些路，他在发现一条路时还会知道这条路的温度和长度。每条路的温度都是互不相同的。
小R需要在宿舍楼中活动，每次他都需要从一个地点到达另一个地点。小R希望每次活动时经过一条最温暖的路径，最温暖的路径的定义为，将路径上各条路的温度从小到大排序后字典序最大。即温度最低的路温度尽量高，在满足该条件的情况下，温度第二低的路温度尽量高，以此类推。小R不会经过重复的路。由于每条路的温度互不相同，因此只存在一条最温暖的路径。
对于小R的每次活动，你需要求出小R需要走过的路径总长度。如果小R通过当前发现的路不能完成这次活动，则输出 −1−1。
注意本题中的字典序与传统意义上的字典序定义有所不同，对于两个序列a,b(a≠b)a,b(a≠b)，若aa是bb的前缀则aa的字典序较大，同时可以推出空串的字典序最大。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4736">BZOJ</a>
<a href="http://uoj.ac/problem/274">UOJ</a>

<h3>Tag</h3>

LCT

<h2>解决思路</h2>

题目中说的什么字典序最大。说白了就是要求温度的最大生成树，直接用&#92;(LCT&#92;)维护即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=500010;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int rev;
    int len,sum,tem;//当前这个点代表的边的长度，路径总长，温度
    int mnid,d1,d2;
};

int n,nodecnt;
Splay_Data S[maxN];
int Stack[maxN],UFS[maxN];//并查集

bool Isroot(int x);
void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Link(int x,int y);
void Cut(int x,int y);
int GetMin(int id1,int id2);
int Find(int x);
void Add_Edge(int u,int v,int id,int ten,int len);
bool Delete(int u,int v,int tem);
void Outp();

int main()
{
    int Q;
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=0;i&lt;=n;i++) S[i].len=0,S[i].tem=inf,UFS[i]=i;
    char opt[10];
    while (Q--)
    {
        scanf("%s",opt);
        if (opt[0]=='f')
        {
            int id,u,v,tem,len;scanf("%d%d%d%d%d",&amp;id,&amp;u,&amp;v,&amp;tem,&amp;len);u++;v++;
            Add_Edge(u,v,id,tem,len);
        }
        if (opt[0]=='m')
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);u++;v++;
            if (Find(u)!=Find(v)) printf("-1\n");
            else
            {
                Makeroot(u);
                Access(v);Splay(v);
                printf("%d\n",S[v].sum);
            }
        }
        if (opt[0]=='c')
        {
            int id,len;scanf("%d%d",&amp;id,&amp;len);id=id+n+1;
            Makeroot(id);S[id].len=len;Update(id);
        }
    }
    return 0;
}

bool Isroot(int x)
{
    int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void Update(int x)
{
    S[x].sum=S[S[x].ch[0]].sum+S[S[x].ch[1]].sum+S[x].len;
    S[x].mnid=GetMin(x,GetMin(S[S[x].ch[0]].mnid,S[S[x].ch[1]].mnid));
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int ls=S[x].ch[0],rs=S[x].ch[1];
        swap(S[ls].ch[0],S[ls].ch[1]);swap(S[rs].ch[0],S[rs].ch[1]);
        if (ls) S[ls].rev^=1;
        if (rs) S[rs].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);return;
}

void Splay(int x)
{
    int now=x,stacktop=1;Stack[1]=now;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].ch[1]=lastx;Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    while (S[x].ch[0]) x=S[x].ch[0];
    return x;
}

void Link(int x,int y)
{
    Makeroot(x);S[x].fa=y;
    return;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[x].fa=S[y].ch[0]=0;
    return;
}

int GetMin(int id1,int id2)
{
    return (S[id1].tem&lt;S[id2].tem)?(id1):(id2);
}

int Find(int x)
{
    if (UFS[x]!=x) UFS[x]=Find(UFS[x]);
    return UFS[x];
}

void Add_Edge(int u,int v,int id,int tem,int len)
{
    id=id+n+1;
    if (Find(u)==Find(v))
        if (Delete(u,v,tem)==0) return;
    UFS[Find(u)]=Find(v);
    Makeroot(u);Makeroot(v);
    S[id].len=len;S[id].tem=tem;S[id].d1=u;S[id].d2=v;
    S[u].fa=id;S[v].fa=id;Update(id);
    return;
}

bool Delete(int u,int v,int tem)
{
    Makeroot(u);Access(v);Splay(v);
    if (S[S[v].mnid].tem&gt;tem) return 0;
    int mnid=S[v].mnid;
    Makeroot(mnid);
    Cut(mnid,S[mnid].d1);Cut(mnid,S[mnid].d2);
    S[mnid].fa=S[mnid].ch[0]=S[mnid].ch[1]=0;
    return 1;
}

void Outp()
{
    printf("id fa ls rs d1 d2 mnid len tem sum\n");
    for (int i=1;i&lt;=n+5;i++) printf("%2d%3d%3d%3d%3d%3d%5d%4d%4d%4d\n",i,S[i].fa,S[i].ch[0],S[i].ch[1],S[i].d1,S[i].d2,S[i].mnid,S[i].len,S[i].tem,S[i].sum);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>414</wp:post_id>
		<wp:post_date><![CDATA[2018-01-25 20:52:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-25 12:52:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4736-uoj274%e6%b8%a9%e6%9a%96%e4%bc%9a%e6%8c%87%e5%bc%95%e6%88%91%e4%bb%ac%e5%89%8d%e8%a1%8c%ef%bc%88lct%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>67</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.53]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 21:35:34]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 13:35:34]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@zhoushuyu(an)：+1]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>45</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>63</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.52]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-27 19:56:16]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-27 11:56:16]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[从未见过萝卜写过如此短的题解，想必萝卜觉得此题不难]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>45</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>45</wp:comment_id>
			<wp:comment_author><![CDATA[zhoushuyu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[978982520@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-25 22:36:00]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 14:36:00]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[从未见过如此数形结合生动详细通俗易懂精妙无双的LCT题解！给博主好评！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>7</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>47</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.31.63]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-26 00:23:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-25 16:23:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你是有多无聊啊。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>45</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[HDU2665]Kth number （主席树）</title>
		<link>http://sycstudio.com/archives/422</link>
		<pubDate>Fri, 26 Jan 2018 01:05:06 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=422</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Give you a sequence and ask you the kth big number of a inteval.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-2665">HDU</a>

<h3>Tag</h3>

主席树

<h2>题目大意</h2>

求区间第&#92;(K&#92;)大

<h2>解决思路</h2>

主席树练手题。
相当于建立出&#92;(n&#92;)棵权值线段树，第&#92;(i&#92;)棵权值线段树保存的是前&#92;(i&#92;)个点的信息，那么类似与前缀和的思想，求&#92;([l,r]&#92;)的线段树就用第&#92;(r&#92;)棵线段树减去第&#92;(l&#92;)棵线段树，在这课作差得到的线段树上查询即可。而主席树就是利用已知信息节约空间。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100110;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;//左右儿子
    int sum;
};

int n,m;
int nodecnt=0;
SegmentData S[maxN*20];
int root[maxN];//保存根节点
int Arr[maxN],Brr[maxN];

void Build(int &amp;now,int l,int r);
void Update(int &amp;now,int l,int r,int num);
int Query(int now1,int now2,int l,int r,int kth);

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        nodecnt=0;
        scanf("%d%d",&amp;n,&amp;m);
        for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Arr[i]),Brr[i]=Arr[i];
        sort(&amp;Brr[1],&amp;Brr[n+1]);//读进来后先离散化
        for (int i=1;i&lt;=n;i++) Arr[i]=lower_bound(&amp;Brr[1],&amp;Brr[n+1],Arr[i])-Brr;
        Build(root[0],1,n);//初始化
        for (int i=1;i&lt;=n;i++) root[i]=root[i-1],Update(root[i],1,n,Arr[i]);//构造n棵主席树
        while (m--)
        {
            int l,r,kth;scanf("%d%d%d",&amp;l,&amp;r,&amp;kth);//查询第K大
            printf("%d\n",Brr[Query(root[l-1],root[r],1,n,kth)]);
        }
    }
    return 0;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)/2;
    Build(S[now].ls,l,mid);
    Build(S[now].rs,mid+1,r);
    return;
}

void Update(int &amp;now,int l,int r,int num)
{
    S[++nodecnt]=S[now];
    S[now=nodecnt].sum++;
    if (l==r) return;
    int mid=(l+r)/2;
    if (num&lt;=mid) Update(S[now].ls,l,mid,num);
    else Update(S[now].rs,mid+1,r,num);
    return;
}

int Query(int now1,int now2,int l,int r,int kth)
{
    if (l==r) return l;
    int lsize=S[S[now2].ls].sum-S[S[now1].ls].sum;
    int mid=(l+r)/2;
    if (lsize&gt;=kth) return Query(S[now1].ls,S[now2].ls,l,mid,kth);
    else return Query(S[now1].rs,S[now2].rs,mid+1,r,kth-lsize);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>422</wp:post_id>
		<wp:post_date><![CDATA[2018-01-26 09:05:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-26 01:05:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu2665kth-number-%ef%bc%88%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4417]Super Mario（主席树）</title>
		<link>http://sycstudio.com/archives/426</link>
		<pubDate>Fri, 26 Jan 2018 02:23:21 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=426</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Mario is world-famous plumber. His “burly” figure and amazing jumping ability reminded in our memory. Now the poor princess is in trouble again and Mario needs to save his lover. We regard the road to the boss’s castle as a line (the length is n), on every integer point i there is a brick on height hi. Now the question is how many bricks in [L, R] Mario can hit if the maximal height he can jump is H.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-4417">HDU</a>

<h3>Tag</h3>

主席树

<h2>题目大意</h2>

求区间内小于给定的&#92;(K&#92;)的数的个数

<h2>解决思路</h2>

离散化并去重之后，用主席树维护权值线段树，类似前缀和地查询即可。
有点卡时，要手写二分+去重才行

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register
#define IL inline

const int maxN=100005;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;
    int sum;
};

int n,nodecnt=0,length;
int root[maxN];
SegmentData S[maxN*25];
int Arr[maxN];
int Brr[maxN];

int Find(int key);//二分
void Build(int &amp;now,int l,int r);
void Update(int &amp;now,int l,int r,int num);
int Query(int now1,int now2,int l,int r,int qr);

int main()
{
    int T;scanf("%d",&amp;T);
    for (int ti=1;ti&lt;=T;ti++)
    {
        mem(S,0);
        mem(root,0);
        printf("Case %d:\n",ti);
        RG int Q;
        nodecnt=0;
        scanf("%d%d",&amp;n,&amp;Q);
        for (RG int i=1;i&lt;=n;i++) scanf("%d",&amp;Arr[i]),Brr[i]=Arr[i];
        sort(&amp;Brr[1],&amp;Brr[n+1]);length=unique(&amp;Brr[1],&amp;Brr[n+1])-Brr-1;//离散化+去重
        for (RG int i=1;i&lt;=n;i++) Arr[i]=Find(Arr[i]);
        Build(root[0],1,length);
        for (RG int i=1;i&lt;=n;i++) root[i]=root[i-1],Update(root[i],1,length,Arr[i]);
        while (Q--)
        {
            RG int l,r,h;scanf("%d%d%d",&amp;l,&amp;r,&amp;h);l++;r++;
            RG int hh=Find(h);
            if (hh==0) {printf("0\n");continue;}//注意特判0的情况
            printf("%d\n",Query(root[l-1],root[r],1,length,hh));
        }
    }
    return 0;
}

void Build(RG int &amp;now,RG int l,RG int r)
{
    now=++nodecnt;
    if (l==r) return;
    RG int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);
    Build(S[now].rs,mid+1,r);
    return;
}

void Update(RG int &amp;now,RG int l,RG int r,RG int num)
{
    S[++nodecnt]=S[now];now=nodecnt;
    S[now].sum++;
    if (l==r) return;
    RG int mid=(l+r)&gt;&gt;1;
    if (num&lt;=mid) Update(S[now].ls,l,mid,num);
    else Update(S[now].rs,mid+1,r,num);
}

int Query(RG int now1,RG int now2,RG int l,RG int r,RG int qr)
{
    if (qr==r) return S[now2].sum-S[now1].sum;
    RG int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return Query(S[now1].ls,S[now2].ls,l,mid,qr);
    else return Query(S[now1].ls,S[now2].ls,l,mid,mid)+Query(S[now1].rs,S[now2].rs,mid+1,r,qr);
}


int Find(int key)
{
    int l=1,r=length;
    int ret=0;
    while (l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if (Brr[mid]&lt;=key)
            ret=mid,l=mid+1;
        else r=mid-1;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>426</wp:post_id>
		<wp:post_date><![CDATA[2018-01-26 10:23:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-26 02:23:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu4417super-mario]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[CodeChef GERALD07/BZOJ3514]Codechef MARCH14 GERALD07[加强版]（LCT，主席树）</title>
		<link>http://sycstudio.com/archives/434</link>
		<pubDate>Sat, 27 Jan 2018 00:38:56 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=434</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

N个点M条边的无向图，询问保留图中编号在[l,r]的边的时候图中的联通块个数。

<h3>Http</h3>

<a href="https://vjudge.net/problem/CodeChef-GERALD07">Codechef</a>
<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3514">BZOJ</a>

<h3>Tag</h3>

LCT，主席树

<h2>解决思路</h2>

原题没有强制在线，加强版有，我们直接讨论加强版的做法。
考虑一条边&#92;(u->v&#92;)，若加入它之前&#92;(u,v&#92;)不连通，那么加入它之后，连通块个数减一；否则，连通块个数不变，但图中出现了一个环，此时，我们去掉这个环中最早加入的边，记&#92;(ntr[i]&#92;)表示加入&#92;(i&#92;)这条边时，去掉的那个最早的边的编号，特别的，若之前&#92;(u,v&#92;)不连通，&#92;(ntr[i]=0&#92;)，若为自环，&#92;(ntr[i]=i&#92;)。
求出这个&#92;(ntr&#92;)之后，对于询问&#92;(l,r&#92;)之间的边，我们计算&#92;(l,r&#92;)中&#92;(ntr&#92;)小于&#92;(l&#92;)的有多少个，用总点数&#92;(n&#92;)减去这个个数即为每一次的答案。
这么做为什么是对的呢？由于我们&#92;(ntr&#92;)中记录的是与这一条边形成环的最早的边的编号，那么如果这一条边的&#92;(ntr&#92;)小于&#92;(l&#92;)，那么也就是说它一定有减去一个连通块的贡献，否则，它的两个端点已经在一个连通块中了，把它加入不会影响答案。
那么，任务就变成了按照编号顺序依此加边，维护编号尽量大的一棵生成树，这个可以用&#92;(LCT&#92;)维护；至于查询&#92;(l,r&#92;)中&#92;(ntr&#92;)小于&#92;(l&#92;)的个数，可以插入到一棵主席树维护权值线段树。
注意，&#92;(Codechef&#92;)有多组数据，下面的代码是针对&#92;(BZOJ&#92;)的。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200010;
const int inf=2147483647;

int n,m;

namespace LCT//LinkCutTree
{
    class Splay_Data
    {
    public:
        int fa,ch[2];
        int rev;
        int key;
        int mnid;//记录加入最早的边的编号
        int d1,d2;
    };

    int nodecnt=0;
    Splay_Data S[maxN*2];
    int Stack[maxN*2];

    bool Isroot(int x)
    {
        if ((S[S[x].fa].ch[0]==x)||(S[S[x].fa].ch[1]==x)) return 0;
        return 1;
    }

    void Update(int x)
    {
        S[x].mnid=x;
        if (S[S[S[x].ch[0]].mnid].key&lt;S[S[x].mnid].key) S[x].mnid=S[S[x].ch[0]].mnid;
        if (S[S[S[x].ch[1]].mnid].key&lt;S[S[x].mnid].key) S[x].mnid=S[S[x].ch[1]].mnid;
        return;
    }

    void PushDown(int x)
    {
        if (S[x].rev)
        {
            S[x].rev=0;int ls=S[x].ch[0],rs=S[x].ch[1];
            swap(S[ls].ch[0],S[ls].ch[1]);swap(S[rs].ch[0],S[rs].ch[1]);
            if (ls) S[ls].rev^=1;
            if (rs) S[rs].rev^=1;
        }
        return;
    }

    void Rotate(int x)
    {
        int y=S[x].fa,z=S[y].fa;
        int sx=(x==S[y].ch[1]);
        int sy=(y==S[z].ch[1]);
        S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
        S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
        S[y].fa=x;S[x].ch[sx^1]=y;
        Update(y);return;
    }

    void Splay(int x)
    {
        int now=x,stacktop=1;Stack[1]=x;
        while (Isroot(now)==0)
        {
            Stack[++stacktop]=S[now].fa;now=S[now].fa;
        }
        for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
        while (Isroot(x)==0)
        {
            int y=S[x].fa,z=S[y].fa;
            if (Isroot(y)==0)
                ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
            Rotate(x);
        }
        Update(x);return;
    }

    void Access(int x)
    {
        int lastx=0;
        while (x)
        {
            Splay(x);S[x].ch[1]=lastx;Update(x);
            lastx=x;x=S[x].fa;
        }
        return;
    }

    void Makeroot(int x)
    {
        Access(x);Splay(x);S[x].rev^=1;
        swap(S[x].ch[0],S[x].ch[1]);
        return;
    }

    int Findroot(int x)
    {
        Access(x);Splay(x);
        while (S[x].ch[0]) x=S[x].ch[0];
        return x;
    }

    void Link(int x,int y)
    {
        Makeroot(x);S[x].fa=y;
        return;
    }

    void Cut(int x,int y)
    {
        Makeroot(x);Access(y);Splay(y);
        S[x].fa=S[y].ch[0]=0;
        return;
    }
    void Add_Edge(int u,int v,int id)
    {
        Makeroot(u);Makeroot(v);
        ++nodecnt;
        S[nodecnt].key=id;
        S[u].fa=nodecnt;S[v].fa=nodecnt;
        S[nodecnt].d1=u;S[nodecnt].d2=v;
        return;
    }
};

namespace Seg//主席树
{
    class SegmentData
    {
    public:
        int ls,rs;
        int sum;
    };

    int nodecnt=0;
    int root[maxN];
    SegmentData S[maxN*30];
    void Build(int &amp;now,int l,int r)
    {
        now=++nodecnt;
        if (l==r) return;
        int mid=(l+r)&gt;&gt;1;
        Build(S[now].ls,l,mid);
        Build(S[now].rs,mid+1,r);
        return;
    }

    void Update(int &amp;now,int l,int r,int num)
    {
        S[++nodecnt]=S[now];now=nodecnt;
        S[nodecnt].sum++;
        if (l==r) return;
        int mid=(l+r)&gt;&gt;1;
        if (num&lt;=mid) Update(S[now].ls,l,mid,num);
        else Update(S[now].rs,mid+1,r,num);
        return;
    }

    int Query(int now1,int now2,int l,int r,int ql,int qr)
    {
        if ((l==ql)&amp;&amp;(r==qr)) return S[now2].sum-S[now1].sum;
        int mid=(l+r)/2;
        if (qr&lt;=mid) return Query(S[now1].ls,S[now2].ls,l,mid,ql,qr);
        else if (ql&gt;=mid+1) return Query(S[now1].rs,S[now2].rs,mid+1,r,ql,qr);
        return Query(S[now1].ls,S[now2].ls,l,mid,ql,mid)+Query(S[now1].rs,S[now2].rs,mid+1,r,mid+1,qr);
    }
};

int K,type;
int ntr[maxN];

int main()
{
    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;K,&amp;type);
    for (int i=0;i&lt;=n;i++) LCT::S[i].key=inf;
    LCT::nodecnt=n;
    for (int i=1;i&lt;=m;i++)//依此加入边，维护生成树
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        if (u==v) {ntr[i]=i;continue;}//自环
        if (LCT::Findroot(u)!=LCT::Findroot(v))
            LCT::Add_Edge(u,v,i);
        else
        {
            LCT::Makeroot(u);LCT::Access(v);LCT::Splay(v);
            int mnid=LCT::S[v].mnid;
            ntr[i]=LCT::S[mnid].key;
            LCT::Cut(LCT::S[mnid].d1,LCT::S[mnid].d2);
            LCT::Add_Edge(u,v,i);
        }
    }
    Seg::Build(Seg::root[0],0,m);
    for (int i=1;i&lt;=m;i++)//把ntr插入到主席树中方便查询
    {
        Seg::root[i]=Seg::root[i-1];
        Seg::Update(Seg::root[i],0,m,ntr[i]);
    }
    int ans=0;
    while (K--)
    {
        int l,r;scanf("%d%d",&amp;l,&amp;r);
        if (type) l^=ans,r^=ans;
        ans=n-Seg::Query(Seg::root[l-1],Seg::root[r],0,m,0,l-1);
        printf("%d\n",ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>434</wp:post_id>
		<wp:post_date><![CDATA[2018-01-27 08:38:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-27 00:38:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[codechef-gerald07-bzoj3514codechef-march14-gerald07%e5%8a%a0%e5%bc%ba%e7%89%88%ef%bc%88lct%ef%bc%8c%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="codechef"><![CDATA[Codechef]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="codechef"><![CDATA[Codechef]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[SPOJ COT/BZOJ 2588]COT - Count on a tree（主席树，LCA，离散化）</title>
		<link>http://sycstudio.com/archives/436</link>
		<pubDate>Sat, 27 Jan 2018 01:58:28 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=436</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

You are given a tree with N nodes. The tree nodes are numbered from 1 to N. Each node has an integer weight.
We will ask you to perform the following operation:
u v k : ask for the kth minimum weight on the path from node u to node v

<h3>Http</h3>

<a href="http://www.spoj.com/problems/COT/">SPOJ</a>
<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2588">BZOJ</a>

<h3>Tag</h3>

主席树，LCA，离散化

<h2>题目大意</h2>

给出一棵点权树，求两点之间路径上的第&#92;(K&#92;)大的点权

<h2>解决思路</h2>

以&#92;(1&#92;)为根，变成有根树，那么现在就是查询&#92;(u&#92;)到&#92;(lca&#92;)并上&#92;(v&#92;)到&#92;(lca&#92;)路径上的第&#92;(K&#92;)大。考虑用主席树给每一个&#92;(i&#92;)到根的路径维护一棵权值线段树，那么可以用类似前缀和的思想，利用&#92;(u,v,lca,fa[lca]&#92;)这四个点加减构造出路径的权值线段树。
因为树是静态的，所以这里采用倍增的方式求出&#92;(lca&#92;)
注意离散化。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=200010;
const int maxM=maxN*2;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;
    int sum;
};

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int NodeW[maxN],Num[maxN];
int Fa[maxN][25],Depth[maxN];
int nodecnt=0,root[maxN];
SegmentData S[maxN*30];

void dfs1(int u,int fa);
void dfs2(int u);
int LCA(int u,int v);
void Build(int &amp;now,int l,int r);
void Update(int &amp;now,int l,int r,int num);
int Query(int n1,int n2,int n3,int n4,int l,int r,int kth);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;NodeW[i]),Num[i]=NodeW[i];
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
    }
    Depth[1]=1;
    dfs1(1,0);//倍增lca预处理
    for (int j=1;j&lt;25;j++)
        for (int i=1;i&lt;=n;i++)
            if (Fa[i][j-1]!=0) Fa[i][j]=Fa[Fa[i][j-1]][j-1];
    sort(&amp;Num[1],&amp;Num[n+1]);//点权离散化
    for (int i=1;i&lt;=n;i++) NodeW[i]=lower_bound(&amp;Num[1],&amp;Num[n+1],NodeW[i])-Num;
    Build(root[0],1,n);//初始化主席树
    dfs2(1);//构造主席树
    int ans=0;
    for (int ti=1;ti&lt;=m;ti++)
    {
        int u,v,kth;scanf("%d%d%d",&amp;u,&amp;v,&amp;kth);u^=ans;
        int lca=LCA(u,v);
        ans=Num[Query(root[u],root[v],root[lca],root[Fa[lca][0]],1,n,kth)];
        printf("%d",ans);
        if (ti!=m) printf("\n");
    }
    return 0;
}

void dfs1(int u,int fa)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Depth[V[i]]=Depth[u]+1;
            Fa[V[i]][0]=u;
            dfs1(V[i],u);
        }
    return;
}

void dfs2(int u)
{
    root[u]=root[Fa[u][0]];
    Update(root[u],1,n,NodeW[u]);
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=Fa[u][0])
            dfs2(V[i]);
    return;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);
    Build(S[now].rs,mid+1,r);
    return;
}

void Update(int &amp;now,int l,int r,int num)
{
    S[++nodecnt]=S[now];
    now=nodecnt;S[now].sum++;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if (num&lt;=mid) Update(S[now].ls,l,mid,num);
    else Update(S[now].rs,mid+1,r,num);
    return;
}

int Query(int n1,int n2,int n3,int n4,int l,int r,int kth)
{
    if (l==r) return l;
    int lsize=S[S[n1].ls].sum+S[S[n2].ls].sum-S[S[n3].ls].sum-S[S[n4].ls].sum;
    int mid=(l+r)&gt;&gt;1;
    if (lsize&gt;=kth) return Query(S[n1].ls,S[n2].ls,S[n3].ls,S[n4].ls,l,mid,kth);
    else return Query(S[n1].rs,S[n2].rs,S[n3].rs,S[n4].rs,mid+1,r,kth-lsize);
}

int LCA(int u,int v)
{
    if ((u==1)||(v==1)) return 1;
    if (Depth[v]&gt;Depth[u]) swap(u,v);
    for (int i=24;i&gt;=0;i--) if ((Fa[u][i])&amp;&amp;(Depth[Fa[u][i]]&gt;=Depth[v])) u=Fa[u][i];
    if (u==v) return u;
    for (int i=24;i&gt;=0;i--) if ((Fa[u][i])&amp;&amp;(Fa[v][i])&amp;&amp;(Fa[u][i]!=Fa[v][i])) u=Fa[u][i],v=Fa[v][i];
    return Fa[u][0];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>436</wp:post_id>
		<wp:post_date><![CDATA[2018-01-27 09:58:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-27 01:58:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[spoj-cot-bzoj-2588cot-count-on-a-tree%ef%bc%88%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%8clca%ef%bc%8c%e7%a6%bb%e6%95%a3%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="post_tag" nicename="lca"><![CDATA[LCA]]></category>
		<category domain="category" nicename="lca"><![CDATA[LCA]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3932/Luogu3186][CQOI2015]任务查询系统（主席树，差分，离散化）</title>
		<link>http://sycstudio.com/archives/439</link>
		<pubDate>Sat, 27 Jan 2018 07:34:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=439</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。超级计算机中的任务用三元组(Si,Ei,Pi)描述，(Si,Ei,Pi)表示任务从第Si秒开始，在第Ei秒后结束（第Si秒和Ei秒任务也在运行），其优先级为Pi。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。调度系统会经常向查询系统询问，第Xi秒正在运行的任务中，优先级最小的Ki个任务（即将任务按照优先级从小到大排序后取前Ki个）的优先级之和是多少。特别的，如果Ki大于第Xi秒正在运行的任务总数，则直接回答第Xi秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在1到n之间（包含1和n）。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3932">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3168">Luogu</a>

<h3>Tag</h3>

主席树，差分，离散化

<h2>解决思路</h2>

我们考虑对于一个任务&#92;(s->e&#92;)，考虑差分在&#92;(s&#92;)加入，在&#92;(t+1&#92;)减去。为了维护区间第&#92;(K&#92;)的相关问题，用主席树维护前缀和即可。
注意离散化

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=210010;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;
    ll cnt,sum;
    int tim;//时间戳
};

class Edge
{
public:
    int s,e,p;
};

int n,m;
int nodecnt=0,root[maxN];
int nowtim;
vector&lt;int&gt; E[maxN];
Edge Input[maxN];
SegmentData S[maxN*30];
int Num[maxN];

void Build(int &amp;now,int l,int r);
void Update(int n1,int &amp;n2,int l,int r,int id,ll key);
ll Query(int now,int l,int r,int kth);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d%d%d",&amp;Input[i].s,&amp;Input[i].e,&amp;Input[i].p);
        Num[i]=Input[i].p;
    }
    sort(&amp;Num[1],&amp;Num[n+1]);
    for (int i=1;i&lt;=n;i++)
    {
        Input[i].p=lower_bound(&amp;Num[1],&amp;Num[n+1],Input[i].p)-Num;
        E[Input[i].s].push_back(Input[i].p);E[Input[i].e+1].push_back(-Input[i].p);
    }
    Build(root[0],1,m+1);
    for (int i=1;i&lt;=m+1;i++)
    {
        root[i]=root[i-1];nowtim=i;
        for (int j=0;j&lt;E[i].size();j++)
            if (E[i][j]&gt;0) Update(root[i],root[i],1,m+1,E[i][j],Num[E[i][j]]);
            else Update(root[i],root[i],1,m+1,-E[i][j],-Num[-E[i][j]]);
    }
    ll ans=1;
    for (int i=1;i&lt;=m;i++)
    {
        int x,a,b,c;scanf("%d%d%d%d",&amp;x,&amp;a,&amp;b,&amp;c);
        int kth=((ll)a*(ll)ans%c+b%c)%c+1;
        if (S[root[x]].cnt&lt;=kth) printf("%lld\n",ans=S[root[x]].sum);
        else printf("%lld\n",ans=Query(root[x],1,m+1,kth));
    }
    return 0;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);Build(S[now].rs,mid+1,r);
    return;
}

void Update(int n1,int &amp;n2,int l,int r,int id,ll key)
{
    //cout&lt;&lt;id&lt;&lt;" "&lt;&lt;key&lt;&lt;endl;
    if (S[n1].tim!=nowtim)
    {
        S[++nodecnt]=S[n1];n2=nodecnt;
        S[n2].tim=nowtim;
    }
    if (key&gt;0) S[n2].cnt++;else S[n2].cnt--;
    S[n2].sum=(ll)S[n2].sum+(ll)key;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if (id&lt;=mid) Update(S[n1].ls,S[n2].ls,l,mid,id,key);
    else Update(S[n1].rs,S[n2].rs,mid+1,r,id,key);
    return;
}

ll Query(int now,int l,int r,int kth)
{
    if (l==r) return (ll)Num[l]*(ll)kth;
    int mid=(l+r)&gt;&gt;1;
    if (S[S[now].ls].cnt&gt;=kth) return Query(S[now].ls,l,mid,kth);
    else return Query(S[now].rs,mid+1,r,kth-S[S[now].ls].cnt)+S[S[now].ls].sum;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>439</wp:post_id>
		<wp:post_date><![CDATA[2018-01-27 15:34:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-27 07:34:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3932-luogu3186cqoi2015%e4%bb%bb%e5%8a%a1%e6%9f%a5%e8%af%a2%e7%b3%bb%e7%bb%9f%ef%bc%88%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%8c%e5%b7%ae%e5%88%86%ef%bc%8c%e7%a6%bb%e6%95%a3%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="post_tag" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="category" nicename="%e5%b7%ae%e5%88%86"><![CDATA[差分]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[51Nod1814]Clarke and string(回文树) by dsl</title>
		<link>http://sycstudio.com/archives/443</link>
		<pubDate>Sun, 28 Jan 2018 07:48:38 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=443</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

克拉克是一名人格分裂患者.有一天克拉克分裂成 &#092;(n&#092;) 个人.<br />
每个克拉克手里有一个由小写字母组成字符串 &#092;(&#095;i&#092;) .克拉克们还有&#092;(q&#092;),第&#092;(i&#092;)次询问,克拉克们想知道有多少个回文串同时出现在&#092;(a&#095;{xi}&#092;)和&#092;(a&#095;{yi}&#092;)中.<br />
一个字符串称为回文串当且仅当这个串前后反转后与这个串相同。

&#092;(n, q, \sum a_i \leqslant 100000&#092;)

<h1>Solution</h1>

upd:
不想写代码了，口胡一下好了：
用回文树求出每个串本质不同的回文子串。然后用&#092;(hash+set&#092;)存储。
每次在set里询问即可。
时间复杂度&#092;(O(n \sqrt n \log n)&#092;)

<hr />

对于每组询问，暴力构出两个串的回文树，然后在较短的串中查询即可。为了加快速度，为每组询问加上记忆化。

然后就AC啦？！

让我们证明一下这样做的正确性，即时间复杂度为&#092;(O(n\sqrt n)&#092;)：
设每组询问的串为&#092;(x,y&#092;)

<ol>
<li>设&#092;(|s_x|&#092;leqslant &#092;sqrt n&#092;)或&#092;(|s_y|\leqslant \sqrt n&#092;)，由于时间复杂度与较短的串有关，所以复杂度显然正确。</p></li>
<li><p>否则&#092;(|s_x|\geqslant\sqrt n&#092;)的串最多有&#092;(\sqrt n&#092;)个,&#092;(|s_x|\geqslant \sqrt n&#092;)且&#092;(|s_y|\geqslant \sqrt n&#092;)最多只有&#092;(n&#092;)种询问，加
上记忆化后显然正确。</p></li>
</ol>

<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;
int n, q;
vector&lt;char&gt; s[maxn];

inline int gi()
{
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

map&lt;pair&lt;int, int&gt;, int&gt; f;

struct palindromic_tree 
{
    pair&lt;int, int&gt; ch[maxn][26];
    int cnt, tot, ans, len[maxn], fail[maxn], last;

    inline void clear()
    {
        last = 1; len[tot = 1] = -1; fail[0] = fail[1] = 1; ++cnt;
    }

    inline void add(int t, int c, int n)
    {
        int x = last;
        while(s[t][n - len[x] - 1] != s[t][n]) x = fail[x];
        if(ch[x][c].second != cnt) {
            int v = ++tot, k = fail[x];
            while(s[t][n - len[k] - 1] != s[t][n]) k = fail[k];
            fail[v] = ch[k][c].second == cnt ? ch[k][c].first : 0; len[v] = len[x] + 2; ch[x][c] = make_pair(v, cnt);
        }
        last = ch[x][c].first;
    }   
}t1, t2;

int l, r, que1[maxn], que2[maxn];
inline int bfs(int s)
{
    l = 0; r = 1; que1[r] = que2[r] = s;
    do {
        ++l; int u = que1[l], v = que2[l];
        for(int i = 0; i &lt; 26; ++i)
            if(t1.ch[u][i].second == t1.cnt &amp;&amp; t2.ch[v][i].second == t2.cnt) {
                ++r; que1[r] = t1.ch[u][i].first; que2[r] = t2.ch[v][i].first;
            }
    }while(l &lt; r);
    return r - 1;
}

inline int solve(int x, int y)
{
    if(f.count(make_pair(x, y))) return f[make_pair(x, y)];
    if(s[x].size() &gt; s[y].size()) swap(x, y);
    t1.clear(); t2.clear();
    register int n, i;
    for(n = s[x].size(), i = 0; i &lt; n; ++i) t1.add(x, s[x][i] - 'a', i);
    for(n = s[y].size(), i = 0; i &lt; n; ++i) t2.add(y, s[y][i] - 'a', i);
    return f[make_pair(x, y)] = bfs(0) + bfs(1);
}

int main()
{
    scanf("%d\n", &amp;n);
    for(int i = 1; i &lt;= n; ++i) {
        char c = getchar(); s[i].push_back(0);
        while('a' &lt;= c &amp;&amp; c &lt;= 'z') s[i].push_back(c), c = getchar();
    }
    scanf("%d\n", &amp;q);
    for(int lastans = 0, i = 1, x, y; i &lt;= q; ++i) {
        x = gi() ^ lastans; y = gi() ^ lastans;
        printf("%d\n", lastans = solve(x, y));
    }
    return 0;
}
</code></pre>

<p>我的代码常数有点(非常?)大，下面是laofu的代码

<pre><code class="c++11">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;unordered_set&gt;

#define pb push_back
#define mp make_pair

using namespace std;

template&lt;typename T&gt;inline void upmin(T &amp;x,T y) { y&lt;x?x=y:0; }
template&lt;typename T&gt;inline void upmax(T &amp;x,T y) { x&lt;y?x=y:0; }

typedef unsigned int u32;
typedef long long LL;
typedef unsigned long long ULL;
typedef long double lod;
typedef pair&lt;int,int&gt; PR;
typedef vector&lt;int&gt; VI;

const lod pi=acos(-1);
const int oo=1&lt;&lt;30;
const LL OO=1e18;

const int N=2e5+100;

int gi() {
    int w=0;bool q=1;char c=getchar();
    while ((c&lt;'0'||c&gt;'9') &amp;&amp; c!='-') c=getchar();
    if (c=='-') q=0,c=getchar();
    while (c&gt;='0'&amp;&amp;c &lt;= '9') w=w*10+c-'0',c=getchar();
    return q? w:-w;
}

char str[N];

int son[N][26],fail[N],len[N],tot,last;
bool vis[N];

inline int getfail(int k,int n) {
    while (str[n-len[k]-1]!=str[n]) k=fail[k];
    return k;
}
inline int add(int k,int n) {
    k=getfail(k,n);
    if (!son[k][str[n]-'a']) {
        len[++tot]=len[k]+2;
        fail[tot]=son[getfail(fail[k],n)][str[n]-'a'];
        son[k][str[n]-'a']=tot;
    }
    k=son[k][str[n]-'a'];
    return k;
}
unordered_set&lt;ULL&gt;H[N];
const ULL seed=19260817;
ULL key[26];
map&lt;PR,int&gt;ans;
ULL pre[N],num[N];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("D.in","r",stdin);
    freopen("D.out","w",stdout);
#endif
    int n=gi(),m,i,j,l,a,b;
    for (i=0;i&lt;26;i++) key[i]=rand();
    for (i=num[0]=1;i&lt;=1e5;i++) num[i]=num[i-1]*seed;
    for (i=1;i&lt;=n;i++) {
        len[1]=-1;fail[0]=1;
        last=tot=1;
        scanf("%s",str+1);str[0]='#';
        l=strlen(str+1);
        vis[0]=vis[1]=true;
        for (j=1;j&lt;=l;j++) {
            pre[j]=pre[j-1]*seed+key[str[j]-'a'];
            last=add(last,j);
            if (!vis[last])
                H[i].insert(pre[j]-pre[j-len[last]]*num[len[last]]);
        }
        memset(vis,0,(tot+1));
        memset(len,0,(tot+1)*4);
        memset(fail,0,(tot+1)*4);
        memset(son,0,sizeof(son[0])*(tot+1));
    }
    m=gi();
    last=0;
    while (m--) {
        a=gi()^last,b=gi()^last;
        if (H[a].size()&lt;H[b].size())
            swap(a,b);
        if (ans.find(mp(a,b))==ans.end()) {
            int res=0;
            for (ULL t:H[b])
                res+=H[a].find(t)!=H[a].end();
            ans[mp(a,b)]=res;
        }
        printf("%d\n",last=ans[mp(a,b)]);
    }
    return 0;
}
</code></pre>

<h2>FAQ:</h2>

Q:你怎么来sycstudio.com写文章了？
A:因为csdn广告太多，cnblogs不想配置，自己的博客还没搭好，所以就来蹭博客了。
Q:你的代码常数有多大？
A:AC中我跑得最慢。
Q:数学公式为什么出锅了？
A:我不会用这个编辑器的公式，我也很无奈好心的萝卜帮我改改吧。
My question：为什么我不能添加分类？？数学公式到底要用什么？萝卜不能改改这个东西吗？]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>443</wp:post_id>
		<wp:post_date><![CDATA[2018-01-28 15:48:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-28 07:48:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[51nod1814clarke-and-string%e5%9b%9e%e6%96%87%e6%a0%91-by-dsl]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="51nod"><![CDATA[51nod]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%96%87%e6%a0%91"><![CDATA[回文树]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="category" nicename="51nod"><![CDATA[51nod]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>70</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.63.28.46]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-30 22:19:57]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-30 14:19:57]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[很抱歉，我的是个假算法，真算法大概将于冬令营后更新]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>64</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.3.89]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-28 15:49:26]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-28 07:49:26]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[已经更正所有数学公式并添加分类。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ4012/Luogu3241][HNOI2015]开店（树链剖分，主席树）</title>
		<link>http://sycstudio.com/archives/447</link>
		<pubDate>Sun, 28 Jan 2018 08:05:15 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=447</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

风见幽香有一个好朋友叫八云紫，她们经常一起看星星看月亮从诗词歌赋谈到人生哲学。最近她们灵机一动，打算在幻想乡开一家小店来做生意赚点钱。这样的想法当然非常好啦，但是她们也发现她们面临着一个问题，那就是店开在哪里，面向什么样的人群。很神奇的是，幻想乡的地图是一个树形结构，幻想乡一共有 n个地方，编号为 1 到 n，被 n-1 条带权的边连接起来。每个地方都住着一个妖怪，其中第 i 个地方的妖怪年龄是 x_i。妖怪都是些比较喜欢安静的家伙，所以它们并不希望和很多妖怪相邻。所以这个树所有顶点的度数都小于或等于 3。妖怪和人一样，兴趣点随着年龄的变化自然就会变化，比如我们的 18 岁少女幽香和八云紫就比较喜欢可爱的东西。幽香通过研究发现，基本上妖怪的兴趣只跟年龄有关，所以幽香打算选择一个地方 u（u为编号），然后在 u开一家面向年龄在 L到R 之间（即年龄大于等于 L、小于等于 R）的妖怪的店。也有可能 u这个地方离这些妖怪比较远，于是幽香就想要知道所有年龄在 L 到 R 之间的妖怪，到点 u 的距离的和是多少（妖怪到 u 的距离是该妖怪所在地方到 u 的路径上的边的权之和） ，幽香把这个称为这个开店方案的方便值。幽香她们还没有决定要把店开在哪里，八云紫倒是准备了很多方案，于是幽香想要知道，对于每个方案，方便值是多少呢。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4012">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3241">Luogu</a>

<h3>Tag</h3>

树链剖分，主席树

<h2>解决思路</h2>

先不考虑年龄的限制，考虑其它点&#92;(x&#92;)到一个指定点&#92;(u&#92;)的距离，设&#92;(dis[i]&#92;)表示点&#92;(i&#92;)到根（默认是&#92;(1&#92;)）的距离，那么就是&#92;(\sum dis[u]+dis[x]-2&#42;dis[lca(u,x)]&#92;)，这个式子的前两项都比较好处理，一个直接用&#92;(dis[u]&#92;)乘以点数，另一个可以用前缀和维护，那么关键是&#92;(dis[lca(u,x)]&#92;)这一项怎么求。
这个的求法可以参考<a href="http://sycstudio.com/archives/328">这一道题</a>，类似的，我们用树链剖分+线段树的方法，对点&#92;(x&#92;)到根的路径的边都+1，这样查询&#92;(u&#92;)到根的路径和就可以得到&#92;(dis[lca(u,x)]&#92;)了。
最后把年龄的限制加上去，我们把妖怪按照年龄排序后，以此以树链剖分的形式插入主席树，这样就可以实现对年龄区间的查询。注意要标记永久化。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=150100;
const int maxM=maxN*2;
const int inf=2147483647;

class SegmentData
{
public:
    int ls,rs;
    ll sum;
    ll lazy;//懒标记，注意这里要永久化，不能下放
};

class Edge
{
public:
    ll v,w;
};

class Monster//妖怪
{
public:
    int id,age;
};

bool operator &lt; (Monster A,Monster B)
{
    return A.age&lt;B.age;
}

int n,m,Q,A;
Monster M[maxN];
int edgecnt=0,Head[maxN],Next[maxM];
Edge E[maxM];
int Dis[maxN],Size[maxN],Hson[maxN],Fa[maxN],Top[maxN];
int idcnt=0,Id[maxN];
int nodecnt=0,Root[maxN];
ll Dissum[maxN],Edgesum[maxN];//Dissum是每一个点到根的距离dis的前缀和，而Edgesum则是把一条边下放到它下面的那个点上的前缀和，后面这个是树链剖分要用到的
SegmentData S[maxN*130];

void dfs1(int u,int fa);
void dfs2(int u,int top);//两个树链剖分的dfs
void Build(int &amp;now,int l,int r);
void Modify(int &amp;now,int l,int r,int ql,int qr);//线段树区间修改
ll Query(int n1,int n2,int l,int r,int ql,int qr,ll lazy);//线段树区间查询

int main()
{
    mem(Head,-1);
    scanf("%d%d%d",&amp;n,&amp;Q,&amp;A);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;M[i].age),M[i].id=i;
    sort(&amp;M[1],&amp;M[n+1]);//将妖怪按照年龄排序
    for (int i=1;i&lt;n;i++)//建树
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt]=(Edge){v,w};
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt]=(Edge){u,w};
    }
    Dis[1]=0;//树链剖分初始化
    dfs1(1,0);
    dfs2(1,1);
    for (int i=1;i&lt;=n;i++) Edgesum[i]+=Edgesum[i-1],Dissum[i]=Dissum[i-1]+Dis[M[i].id];//构造前缀和
    Build(Root[0],1,n);//主席树初始化
    for (int i=1;i&lt;=n;i++)
    {
        int u=M[i].id;Root[i]=Root[i-1];
        while (Top[u]!=1) Modify(Root[i],1,n,Id[Top[u]],Id[u]),u=Fa[Top[u]];
        Modify(Root[i],1,n,1,Id[u]);
    }
    ll ans=0;
    while (Q--)//回答询问
    {
        int u,a,b;scanf("%d%d%d",&amp;u,&amp;a,&amp;b);
        int L=(a+ans)%A,R=(b+ans)%A;if (L&gt;R) swap(L,R);
        L=lower_bound(&amp;M[1],&amp;M[n+1],(Monster){0,L})-M;
        R=upper_bound(&amp;M[1],&amp;M[n+1],(Monster){0,R})-M-1;
        ll ret=0,uu=u;
        while (Top[uu]!=1)
            ret=ret+Query(Root[L-1],Root[R],1,n,Id[Top[uu]],Id[uu],0),uu=Fa[Top[uu]];
        ret=ret+Query(Root[L-1],Root[R],1,n,1,Id[uu],0);
        ans=(ll)(R-L+1)*Dis[u]+Dissum[R]-Dissum[L-1]-2*ret;
        printf("%lld\n",ans);
    }
    return 0;
}

void dfs1(int u,int fa)
{
    Size[u]=1;Fa[u]=fa;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (E[i].v!=fa)
        {
            Dis[E[i].v]=Dis[u]+E[i].w;
            dfs1(E[i].v,u);
            Size[u]+=Size[E[i].v];
            if (Size[E[i].v]&gt;Size[Hson[u]]) Hson[u]=E[i].v;
        }
    return;
}

void dfs2(int u,int top)
{
    Id[u]=++idcnt;Top[u]=top;
    Edgesum[idcnt]=Dis[u]-Dis[Fa[u]];
    if (Hson[u]==0) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((E[i].v!=Fa[u])&amp;&amp;(E[i].v!=Hson[u]))
            dfs2(E[i].v,E[i].v);
    return;
}

void Build(int &amp;now,int l,int r)
{
    now=++nodecnt;
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    Build(S[now].ls,l,mid);Build(S[now].rs,mid+1,r);
    return;
}

void Modify(int &amp;now,int l,int r,int ql,int qr)
{
    S[++nodecnt]=S[now];now=nodecnt;
    S[now].sum+=Edgesum[qr]-Edgesum[ql-1];//更新当前区间
    if ((l==ql)&amp;&amp;(r==qr))//若正好是当前区间，则更新懒标记
    {
        S[now].lazy++;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) Modify(S[now].ls,l,mid,ql,qr);
    else if (ql&gt;=mid+1) Modify(S[now].rs,mid+1,r,ql,qr);
    else
    {
        Modify(S[now].ls,l,mid,ql,mid);Modify(S[now].rs,mid+1,r,mid+1,qr);
    }
    return;
}

ll Query(int n1,int n2,int l,int r,int ql,int qr,ll lazy)//注意这里最后一项是一路下来时累加的懒标记
{
    if ((l==ql)&amp;&amp;(r==qr)) return S[n2].sum-S[n1].sum+lazy*(Edgesum[r]-Edgesum[l-1]);
    int mid=(l+r)&gt;&gt;1;
    lazy=lazy+S[n2].lazy-S[n1].lazy;//把这一次的懒标记加上
    if (qr&lt;=mid) return Query(S[n1].ls,S[n2].ls,l,mid,ql,qr,lazy);
    else if (ql&gt;=mid+1) return Query(S[n1].rs,S[n2].rs,mid+1,r,ql,qr,lazy);
    else return Query(S[n1].ls,S[n2].ls,l,mid,ql,mid,lazy)+Query(S[n1].rs,S[n2].rs,mid+1,r,mid+1,qr,lazy);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>447</wp:post_id>
		<wp:post_date><![CDATA[2018-01-28 16:05:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-28 08:05:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4012-luogu3241hnoi2015%e5%bc%80%e5%ba%97%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2038/Luogu1494][2009国家集训队]小Z的袜子（莫队算法，离线）</title>
		<link>http://sycstudio.com/archives/450</link>
		<pubDate>Sun, 28 Jan 2018 12:55:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=450</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……
具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。
你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2120">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1494">Luogu</a>

<h3>Tag</h3>

莫队算法，离线

<h2>解决思路</h2>

早就想学莫队算法了，今天总算认真学了一次。
先来看看这一道题吧。
考虑区间[l,r],记&#92;(Sum[i]&#92;)表示这个范围内颜色&#92;(i&#92;)的个数。那么这个区间内的答案就是&#92;(\frac{\sum Sum[i]&#42;(Sum[i]-1)}{len&#42;(len-1)}&#92;)，其中&#92;(len&#92;)是区间长。化简一下得到&#92;(\frac{\sum Sum[i]^2-\sum Sum[i]}{len&#42;(len-1)}=\frac{\sum Sum[i]^2-len}{len&#42;(len-1)}&#92;)。那么关键就是求&#92;(Sum[i]^2&#92;)。
考虑按长度&#92;(\sqrt{n}&#92;)分块，若左端点在同一个块内，按右端点排序，否则按左端点排序。然后从前往后移动指针即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*((ll)x))

const int maxN=50010;
const int inf=2147483647;

class Data
{
public:
    int l,r,id;
    ll A,B;
};

int n,m,size;
ll Ans=0;
int Belong[maxN],Color[maxN],Sum[maxN];
Data Q[maxN];

bool cmp1(Data A,Data B);
bool cmp2(Data A,Data B);
void Move(ll pos,ll opt);
ll gcd(ll a,ll b);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);size=sqrt(n);//分块大小
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Color[i]),Belong[i]=(i-1)/size+1;//求出每一个点所属的块
    for (int i=1;i&lt;=m;i++) scanf("%d%d",&amp;Q[i].l,&amp;Q[i].r),Q[i].id=i;
    sort(&amp;Q[1],&amp;Q[m+1],cmp1);
    int l=1,r=0;
    for (int i=1;i&lt;=m;i++)
    {
        //移动指针
        while (l&lt;Q[i].l) Move(l,-1),l++;
        while (l&gt;Q[i].l) Move(l-1,1),l--;
        while (r&lt;Q[i].r) Move(r+1,1),r++;
        while (r&gt;Q[i].r) Move(r,-1),r--;
        Q[i].A=(ll)Ans-(ll)(Q[i].r-Q[i].l+1);
        Q[i].B=(ll)(Q[i].r-Q[i].l+1)*(ll)(Q[i].r-Q[i].l);
    }
    sort(&amp;Q[1],&amp;Q[m+1],cmp2);
    for (int i=1;i&lt;=m;i++)
        if (Q[i].A==0) printf("0/1\n");
        else
        {
            ll g=gcd(Q[i].A,Q[i].B);
            printf("%lld/%lld\n",Q[i].A/g,Q[i].B/g);
        }
    return 0;
}

bool cmp1(Data A,Data B)
{
    if (Belong[A.l]==Belong[B.l]) return A.r&lt;B.r;
    else return A.l&lt;B.l;
}

bool cmp2(Data A,Data B)
{
    return A.id&lt;B.id;
}

void Move(ll pos,ll opt)
{
    Ans-=sqr(Sum[Color[pos]]);
    Sum[Color[pos]]+=opt;
    Ans+=sqr(Sum[Color[pos]]);
}

ll gcd(ll a,ll b)
{
    ll tmp;
    while (b) tmp=a,a=b,b=tmp%b;
    return a;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>450</wp:post_id>
		<wp:post_date><![CDATA[2018-01-28 20:55:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-28 12:55:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2038-luogu14942009%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9f%e5%b0%8fz%e7%9a%84%e8%a2%9c%e5%ad%90%ef%bc%88%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95%ef%bc%8c%e7%a6%bb%e7%ba%bf%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="category" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1878/Luogu1972][SDOI2009]HH的项链（莫队算法，离线，分块）</title>
		<link>http://sycstudio.com/archives/453</link>
		<pubDate>Sun, 28 Jan 2018 14:42:45 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=453</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

HH有一串由各种漂亮的贝壳组成的项链。HH相信不同的贝壳会带来好运，所以每次散步 完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH不断地收集新的贝壳，因此他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答。。。因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1878">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1972">Luogu</a>

<h3>Tag</h3>

莫队算法，离线，分块

<h2>解决思路</h2>

类似<a href="">这一题</a>的方法，分块排序后移动端点构造答案

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010;
const int maxM=200100;
const int maxColor=1000100;
const int inf=2147483647;

class Data
{
public:
    int l,r,id;
    int Ans;
};

int n,m,Ans;
int Belong[maxN];
Data Q[maxM];
int Color[maxN],Sum[maxColor];

bool cmp1(Data A,Data B);
bool cmp2(Data A,Data B);
void Move(int pos,int opt);

int main()
{
    scanf("%d",&amp;n);int size=sqrt(n);//这里块的大小取sqrt(n)为最佳
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Color[i]),Belong[i]=(i-1)/size+1;
    scanf("%d",&amp;m);
    for (int i=1;i&lt;=m;i++) scanf("%d%d",&amp;Q[i].l,&amp;Q[i].r),Q[i].id=i;
    sort(&amp;Q[1],&amp;Q[m+1],cmp1);
    int l=1,r=0;
    for (int i=1;i&lt;=m;i++)
    {
        while (l&lt;Q[i].l) Move(l,-1),l++;
        while (l&gt;Q[i].l) Move(l-1,1),l--;
        while (r&lt;Q[i].r) Move(r+1,1),r++;
        while (r&gt;Q[i].r) Move(r,-1),r--;
        Q[i].Ans=Ans;
    }
    sort(&amp;Q[1],&amp;Q[m+1],cmp2);
    for (int i=1;i&lt;=m;i++) printf("%d\n",Q[i].Ans);
    return 0;
}

bool cmp1(Data A,Data B)
{
    if (Belong[A.l]==Belong[B.l]) return A.r&lt;B.r;
    return A.l&lt;B.l;
}


bool cmp2(Data A,Data B)
{
    return A.id&lt;B.id;
}

void Move(int pos,int opt)
{
    if (Sum[Color[pos]]) Ans--;
    Sum[Color[pos]]+=opt;
    if (Sum[Color[pos]]) Ans++;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>453</wp:post_id>
		<wp:post_date><![CDATA[2018-01-28 22:42:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-28 14:42:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1878-luogu1972sdoi2009hh%e7%9a%84%e9%a1%b9%e9%93%be%ef%bc%88%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95%ef%bc%8c%e7%a6%bb%e7%ba%bf%ef%bc%8c%e5%88%86%e5%9d%97%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="category" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>洛谷P4003 无限之环（infinityloop）（网络流，费用流）by hjt</title>
		<link>http://sycstudio.com/archives/457</link>
		<pubDate>Wed, 31 Jan 2018 11:48:09 +0000</pubDate>
		<dc:creator><![CDATA[flashhu]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=457</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="https://www.luogu.org/problemnew/show/4003">洛谷题目传送门</a>
（题目顺便附在了下方）

<h2>思路分析</h2>

<strong>表示这是一道思维神题</strong>。。。。。。

有人第一眼看上去觉得这要跑费用流吗？

然而只要会建图，剩下的就是套模板的事了。

我们这样来理解。对于每个方格上的水管的每一个支管，有且仅有一个其它方格上的支管与其相连，这样就不会漏水了。用网络流知识表述，就是每个支管<strong>容量只能为1</strong>，且全都要<strong>满流</strong>，于是跑<strong>最小费用可行流</strong>。

然而即使产生了最优情况，整个管网也不一定是一整个联通块，而可能被分成若干块。因此，怎样强制使每两个相邻的方格上都产生流量呢？就要把源汇点连到每个格子上。而且，还要对<strong>每个格点染色</strong>，相邻的两个格点，一个连源点，一个连汇点。具体的实现，就要利用格点<strong>行列坐标和的奇偶性</strong>来判断。

而产生的费用呢？当然是旋转造成的啦！真正的思维就体现在这里了。因为旋转还会造成接触点的变化，所以肯定是要<strong>拆点</strong>的，一个方格拆成五个点，上下左右中。。。。。。中间点连上源/汇点，并根据支管情况向四周连<strong>容量1，费用0</strong>的边。四周视作接触点，与对应相邻的另一个接触点连<strong>容量1，费用0</strong>的边。讨论相邻两个方格格因旋转而产生的有费用的连边，实在是太难了。。。。。。猛然发现，所有的情况，其实只需要在内部进行转化就好了。

所有的方格，我们大致分成以下几类进行讨论。

<h4>第一种：射线型</h4>

<img src="http://sycstudio.com/media/Luogu/4003-3.png" alt="" />

这种好办。射线指向上面，那么就让左、下、右接触点直接连接上接触点。左，右连上去，表示只要转90度，所以<strong>费用为1</strong>。下面连上去<strong>费用为2</strong>。

<h4>第二种：直角型</h4>

<img src="http://sycstudio.com/media/Luogu/4003-4.png" alt="" />

这种理解起来就有难度了。如果顺时针转90度，会变成这样

<img src="http://sycstudio.com/media/Luogu/4003-5.png" alt="" />

相当于原来连上接触点的支管连到了下面，那么上与下建一条<strong>容量为1，费用为1</strong>的边。同样的道理，逆时针转90度，左与右建一条<strong>容量为1，费用为1</strong>的边。再来讨论转180度，这时候，会通过已有的边由左、下直接转移到右、上，费用加起来正好是2，所以不用连更多边了。

<h4>第三种：T字型</h4>

<img src="http://sycstudio.com/media/Luogu/4003-6.png" alt="" />

像前面一样讨论，也可以建边。从下向左、右各建一条<strong>容量为1，费用为1</strong>的边，向上建一条<strong>费用为2</strong>的边。这里就留给读者自己思考啦。

<hr />

以上三种情况，每一种都有4个形状，但连边方法都是一样的。
还有直线型，十字型和空的，要么不能转，要么转了没意义，就不用内部建边了。

下面贴代码

<pre><code>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
using namespace std;
#define R register int
#define UP(U) U+turn*sum
#define RI(U) U+((turn+1)&amp;3)*sum
#define DO(U) U+((turn+2)&amp;3)*sum
#define LE(U) U+((turn+3)&amp;3)*sum
#define MD(U) U+(sum&lt;&lt;2)//上面几个用来计算对应点的数组下标，上下左右中。。。
const int INF=2147483647,N=20009,M=200009;
int sum,P=1,S=0,T;//sum方格总数，P建图循环变量，S、T为源汇点
int he[N],ne[M],to[M],f[M],c[M];//f流量，c费用
int q[N],d[N],pre[N];//q队列，d距离，pre记录最短路
bool inq[N];//标记是否在队列中
inline void in(R&amp;z)//快读
{
    register char c=getchar();
    while(c&lt;'-')c=getchar();
    z=c&amp;15;c=getchar();
    while(c&gt;'-')z*=10,z+=c&amp;15,c=getchar();
}
inline void add(R u,R v,R flow,R cost,R tp)//建边，tp表示染色属性
{
    if(tp){tp=u;u=v;v=tp;}//如果是奇数点，所有的边都要反向，要流出去
    to[++P]=v;ne[P]=he[u];he[u]=P;c[P]=cost;f[P]=flow;
    to[++P]=u;ne[P]=he[v];he[v]=P;c[P]=-cost;
}
#define PB(X) q[t]=X;if(++t==N)t=0
#define PF(X) if(--h&lt;0)h=N-1;q[h]=v//手打了一下双向循环队列
inline bool spfa()//模板，加了两种优化
{
    R h=0,t=1,i,u,v,dn,cnt=1,sum=0;
    for(i=S+1;i&lt;=T;++i)d[i]=INF;
    q[0]=S;inq[0]=1;
    while(h!=t)
    {
        u=q[h];
        if(++h==N)h=0;
        if(d[u]*cnt&gt;sum){PB(u);continue;}//LLL优化
        --cnt;sum-=d[u];
        for(i=he[u];i;i=ne[i])
            if(f[i]&amp;&amp;d[v=to[i]]&gt;(dn=d[u]+c[i]))
            {
                if(inq[v])sum-=d[v];
                else
                {
                    inq[v]=1;++cnt;
                    if(d[v]&lt;d[q[h]]){PB(v);}
                    else{PF(v);}//SLF优化
                }
                pre[v]=i;
                sum+=(d[v]=dn);
            }
        inq[u]=0;
    }
    return d[T]!=INF;
}
int main()
{
    R n,m,i,j,k=1,t,shape,turn,totf=0,mf=0,mc=0;//totf总流量，mf最大可行流，mc总费用
    in(n);in(m);
    sum=n*m;T=sum*5+1;
    for(i=0;i&lt;n;++i)
        for(j=0;j&lt;m;++j,++k)
        {
            turn=0;//turn下面会用来翻转，将同类型的水管归类到一起
            t=(i+j)&amp;1;//t是染色属性，只要判断奇偶
            if(t)add(S,MD(k),INF,0,0);
            else add(MD(k),T,INF,0,0);
            if(i)add(DO(k-m),UP(k),1,0,t);
            if(j)add(RI(k-1),LE(k),1,0,t);
            in(shape);
            if(shape&amp;1)add(UP(k),MD(k),1,0,t),++totf;//统计总流量
            if(shape&amp;2)add(RI(k),MD(k),1,0,t),++totf;//因为每个流拆成了两段
            if(shape&amp;4)add(DO(k),MD(k),1,0,t),++totf;//所以最终结果会是实际的两倍
            if(shape&amp;8)add(LE(k),MD(k),1,0,t),++totf;//中点与四周点连边
            switch(shape)
            {
            case 8:++turn;//1000 ←
            case 4:++turn;//0100 ↓
            case 2:++turn;//0010 →
            case 1:       //0001 ↑
                add(RI(k),UP(k),1,1,t);
                add(DO(k),UP(k),1,2,t);
                add(LE(k),UP(k),1,1,t);
                break;//四种形状内部连边情况是一样的，转一下统一处理就方便些了，下面同理
            case 9:++turn; //1001 ┘
            case 12:++turn;//1100 ┐
            case 6:++turn; //0110 ┌
            case 3:        //0011 └
                add(DO(k),UP(k),1,1,t);
                add(LE(k),RI(k),1,1,t);
                break;
            case 13:++turn;//1101 ┤
            case 14:++turn;//1110 ┬
            case 7:++turn; //0111 ├
            case 11:       //1011 ┴
                add(DO(k),LE(k),1,1,t);
                add(DO(k),UP(k),1,2,t);
                add(DO(k),RI(k),1,1,t);
                break;
            }
        }
    while(spfa())
    {
        m=INF;//这里m记下流量
        for(i=T;i!=S;i=to[k^1])
        {
            k=pre[i];
            if(m&gt;f[k])m=f[k];
        }
        mf+=m;
        for(i=T;i!=S;i=to[k^1])
        {
            k=pre[i];
            f[k]-=m;f[k^1]+=m;
            mc+=m*c[k];
        }
    }
    printf("%d",totf==mf&lt;&lt;1?mc:-1);//注意如果没能流满就输-1
    return 0;
}
</code></pre>

<h2>附题目</h2>

<h3>题目描述</h3>

曾经有一款流行的游戏，叫做 Infinity Loop，先来简单的介绍一下这个游戏：
游戏在一个 n ∗ m 的网格状棋盘上进行，其中有些小方格中会有水管，水管可能在格子某些方向的边界的中点有接口，所有水管的粗细都相同，所以如果两个相邻方格的共边界的中点都有接头，那么可以看作这两个接头互相连接。水管有以下 15 种形状：
<img src="http://sycstudio.com/media/Luogu/4003-1.png" alt="4003-1" />

游戏开始时，棋盘中水管可能存在漏水的地方。
形式化地：如果存在某个接头，没有和其它接头相连接，那么它就是一个漏水的地方。
玩家可以进行一种操作：选定一个含有<strong>非直线型水管</strong>的方格，将其中的水管绕方格中心顺时针或逆时针旋转 90 度。
直线型水管是指左图里中间一行的两种水管。
现给出一个初始局面，请问最少进行多少次操作可以使棋盘上不存在漏水的地方。

<h3>输入输出格式</h3>

<h4>输入格式：</h4>

第一行两个正整数 n， m，代表网格的大小。
接下来 n 行每行 m 个数，每个数是 [0,15] 中的一个，你可以将其看作一个 4 位的二进制数，从低到高每一位分别代表初始局面中这个格子上、右、下、左方向上是否有水管接头。
特别地，如果这个数是 0 ，则意味着这个位置没有水管。
比如 3(0011(2)) 代表上和右有接头，也就是一个 L 型;
而 12(1100(2)) 代表下和左有接头，也就是将 L 型旋转 180 度。

<h4>输出格式：</h4>

输出共一行，表示最少操作次数。如果无法达成目标，输出-1.

<h3>输入输出样例</h3>

<h4>输入样例#1：</h4>

<pre><code class="txt">2 3
3 14 12
3 11 12
</code></pre>

<h4>输出样例#1：</h4>

<pre><code class="txt">2
</code></pre>

<h4>输入样例#2：</h4>

<pre><code>3 2
1 8
5 10
2 4
</code></pre>

<h4>输出样例#2：</h4>

<pre><code>-1
</code></pre>

<h4>输入样例#3：</h4>

<pre><code>3 3
9 11 3
13 15 7
12 14 6
</code></pre>

<h4>输出样例#3：</h4>

<pre><code>16
</code></pre>

<h3>说明</h3>

<h4>【样例 1 解释】</h4>

样例 1 棋盘如下
旋转方法很显然，先将左上角虚线方格内的水管顺时针转 90 度
<img src="http://sycstudio.com/media/Luogu/4003-2.png" alt="" />
然后右下角虚线方格内的水管逆时针旋转 90 度，这样就使得水管封闭了

<h4>【样例 2 解释】</h4>

样例 2 为题目描述中的第一张图片，无法达成目标。

<h4>【样例 3 解释】</h4>

样例 3 为题目描述中的第二张图片，将除了中心方格以外的每个方格内的水管都转 180 度即可。

<h3>闲话</h3>

小蒟蒻来SYCstudio.com签下到。。。。。。
对这里清爽的界面风格表示强烈资磁！！！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>457</wp:post_id>
		<wp:post_date><![CDATA[2018-01-31 19:48:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-31 11:48:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b4%9b%e8%b0%b7p4003-%e6%97%a0%e9%99%90%e4%b9%8b%e7%8e%af%ef%bc%88infinityloop%ef%bc%89%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e8%b4%b9%e7%94%a8%e6%b5%81%ef%bc%89-by-flashhu]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="oj"><![CDATA[OJ]]></category>
		<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>71</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.31.193]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-01-31 23:59:45]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-01-31 15:59:45]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[欢迎欢迎。
不过以后发如果有图片的话请联系我在后台把图片加到本站，直接引用外链的话很容易挂掉的，已经人工修复啦！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>73</wp:comment_id>
			<wp:comment_author><![CDATA[flashhu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1258661899@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-01 15:02:24]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-01 07:02:24]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[好的，感谢！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>71</wp:comment_parent>
			<wp:comment_user_id>11</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>79</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[sycstudio@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-04 15:49:30]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-04 07:49:30]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[哼，菜鸡，我一年前就把这题切了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[trash]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
				<wp:meta_value><![CDATA[1517735542]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>[UOJ207]共价大爷游长沙（LCT，随机化）</title>
		<link>http://sycstudio.com/archives/461</link>
		<pubDate>Wed, 31 Jan 2018 15:44:43 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=461</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

火车司机出秦川，跳蚤国王下江南，共价大爷游长沙。每个周末，勤劳的共价大爷都会开车游历长沙市。
长沙市的交通线路可以抽象成为一个 n 个点 n−1 条边的无向图，点编号为 1 到 n，任意两点间均存在恰好一条路径，显然两个点之间最多也只会有一条边相连。有一个包含一些点对 (x,y) 的可重集合S，共价大爷的旅行路线是这样确定的：每次他会选择 S 中的某一对点 (x,y)，并从 x 出发沿着唯一路径到达 y。
小L是共价大爷的脑残粉，为了见到共价大爷的尊容，小L决定守在这张图的某条边上等待共价大爷的到来。为了保证一定能见到他，显然小L必须选择共价大爷一定会经过的边——也就是所有共价大爷可能选择的路径都经过的边。
现在小L想知道，如果他守在某一条边，是否一定能见到共价大爷。
然而长沙市总是不断的施工，也就是说，可能某个时刻某条边会断开，同时这个时刻一定也有某条新边会出现，且任意时刻图都满足任意两点间均存在恰好一条路径的条件。注意断开的边有可能和加入的新边连接着相同的两个端点。共价大爷的兴趣也会不断变化，所以S也会不断加入新点对或者删除原有的点对。当然，小L也有可能在任何时候向你提出守在某一条边是否一定能见到共价大爷的问题。你能回答小L的所有问题吗？

<h3>Http</h3>

<a href="http://uoj.ac/problem/207">UOJ</a>

<h3>Tag</h3>

LCT，随机化

<h2>解决思路</h2>

<a href="http://blog.csdn.net/dsl_hn_2002">dsl</a>推荐的这道题，写了一晚上。两个人差不多想到了前面的大部分部分分，但仍然不知道到底怎么做。一看题解，真乃神题也。
考虑如果一个边&#92;(x,y&#92;)是共价大爷一定会经过的边，那么把&#92;(x&#92;)作为根，&#92;(S&#92;)中的每一对点中必然有一个出现在&#92;(y&#92;)的子树内。
这个怎么统计呢？总不能&#92;(bitset&#92;)吧。这时候看到随机化的标签，没错，可以给每一对点随机一个权值，求子树的异或和，若&#92;(y&#92;)的子树异或和与全局&#92;(S&#92;)中每一对点权值的异或和相等，那么就很有可能是对的。当权值区间取得&#92;(10^9&#92;)差不多就不会错了。
所以本题的思路是，对每一对点随机一个权值，&#92;(LCT&#92;)维护子树异或和，注意是子树，所以这里关系到虚子树的异或和，另外再记一个虚子树异或和即可，只在改变边的虚实关系的时候修改它。
最后需要注意的是，随机种子最好不要用常用的那些，容易被&#92;(hack&#92;)

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=400100;
const int inf=2147483647;

class Splay_Data
{
public:
    int fa,ch[2];
    int rev;
    int key;
    int sum;//异或和（包括实虚子树）
    int vsum;//虚子树异或和
};

int n,m;
Splay_Data S[maxN];
int Stack[maxN];
int scnt=0,S1[maxN],S2[maxN],Sxor[maxN];

bool Isroot(int x);
void PushDown(int x);
void Update(int x);
void Rotate(int x);
void Splay(int x);
void Access(int x);
void Makeroot(int x);
int Findroot(int x);
void Link(int x,int y);
void Cut(int x,int y);
int make(int l,int r);//得到一个l到r区间内的随机数
void Outp();

int main()
{
    srand(141936+141905);
    scanf("%d",&amp;n);scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        Link(u,v);
    }
    int xorsum=0;
    for (int i=1;i&lt;=m;i++)
    {
        int type;
        scanf("%d",&amp;type);
        if (type==1)
        {
            int x,y,u,v;scanf("%d%d%d%d",&amp;x,&amp;y,&amp;u,&amp;v);
            Cut(x,y);Link(u,v);
        }
        if (type==2)
        {
            int x,y;scanf("%d%d",&amp;x,&amp;y);
            scnt++;S1[scnt]=x;S2[scnt]=y;Sxor[scnt]=make(1,1000000000);
            Makeroot(x);Splay(x);S[x].key^=Sxor[scnt];Update(x);
            Makeroot(y);Splay(y);S[y].key^=Sxor[scnt];Update(y);
            xorsum^=Sxor[scnt];
        }
        if (type==3)
        {
            int id;scanf("%d",&amp;id);
            int x=S1[id],y=S2[id];
            Makeroot(x);Splay(x);S[x].key^=Sxor[id];Update(x);
            Makeroot(y);Splay(y);S[y].key^=Sxor[id];Update(y);
            xorsum^=Sxor[id];
        }
        if (type==4)
        {
            int x,y;scanf("%d%d",&amp;x,&amp;y);
            Makeroot(x);Access(y);Splay(y);
            if (S[x].sum==xorsum) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}

bool Isroot(int x)
{
    int fa=S[x].fa;
    if ((S[fa].ch[0]==x)||(S[fa].ch[1]==x)) return 0;
    return 1;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Update(int x)
{
    S[x].sum=S[S[x].ch[0]].sum^S[S[x].ch[1]].sum^S[x].key^S[x].vsum;
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (Isroot(y)==0) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);Update(x);return;
}

void Splay(int x)
{
    int now=x,stacktop=1;Stack[1]=x;
    while (Isroot(now)==0)
    {
        Stack[++stacktop]=S[now].fa;now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (Isroot(x)==0)
    {
        int y=S[x].fa,z=S[y].fa;
        if (Isroot(y)==0)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):Rotate(y);
        Rotate(x);
    }
    Update(x);return;
}

void Access(int x)
{
    int lastx=0;
    while (x)
    {
        Splay(x);S[x].vsum^=S[lastx].sum^S[S[x].ch[1]].sum;
        S[x].ch[1]=lastx;Update(x);
        lastx=x;x=S[x].fa;
    }
    return;
}

void Makeroot(int x)
{
    Access(x);Splay(x);S[x].rev^=1;swap(S[x].ch[0],S[x].ch[1]);
    return;
}

int Findroot(int x)
{
    Access(x);Splay(x);
    while (S[x].ch[0]) x=S[x].ch[0];
    return x;
}

void Link(int x,int y)
{
    Makeroot(x);Makeroot(y);S[y].vsum^=S[x].sum;
    S[x].fa=y;
    return;
}

void Cut(int x,int y)
{
    Makeroot(x);Access(y);Splay(y);
    S[x].fa=S[y].ch[0]=0;Update(x);Update(y);
    return;
}

int make(int l,int r)
{
    double dou=1.0*rand()/RAND_MAX;
    return dou*(r-l+1)+l;
}

void Outp()
{
    printf("id fa ls rs       key        sum        vsum\n");
    for (int i=0;i&lt;=n;i++) printf("%2d%3d%3d%3d%10d%11d%12d\n",i,S[i].fa,S[i].ch[0],S[i].ch[1],S[i].key,S[i].sum,S[i].vsum);
    cout&lt;&lt;endl;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>461</wp:post_id>
		<wp:post_date><![CDATA[2018-01-31 23:44:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-01-31 15:44:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[uoj207%e5%85%b1%e4%bb%b7%e5%a4%a7%e7%88%b7%e6%b8%b8%e9%95%bf%e6%b2%99%ef%bc%88lct%ef%bc%8c%e9%9a%8f%e6%9c%ba%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="post_tag" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="post_tag" nicename="%e9%9a%8f%e6%9c%ba%e5%8c%96"><![CDATA[随机化]]></category>
		<category domain="category" nicename="link-cut-tree"><![CDATA[Link-Cut-Tree]]></category>
		<category domain="category" nicename="uoj"><![CDATA[UOJ]]></category>
		<category domain="category" nicename="%e9%9a%8f%e6%9c%ba%e5%8c%96"><![CDATA[随机化]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>72</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-01 14:16:26]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-01 06:16:26]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这个种子很不错]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ1076/Luogu2743][SCOI2008]奖励关（动态规划，状态压缩）</title>
		<link>http://sycstudio.com/archives/465</link>
		<pubDate>Thu, 01 Feb 2018 07:37:39 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=465</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

你正在玩你最喜欢的电子游戏，并且刚刚进入一个奖励关。在这个奖励关里，系统将依次随机抛出k次宝物，每次你都可以选择吃或者不吃（必须在抛出下一个宝物之前做出选择，且现在决定不吃的宝物以后也不能再吃）。宝物一共有n种，系统每次抛出这n种宝物的概率都相同且相互独立。也就是说，即使前k-1次系统都抛出宝物1（这种情况是有可能出现的，尽管概率非常小），第k次抛出各个宝物的概率依然均为1/n。 获取第i种宝物将得到Pi分，但并不是每种宝物都是可以随意获取的。第i种宝物有一个前提宝物集合Si。只有当Si中所有宝物都至少吃过一次，才能吃第i种宝物（如果系统抛出了一个目前不能吃的宝物，相当于白白的损失了一次机会）。注意，Pi可以是负数，但如果它是很多高分宝物的前提，损失短期利益而吃掉这个负分宝物将获得更大的长期利益。 假设你采取最优策略，平均情况你一共能在奖励关得到多少分值？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1076">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2473">Luogu</a>

<h3>Tag</h3>

动态规划，状态压缩

<h2>解决思路</h2>

一般而言，对于这种状态压缩动态规划都是设&#92;(F[i][S]&#92;)表示当前再第几次，当前选择过的宝物集合为&#92;(S&#92;)。枚举当前这一轮出来的宝物是哪一个，如果这个宝物要求的宝物都已经出现过了，那么就可以从选这个宝物和不选这个宝物两个地方转移过来，否则就只能从不选转移过来。
但是这么转移有问题，关键是不知道最终哪些状态是有用的哪些是没用的。那么我们可以倒着转移，从最后一个向前面转移，那么答案就在&#92;(F[1][0]&#92;)里面。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=15;
const int maxK=120;
const int inf=2147483647;

int n,K;
int P[maxN];
int Rely[maxN];//一个宝物要依赖于哪些宝物
ld F[maxK][(1&lt;&lt;maxN)+10];

int main()
{
    scanf("%d%d",&amp;K,&amp;n);
    for (int i=0;i&lt;n;i++)
    {
        scanf("%d",&amp;P[i]);
        int k;scanf("%d",&amp;k);
        while (k!=0)
        {
            Rely[i]|=1&lt;&lt;(k-1);
            scanf("%d",&amp;k);
        }
    }
    for (int i=K;i&gt;=1;i--)
        for (int j=0;j&lt;(1&lt;&lt;(n+1));j++)
        {
            for (int k=0;k&lt;n;k++)
                if ((j&amp;Rely[k])==Rely[k])
                    F[i][j]+=max(F[i+1][j],F[i+1][j|(1&lt;&lt;k)]+P[k]);
                else F[i][j]+=F[i+1][j];
            F[i][j]=F[i][j]/(ld)n;
        }
    printf("%.6LF\n",F[1][0]);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>465</wp:post_id>
		<wp:post_date><![CDATA[2018-02-01 15:37:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-01 07:37:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1076-luogu2743scoi2008%e5%a5%96%e5%8a%b1%e5%85%b3%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>93</wp:comment_id>
			<wp:comment_author><![CDATA[xzy]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[347605798@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-09 17:25:47]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-09 09:25:47]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主我想了一下午，还是不知道为什么正着DP是错的。。。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>94</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.28.150]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-09 21:15:40]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-09 13:15:40]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这个嘛，主要是在中间转移的时候不知道哪些状态是可以用于转移的。因为有一些宝物的得分是负数，所以中间转移出来有可能是0，这样就不知道哪些是可以转移或不可以转移的了。或许你可以试试再记一个bool数组表示该状态是否是可以用于转移的。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>93</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ3675/Luogu3648][Apio2014]序列分割（动态规划，斜率优化）</title>
		<link>http://sycstudio.com/archives/466</link>
		<pubDate>Thu, 01 Feb 2018 11:16:42 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=466</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小H最近迷上了一个分隔序列的游戏。在这个游戏里，小H需要将一个长度为n的非负整数序列分割成k+1个非空的子序列。为了得到k+1个子序列，小H需要重复k次以下的步骤：
1.小H首先选择一个长度超过1的序列（一开始小H只有一个长度为n的序列——也就是一开始得到的整个序列）；
2.选择一个位置，并通过这个位置将这个序列分割成连续的两个非空的新序列。
每次进行上述步骤之后，小H将会得到一定的分数。这个分数为两个新序列中元素和的乘积。小H希望选择一种最佳的分割方式，使得k轮之后，小H的总得分最大。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3675">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3648">Luogu</a>

<h3>Tag</h3>

动态规划，斜率优化，单调队列

<h2>解决思路</h2>

首先需要知道的是，如果分割的位置是一定的，那么最后的和也是一定的。
比如说&#92;(ab|cd|e&#92;)，先分割前面和先分割后面是一样的，推广一下，分割成&#92;(K&#92;)个块的答案就是把每一个块求和再两两乘起来求和。
那么考虑&#92;(DP&#92;)，设&#92;(F[i][k]&#92;)表示前&#92;(i&#92;)个数分割&#92;(k&#92;)次最大的得分，那么枚举一个小于&#92;(i&#92;)的&#92;(j&#92;)就有
&#92;[F[i][k]=max(F[j][k]+Sum[j]&#42;(Sum[i]-Sum[j])&#92;]
其中&#92;(Sum[i]&#92;)是前&#92;(i&#92;)个数的前缀和。
这样的复杂度是&#92;(O(n^2k)&#92;)的。考虑斜率优化消去一维。
设&#92;(j&#95;1 &lt; j&#95;2&#92;)，并且&#92;(j&#95;2&#92;)的答案更优，那么有
&#92;[F[j&#95;1][k-1]+Sum[j&#95;1]&#42;Sum[i]-Sum[j&#95;1]^2 &lt; F[j&#95;2][k-1]-Sum[j&#95;2]&#42;Sum[i]-Sum[j&#95;2]^2&#92;]
&#92;[F[j&#95;1][k-1]-Sum[j&#95;1]^2-F[j&#95;2][k-1]+Sum[j&#95;2]^2 &lt; Sum[i]&#42;(Sum[j&#95;2]-Sum[j&#95;1])&#92;]
那么这样就可以用单调队列维护了。注意，因为数是非负整数，所以&#92;(Sum[j&#95;2]-Sum[j&#95;1]&#92;)可能是0，不能除过去。
&#92;(Luogu&#92;)需要输出方案，那么在转移的时候再记录一下从哪里分割转移过来即可。

<h2>代码</h2>

&#92;(BZOJ&#92;)

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*((ll)x))
#define Y(k,j1,j2) (F[j1][k&amp;1]-sqr(Sum[j1])-F[j2][k&amp;1]+sqr(Sum[j2]))
#define X(j1,j2) (Sum[j2]-Sum[j1])

const int maxN=100010;
const int maxK=210;
const int inf=2147483647;

int n,K;
ll Arr[maxN],Queue[maxN];
ll Sum[maxN];
ll F[maxN][2];

int main()
{
    scanf("%d%d",&amp;n,&amp;K);
    for (int i=1;i&lt;=n;i++) scanf("%lld",&amp;Arr[i]);
    for (int i=1;i&lt;=n;i++) Sum[i]=Sum[i-1]+(ll)Arr[i];
    for (int j=1;j&lt;=K;j++)
    {
        int now=j&amp;1;
        int l=1,r=0;
        for (int i=1;i&lt;=n;i++)
        {
            while ((l&lt;r)&amp;&amp;(Y(j-1,Queue[l],Queue[l+1])&lt;=Sum[i]*X(Queue[l],Queue[l+1]))) l++;//弹出队首
            F[i][now]=F[Queue[l]][now^1]+Sum[Queue[l]]*Sum[i]-sqr(Sum[Queue[l]]);
            while ((l&lt;r)&amp;&amp;(Y(j-1,Queue[r-1],Queue[r])*X(Queue[r],i)&gt;=Y(j-1,Queue[r],i)*X(Queue[r-1],Queue[r]))) r--;//弹出队尾
            Queue[++r]=i;
        }
    }
    printf("%lld\n",F[n][K&amp;1]);
    return 0;
}
</code></pre>

&#92;(Luogu&#92;)

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*((ll)x))
#define Y(k,j1,j2) (F[j1][k&amp;1]-sqr(Sum[j1])-F[j2][k&amp;1]+sqr(Sum[j2]))
#define X(j1,j2) (Sum[j2]-Sum[j1])

const int maxN=100010;
const int maxK=210;
const int inf=2147483647;

int n,K;
ll Arr[maxN],Queue[maxN];
ll Sum[maxN];
ll F[maxN][2];
int Path[maxN][maxK];//记录方案

int main()
{
    scanf("%d%d",&amp;n,&amp;K);
    for (int i=1;i&lt;=n;i++) scanf("%lld",&amp;Arr[i]);
    for (int i=1;i&lt;=n;i++) Sum[i]=Sum[i-1]+(ll)Arr[i];
    for (int j=1;j&lt;=K;j++)
    {
        int now=j&amp;1;
        int l=1,r=0;
        for (int i=1;i&lt;=n;i++)
        {
            while ((l&lt;r)&amp;&amp;(Y(j-1,Queue[l],Queue[l+1])&lt;=Sum[i]*X(Queue[l],Queue[l+1]))) l++;
            F[i][now]=F[Queue[l]][now^1]+Sum[Queue[l]]*Sum[i]-sqr(Sum[Queue[l]]);
            Path[i][j]=Queue[l];//记录一下是分割哪里转移过来的
            while ((l&lt;r)&amp;&amp;(Y(j-1,Queue[r-1],Queue[r])*X(Queue[r],i)&gt;=Y(j-1,Queue[r],i)*X(Queue[r-1],Queue[r]))) r--;
            Queue[++r]=i;
        }
    }
    printf("%lld\n",F[n][K&amp;1]);
    int now=n;
    for (int i=K;i&gt;=1;i--)//输出分割方案
    {
        printf("%d ",Path[now][i]);
        now=Path[now][i];
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>466</wp:post_id>
		<wp:post_date><![CDATA[2018-02-01 19:16:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-01 11:16:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3675-luogu3648apio2014%e5%ba%8f%e5%88%97%e5%88%86%e5%89%b2%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="post_tag" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96"><![CDATA[斜率优化]]></category>
		<category domain="post_tag" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="category" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="category" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[斜率优化动态规划]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4518/Luogu4072][Sdoi2016]征途（动态规划，斜率优化）</title>
		<link>http://sycstudio.com/archives/467</link>
		<pubDate>Fri, 02 Feb 2018 12:49:33 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=467</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Pine开始了从S地到T地的征途。
从S地到T地的路可以划分成n段，相邻两段路的分界点设有休息站。
Pine计划用m天到达T地。除第m天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。
Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。
帮助Pine求出最小方差是多少。
设方差是v，可以证明，v×m^2是一个整数。为了避免精度误差，输出结果时输出v×m^2。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4518">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P4072">Luogu</a>

<h3>Tag</h3>

动态规划，斜率优化

<h2>解决思路</h2>

先考虑答案是怎么算的，设&#92;(Sum[i]&#92;)表示前&#92;&#40;i&#92;)段路的前缀和。
&#92;[Ans=m^2&#42;\frac{\sum&#95;{i=1}^{m} (x&#95;i- \bar x)^2}{m} &#92;&#92; = m&#42;(\sum&#95;{i=1}^{m} x&#95;{i}^{2}+m&#42; {\bar x}^2-2&#42;\sum&#95;{i=1}^{m} x&#95;i &#42; \bar x) &#92;&#92; =m&#42;\sum&#95;{i=1}^{m} x&#95;{i}^2+Sum[n]^2-2&#42;Sum[i]^2 &#92;&#92; = m&#95;{i=1}^{m} x&#95;{i}^2-Sum[n]^2&#92;]
那么这个式子就只与前面&#92;(X&#95;{i}^2&#92;)这一项有关了，把这一项拿出来单独考虑。
设&#40;F[i][j]&#41;表示前&#92;(j&#92;)个数分成&#92;(i&#92;)组使得上面那个&#92;(X&#95;{i}^2&#92;)和最小，那么有下面的朴素转移方程
&#92;[F[i][j]=min(F[i-1][k]+(Sum[j]-Sum[j])^2)&#92;]
设&#92;(j1 &lt; j2&#92;)，且j2的答案更优，那么有
&#92;[F[i-1][j1]+(Sum[i]-Sum[j1])^2 &gt; F[i-1][j2]+(Sum[i]-Sum[j2])^2 &#92;&#92; F[i-1][j1]+Sum[j1]^2-F[i-1][j2]-Sum[j2]^2 &gt; 2&#42;Sum[i]&#42;(Sum[j1]-Sum[j2])&#92;]
这样就可以斜率优化了。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define sqr(x) (((ll)x)*(x))
#define Y(k,j1,j2) ((ll)F[k][j1]-(ll)F[k][j2]+(ll)sqr(Sum[j1])-(ll)sqr(Sum[j2]))
#define X(j1,j2) ((ll)Sum[j1]-(ll)Sum[j2])

const int maxN=3010;
const int inf=2147483647;

ll n,m;
ll Length[maxN],Sum[maxN],Queue[maxN];
ll F[maxN][maxN];

int main()
{
    scanf("%lld%lld",&amp;n,&amp;m);mem(F,63);F[0][0]=0;
    for (ll i=1;i&lt;=n;i++) scanf("%lld",&amp;Length[i]),Sum[i]=Sum[i-1]+Length[i];
    for (ll i=1;i&lt;=m;i++)
    {
        ll l=0,r=0;
        for (ll j=1;j&lt;=n;j++)
        {
            while ((l&lt;r)&amp;&amp;(Y(i-1,Queue[l],Queue[l+1])&gt;2*Sum[j]*X(Queue[l],Queue[l+1]))) l++;
            F[i][j]=F[i-1][Queue[l]]+sqr(Sum[j]-Sum[Queue[l]]);
            while ((l&lt;r)&amp;&amp;(Y(i-1,Queue[r-1],Queue[r])*X(Queue[r],j)&gt;Y(i-1,Queue[r],j)*X(Queue[r-1],Queue[r]))) r--;
            Queue[++r]=j;
        }
    }
    printf("%lld\n",(ll)m*F[m][n]-sqr(Sum[n]));
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>467</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 20:49:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 12:49:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4518-luogu4072sdoi2016%e5%be%81%e9%80%94%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96"><![CDATA[斜率优化]]></category>
		<category domain="category" nicename="%e6%96%9c%e7%8e%87%e4%bc%98%e5%8c%96%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[斜率优化动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97-%e5%8d%95%e8%b0%83%e6%a0%88"><![CDATA[单调队列/单调栈]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>回文树总结 by dsl</title>
		<link>http://sycstudio.com/archives/470</link>
		<pubDate>Fri, 02 Feb 2018 13:18:11 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=470</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>回文树总结</h1>

<h2>引入</h2>

对于一般的字符串问题，我们拥有处理它们的强大工具——后缀数组，后缀树，后缀自动机。
但对于一类特殊的关于回文串的字符串问题，我们也有一种强大的工具——回文树（由Mikhail Rubinchik发明，在Petrozavodsk Summer Camp 2014上首次提出来）。

<h2>回文树</h2>

安利我的博客<a href="http://blog.csdn.net/dsl_hn_2002/article/details/79175596" title="「学习笔记」回文树/回文自动机(Palindromic Tree)">「学习笔记」回文树/回文自动机(Palindromic Tree)</a>
和一篇论文国家集训队2017论文集《回文树及其应用》——翁文涛。

<h2>例题</h2>

<h3>A.[BZOJ2565]最长双回文串</h3>

<h4>Description</h4>

顺序和逆序读起来完全一样的串叫做回文串。比如acbca是回文串，而abc不是（abc的顺序为“abc”，逆序为“cba”，不相同）。
输入长度为n的串S，求S的最长双回文子串T,即可将T分为两部分X，Y，（|X|,|Y|≥1）且X和Y都是回文串。

2≤|S|≤10^5

<h4>Solution</h4>

正反建两个回文树，同时计算出&#92;(s_{1..i}&#92;)的最长回文后缀和&#92;(s_{i+1..|s|}&#92;)的最长回文前缀。
取和的&#92;(max&#92;)即可。

<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;
char s1[maxn], s2[maxn];
int n, len1[maxn], len2[maxn], ans;

struct Palindromic_Tree 
{
    int ch[maxn][26], tot, len[maxn], fail[maxn], last;

    Palindromic_Tree() 
    {
        len[tot = 1] = -1; fail[0] = fail[1] = 1;
    }

    int insert(int c, int n, char* s)
    {
        int x = last;
        while(s[n - len[x] - 1] != s[n]) x = fail[x];
        if(!ch[x][c]) {
            int v = ++tot, k = fail[x];
            while(s[n - len[k] - 1] != s[n]) k = fail[k];
            fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v;
        }
        last = ch[x][c];
        return len[ch[x][c]];
    }
}t1, t2;

int main()
{
    scanf("%s", s1 + 1);
    n = strlen(s1 + 1);
    for(int i = 1; i &lt;= n; ++i) s2[i] = s1[n - i + 1];

    for(int i = 1; i &lt;= n; ++i) 
        len1[i] = t1.insert(s1[i] - 'a', i, s1), len2[n - i + 1] = t2.insert(s2[i] - 'a', i, s2);
    for(int i = 1; i &lt; n; ++i) 
        ans = max(ans, len1[i] + len2[i + 1]);

    printf("%d\n", ans);

    return 0;
}
</code></pre>

<h3>B.[SHOI2011]双倍回文</h3>

<h3>Description</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2342" title="题面">题面</a>

<h3>Solution</h3>

直接构造出回文树,然后在&#92;(fail&#92;)树上dfs。一个回文串是双倍回文串的条件是长度是4且父亲中有长度为其一半的回文串即可。

<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 500005;
struct edge {
    int to, next;
}e[maxn * 2];
int n, h[maxn], cnt;
char s[maxn];

int ch[maxn][26], len[maxn], tot, fail[maxn], last, ans;

inline void link(int u, int v)
{
    e[++cnt] = (edge) {v, h[u]}; h[u] = cnt;
}

void add(int c, int n)
{
    int x = last;
    while(s[n - len[x] - 1] != s[n]) x = fail[x];
    if(!ch[x][c]) {
        int v = ++tot, k = fail[x];
        while(s[n - len[k] - 1] != s[n]) k = fail[k];
        fail[v] = ch[k][c]; ch[x][c] = v; len[v] = len[x] + 2;
        link(fail[v], v);
    }
    last = ch[x][c];
}

int vis[maxn];
void dfs(int u)
{
    if(len[u] % 4 == 0 &amp;&amp; vis[len[u] / 2]) ans = max(ans, len[u]);
    ++vis[len[u]];
    for(int i = h[u]; i; i = e[i].next) dfs(e[i].to);
    --vis[len[u]];
}

int main()
{
    scanf("%d", &amp;n);
    scanf("%s", s + 1);

    len[tot = 1] = -1; fail[0] = fail[1] = 1; link(1, 0);
    for(int i = 1; i &lt;= n; ++i)
        add(s[i] - 'a', i);

    dfs(1);
    printf("%d\n", ans);

    return 0;
}

</code></pre>

<h3>C.<a href="http://sycstudio.com/archives/443" title="[51nod]Clarke and string">[51nod]Clarke and string</a></h3>

<h3>D.[省队集训2013day7T1]str</h3>

<h4>Description</h4>

求一个串第&#92;(k&#92;)小的回文子串。

字符串比较方式如下(与一般的比较方式不完全相同)

<pre><code class="cpp">int cmp(string a, string b)
{
    if (len(a) != len(b))
        return len(a) &lt; len(b);
    else
    {
        int i;
        for (i = 0; i &lt; len(a); ++i)
            if(a[i] != b[i])
                return a[i] &lt; b[i];
        return 0;
    }
}
</code></pre>

&#92;(|s|\leqslant 10^5&#92;)

<h4>Solution</h4>

方法1:

字符串比较的方式为先比较长度，然后比较字符。所以可以直接在回文树上bfs。

<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;
int n, k; long long p;
char s[maxn];

int ch[maxn][26], len[maxn], fail[maxn], v[maxn], last, tot;
pair&lt;int, int&gt; fa[maxn];

inline void add(int c, int n)
{
    int x = last;   
    while(s[n - len[x] - 1] != s[n]) x = fail[x];
    if(!ch[x][c]) {
        int v = ++tot, k = fail[x];
        while(s[n - len[k] - 1] != s[n]) k = fail[k];
        fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v; fa[v] = make_pair(c, x);
    }
    ++v[last = ch[x][c]];
}

inline void print(int c, int u, int k)
{
    int cnt = 0; s[++cnt] = c + 'a';
    while(fa[u].second &gt; 1) {
        u = fa[u].second;
        s[++cnt] = fa[u].first + 'a';
    }   
    for(int i = 1; i &lt;= cnt; ++i) putchar(s[i]); 
    for(int i = cnt - k; i &gt;= 1; --i) putchar(s[i]);
}

int que1[maxn], que2[maxn];
inline void bfs()
{
    register int l1 = 0, l2 = 0, r1 = 1, r2 = 1, u;
    que1[r1] = 1; que2[r2] = 0;
    do {
        if(l1 &lt; r1) {
            int l = l1 + 1, r = r1;
            for(int j = 0; j &lt; 26; ++j)
                for(int i = l; i &lt;= r; ++i)
                    if(ch[u = que1[i]][j]) {
                        if(k &lt;= 1) {print(j, ch[u][j], 1); return ;}
                        --k; que1[++r1] = ch[u][j];
                    }
            l1 = r;
        }
        if(l2 &lt; r2) {
            int l = l2 + 1, r = r2;
            for(int j = 0; j &lt; 26; ++j)
                for(int i = l; i &lt;= r; ++i)
                    if(ch[u = que2[i]][j]) {
                        if(k &lt;= 1) {print(j, ch[u][j], 0); return ;}
                        --k; que2[++r2] = ch[u][j];
                    }
            l2 = r;
        }
    }while(k);
}

int main()
{
    freopen("str.in", "r", stdin);
    freopen("str.out", "w", stdout);

    scanf("%d%lld\n%s", &amp;n, &amp;p, s + 1); 
    len[tot = 1] = -1; fail[0] = fail[1] = 1;
    for(int i = 1; i &lt;= n; ++i) add(s[i] - 'a', i);
    printf("%d\n", tot - 1);
    k = p % (tot - 1) + 1;
    bfs();

    return 0;
}
</code></pre>

方法2(std):
<img src="http://sycstudio.com/wp-content/uploads/2018/02/08b351bf1f0b5abf6c96dca75fb9c6d1.png" alt="Markdown" />

<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;ctime&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;bitset&gt;
#include&lt;functional&gt;
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define REP(i,l,r) for((i)=(l);(i)&lt;=(r);++(i))
#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))
using namespace std;

typedef long long LL;
typedef double ld;

const int MAX=500000+10;
const int INF=1000000000;
const int Alpha=28;

int n;
LL k;
char str[MAX],a[MAX];

struct Node
{
    Node* ch[Alpha];
    Node* ne[Alpha];
    Node* p;
    int len;
    int maxs;
    int place;
    int help_for_dfs;
    Node()
    {
        memset(ch,0,sizeof ch);
        memset(ne,0,sizeof ne);
        p=0;
        len=0;
        maxs=0;
        help_for_dfs=-1;
    }
}tree[MAX*2],*Root,*place[MAX];
int cnt;

Node* add(Node* v,int id,int len)
{
    Node* u=tree+cnt++;
    u-&gt;len=len;
    for(;v &amp;&amp; !v-&gt;ch[id];v=v-&gt;p)
        v-&gt;ch[id]=u;
    if(!v)
        u-&gt;p=Root;
    else
    {
        Node* bro=v-&gt;ch[id];
        if(v-&gt;len+1==bro-&gt;len)
            u-&gt;p=bro;
        else
        {
            Node* nv=tree+cnt++;
            *nv=*bro;
            nv-&gt;len=v-&gt;len+1;
            u-&gt;p=nv;
            bro-&gt;p=nv;
            for(;v &amp;&amp; v-&gt;ch[id]==bro;v=v-&gt;p)
                v-&gt;ch[id]=nv;
        }
    }
    return u;
}

int maxs[MAX];
int num[MAX];

int cmp(int a,int b)
{
    return tree[a].len&gt;tree[b].len;
}

int toAdd[MAX];
LL ans[MAX];

int pa[MAX],num_pa;

void dfs(Node* S)
{
    Node* u=S;
    while(1)
    {
        int&amp; i=u-&gt;help_for_dfs;
        if(u-&gt;place==u-&gt;len &amp;&amp; u-&gt;len%2==0 &amp;&amp; i==-1)
            pa[++num_pa]=u-&gt;place;
        for(++i;i&lt;Alpha;++i)
            if(u-&gt;ne[i])
            {
                pa[++num_pa]=-u-&gt;len;
                u=u-&gt;ne[i];
                break;
            }
        if(i==Alpha)
        {
            if(u==S)
                break;
            u=u-&gt;p;
        }
    }
}

int getL(int a,int b)
{
    int dif=b/2-(a-1)/2;
    if(str[b]=='z'+1)//a到b中有多少奇数 b中的奇数个数是(b+1)/2
        return dif*2;
    else return dif*2-1;
}

int main()
{
    freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
    int i;
    scanf("%d",&amp;n);
    cin&gt;&gt;k;
    scanf("%s",a+1);
    int tmp=0;
    str[++tmp]='z'+1;
    REP(i,1,n)
    {
        str[++tmp]=a[i];
        str[++tmp]='z'+1;
    }
    str[tmp+1]='z'+2;
    n=tmp;
    Node* last=place[0]=Root=tree+cnt++;
    REP(i,1,n)
    {
        place[i]=last=add(last,str[i]-'a',i);
        place[i]-&gt;place=i;
    }
    int mm=1;
    maxs[1]=0;
    REP(i,1,n)
    {
        if(i&lt;=mm+maxs[mm])
            maxs[i]=min( maxs[2*mm-i] , mm+maxs[mm]-i ) ;
        for(;str[i-maxs[i]-1]==str[i+maxs[i]+1];++maxs[i])
            ;
        if(i+maxs[i]&gt;mm+maxs[mm])
            mm=i;
        place[i]-&gt;maxs=maxs[i];
    }
    REP2(i,0,cnt)
        num[i]=i;
    sort(num,num+cnt,cmp);
    REP2(i,0,cnt)
    {
        Node* u=tree+num[i];
        if(u-&gt;p)
        {
            u-&gt;p-&gt;maxs=max(u-&gt;p-&gt;maxs,u-&gt;maxs);
            if(!u-&gt;p-&gt;place)
                u-&gt;p-&gt;place=u-&gt;place;
            u-&gt;p-&gt;ne[ str[ u-&gt;place-u-&gt;p-&gt;len ] - 'a']=u;
            int l=u-&gt;p-&gt;len+1;
            int r=min(u-&gt;len,u-&gt;maxs+1);
            l=getL(u-&gt;place-l+1,u-&gt;place);
            r=getL(u-&gt;place-r+1,u-&gt;place);
            if(r&gt;=l)
            {
                toAdd[l]++;
                toAdd[r+2]--;
            }
        }
    }
    LL sum=0;
    LL now=0,all=1;
    for(i=1;i&lt;=n;i+=2)
    {
        sum+=toAdd[i];
        ans[i]=sum;
        all+=ans[i];
    }
    sum=0;
    for(i=0;i&lt;=n;i+=2)
    {
        sum+=toAdd[i];
        ans[i]=sum;
        all+=ans[i];
    }
    all-=2;
    k=k%all+1;
    cout&lt;&lt;all&lt;&lt;endl;
    now=0;
    int anslen=0;
    REP(i,1,n)
    {
        if(now&lt;k &amp;&amp; now+ans[i]&gt;=k)
        {
            k-=now;
            anslen=i;
            break;
        }
        now+=ans[i];
    }
    dfs(Root);
    int height=0;
    REP(i,1,num_pa)
    {
        int c=pa[i];
        if(c&lt;=0)
        {
            height=min(height,(-c+1)/2);
            continue;
        }
        int u=pa[i];
        if(u-anslen+1&gt;=1 &amp;&amp; maxs[u-anslen+1]+1&gt;=anslen &amp;&amp; height&lt;anslen)//这儿目测还有问题。。。
        {
            --k;
            if(!k)
            {
                for(int j=u;anslen;j-=2,anslen--)
                    cout&lt;&lt;str[j];
                cout&lt;&lt;endl;
                break;
            }
            height=INF;
        }
    }
    return 0;
}
</code></pre>

从这道题我们可以看出回文树在处理回文串的优越性。

<h3>E.[省队集训2015day1T1]字符串合成</h3>

<h4>Description</h4>

给定四种对字符串 S 的操作:
(1) push_back( P ):在 S 后连接一个字符串 P,即 S = S + P,代价为| P |;
(2) push_front( P ):在 S 前连接一个字符串 P,即 S = P + S,代价为| P |;
(3) symmetry_back( ):将 S 翻转后连接在 S 之后,即 S = S + rev(S),代价为 1;
(4) symmetry_front( ):将 S 翻转后连接在 S 之前,即 S = rev(S) + S,代价为 1;
给定一个目标串 S,要求你通过上述四种操作,用最少的代价合成出目标串。初始只有一个空串。

<h4>Solution</h4>

观察可以发现三个性质：

<ol>
<li>每次合成最终的串的方法一定是先合成一个回文串，然后两边的字符暴力添加。</li>
<li>一个偶数长度的回文串的合成方法一定是先合成一半的串，然后翻转。</li>
<li>合成一个偶数长度的回文串的左半边与右半边的步数相同。</li>
</ol>

考虑在回文树上DP，设&#92;(f(s)&#92;)为在合成回文串&#92;(s&#92;)的最小代价。
同时在回文树求出&#92;(fail_s&#92;)(&#92;(s&#92;)的最长回文前缀(后缀))，&#92;(fa_s&#92;)(&#92;(s&#92;)在回文树上的父亲，&#92;(half_s&#92;)(不超过s长度一半的最长回文前缀)。

<ul>
<li>如果&#92;(s&#92;)为奇数长度的回文串，则&#92;(f_s=min(f_{fa_s}+2,f_{fail_s}+|s|-|fail_s|&#92;)。因为&#92;(s&#92;)长度为奇数，所以不可能由翻转得出，只可能由首尾加字符得来。</li>
<li>如果&#92;(s&#92;)为偶数唱的回文串，则合成&#92;(s&#92;)的最后一步一定是翻转。而&#92;(s&#92;)的一半却不一定是回文串。所以考虑把转移合并。若翻转前在串首增加了字符，则&#92;(f_s=f_{fa_s}+1&#92;)表示&#92;(s_fa&#92;)在最后一步翻转前在首部增加了字符。若翻转加倍前未在尾部增加了字符则&#92;(f_s=f_{s_{half}}+\frac{s_{len}}{2}&#92;)表示先合成&#92;(s_{half}&#92;)然后在尾部添加字符合成&#92;(s&#92;)的一半。最后翻转加倍。</li>
</ul>

<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 100005;
int m, ans;
char s[maxn];

int ch[maxn][26], fail[maxn], len[maxn], half[maxn], fa[maxn], tot, last;
int f[maxn];

void add(int c, int n)
{
    int x = last;
    while(s[n - len[x] - 1] != s[n]) x = fail[x];
    if(!ch[x][c]) {
        int v = ++tot, k = fail[x];
        memset(ch[v], 0, sizeof(ch[v]));
        while(s[n - len[k] - 1] != s[n]) k = fail[k];
        fail[v] = ch[k][c]; len[v] = len[x] + 2; fa[v] = x;
        if((len[k = half[x]] + 2) * 2 &gt; len[v]) k = fail[k];
        while(s[n - len[k] - 1] != s[n]) k = fail[k]; if(ch[k][c]) k = ch[k][c];
        half[v] = k; ch[x][c] = v; 
        if(len[v] &amp; 1) f[v] = min(f[fa[v]] + 2, f[fail[v]] + len[v] - len[fail[v]]);
        else if(fa[v]) f[v] = min(f[fa[v]] + 1, f[half[v]] + len[v] / 2 - len[half[v]] + 1);
        else f[v] = 2;
        ans = min(ans, m - len[v] + f[v]); 
    }
    last = ch[x][c];
}

int main()
{
    freopen("synthesis.in", "r", stdin);
    freopen("synthesis.out", "w", stdout);

    int T; scanf("%d", &amp;T);
    while(T--) {
        scanf("%s\n", s + 1); ans = m = strlen(s + 1);
        memset(ch[0], 0, sizeof(ch[0])); memset(ch[1], 0, sizeof(ch[1]));
        len[tot = 1] = -1; fail[0] = fail[1] = half[0] = half[1] = 1; last = 1;
        for(int i = 1; i &lt;= m; ++i) add(s[i] - 'a', i);
        printf("%d\n", ans);
    }

    return 0;
}
</code></pre>

<h3>F.[省队集训2015day1T1]月宫的符卡序列</h3>

<h4>Description</h4>

<img src="http://sycstudio.com/wp-content/uploads/2018/02/6b76c88e1cb3223fed264246defc621f.png" alt="题意" title="题意" />

<h4>Solution</h4>

这道题我的做法是用Manacher建出一个类似回文树的东西。
对这个串进行Manacher的预处理，使得每个回文串的长度都为奇数。
现在考虑建出这棵回文树(明显，所有回文串都位于odd节点下方)
对于每个位置&#92;(i&#92;)，它对每个以它为中心的回文串贡献为&#92;(i&#92;)。设其最远的回文串延伸了&#92;(f_i&#92;),则相当于给串&#92;(s_{[i-f_i+1,i+f_i-1]}&#92;)到根异或上了i。
现在的问题是怎么建出这棵回文树：
在Manacher的算法过程中，设当前中心为i，当前节点为x，如果&#92;(s_{i-f_i}=s_{i+f_i}&#92;)，那么&#92;(x'=x→s_{i+f_i}&#92;),这样算法结束，这棵树也就建出来了。
至于每个位置在串中的位置的求法，可以自己yy或者看下代码。

<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 2000005;
int n;
char s[maxn];

int f[maxn], pos[maxn], ch[maxn][27], g[maxn][22], val[maxn], tot;

inline int getfa(int u, int dis)
{
    for(int i = 0; i &lt;= 20; ++i)
        if(dis &amp; (1 &lt;&lt; i)) u = g[u][i];
    return u;
}

inline int next(int u, int c)
{
    if(ch[u][c]) return ch[u][c];
    ch[u][c] = ++tot;
    memset(ch[tot], 0, sizeof(ch[tot]));
    val[tot] = 0; g[tot][0] = u;
    for(int i = 1; (1 &lt;&lt; i) &lt;= n; ++i)
        g[tot][i] = g[g[tot][i - 1]][i - 1];
    return tot;
}

int main()
{
    freopen("A.in", "r", stdin);
    freopen("A.out", "w", stdout);

    int T; scanf("%d\n", &amp;T);
    memset(s, -1, sizeof(s));
    while(T--) {
        s[n = 0] = 'a' + 26; char c = getchar();
        while('a' &lt;= c &amp;&amp; c &lt;= 'z') {
            s[++n] = c; s[++n] = 'a' + 26; c = getchar();
        }
        tot = 1; val[1] = 0;memset(ch[1], 0, sizeof(ch[1]));
        for(int i = 0, k = 0; i &lt;= n; ++i) {
            if(i == 68)
                i = 68;
            if(k + f[k] - 1 &gt;= i) {
                if(i + f[k - (i - k)] &lt;= k + f[k]) f[i] = f[k - (i - k)], pos[i] = pos[k - (i - k)];
                else f[i] = f[k] + k - i, pos[i] = getfa(pos[k - (i - k)], f[k - (i - k)] - f[i]);
            }else f[i] = 1, pos[i] = next(1, s[i] - 'a');
            while(i - f[i] &gt;= 0 &amp;&amp; i + f[i] &lt;= n &amp;&amp; s[i - f[i]] == s[i + f[i]]) 
                pos[i] = next(pos[i], s[i - f[i]] - 'a'), ++f[i];
            val[pos[i]] ^= (i - 1) / 2;
            if(i + f[i] &gt; k + f[k]) k = i;
        }
        int ans = 0;
        for(int i = tot; i &gt;= 2; --i) {
            if(i != ch[1][26]) ans = max(ans, val[i]);
            val[g[i][0]] ^= val[i];
        }
        printf("%d\n", ans);
    }
    return 0;
}
</code></pre>

这个是laofu的做法：
先建出回文树并求出&#92;(s_{1..i}&#92;)的最长回文后缀，然后跑Manacher，在Manacher的过程中求出f数组，然后暴跳&#92;(i+f_i&#92;)最长回文后缀的fail，直到len等于f_i为止。

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;
#define inf 2147483647
#define fre(z) freopen(z".in","r",stdin),freopen(z".out","w",stdout)
#define my int
#define d "%d"
#define md double
using namespace std;
const int N=2e6+100;
int getint();
int n,n2;
char s[N];
int next[N][26],fail[N],len[N],sum[N],ans,tot,last,id[N],p[N];
inline int get_fail(int p,int n) {
    while (s[n]!=s[n-len[p]-1]) p=fail[p];
    return p;
}
inline void add(int c,int n) {
    int p=get_fail(last,n);
    if (!next[p][c]) {
        len[++tot]=len[p]+2;memset(next[tot],0,sizeof(next[tot]));sum[tot]=0;
        fail[tot]=next[get_fail(fail[p],n)][c];
        next[p][c]=tot;
    }
    last=next[p][c];
}
inline void work() {
    scanf("%s",s+1);n=strlen(s+1);ans=0;memset(next,0,sizeof(next[0])&lt;&lt;1);
    last=tot=1;len[0]=0,len[1]=-1,fail[0]=fail[1]=1;
    for (int i=1;i&lt;=n;i++)
        add(s[i]-'a',i),p[i]=last;
    for (int i=n;i;i--) s[i&lt;&lt;1]=s[i],s[(i&lt;&lt;1)-1]='*';s[0]='^';n2=n&lt;&lt;1;s[n2+1]='*';s[n2+2]='&amp;';
    for (int i=1,mx=0,cn;i&lt;=n2;i++) {
        id[i]=mx&gt;i?min(mx-i,id[(cn&lt;&lt;1)-i]):0;
        while (s[i-id[i]-1]==s[i+id[i]+1]) id[i]++;
        int &amp;j=p[(i+id[i])&gt;&gt;1];
        while(len[j]&gt;id[i]) j=fail[j];
        sum[j]^=(i&gt;&gt;1)-1;
        if (i+id[i]&gt;mx) mx=i+id[i],cn=i;
    }
    for (int i=tot;i!=1;i--) {
        for (int j=0;j&lt;26;j++) if (next[i][j]) sum[i]^=sum[next[i][j]];
        ans=max(ans,sum[i]);
    }
    printf("%d\n",ans);
}
int main()
{
    fre("A");
    for (int T=getint();T--;)
        work();
      return 0;
}
int getint()
{
      int w=0;
    bool q=1;
    char c=getchar();
    while ((c&lt;'0'||c&gt;'9') &amp;&amp; c!='-') c=getchar();
    if (c=='-') q=0,c=getchar();
      while (c&gt;='0'&amp;&amp;c &lt;= '9') w=w*10+c-'0',c=getchar();
    return q? w:-w;
}

</code></pre>

<h3>G.[省队集训2017day3T2]回文串</h3>

<h4>Description</h4>

<img src="http://sycstudio.com/wp-content/uploads/2018/02/9b271accda790e22924ce99052694f28.png" alt="Description" title="Description" />

<h4>Solution</h4>

可以看出题目所求的其实是&#92;(fail&#92;)树的一段路径和。
考虑离线建出最终的回文树，然后在求出每个位置最终的最长回文前缀与后缀。
每次询问实际上的值是&#92;(len_i*right_i&#92;)，其中right是字符串的出现次数。用动态树维护即可。
值得注意的是lca有时候不会被统计进答案，所以要特判。

感觉讲的好不清楚啊，不懂来问我吧，QAQ...

<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long lint;
const int maxn = 300005;
int n, m;

inline int gi()
{
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

//动态树
struct link_cut_tree
{

    int ch[maxn][2], f[maxn], rev[maxn], val[maxn];
    lint sumv[maxn], suml[maxn], sum[maxn], addv[maxn];

    #define isroot(x) (ch[f[x]][0] != x &amp;&amp; ch[f[x]][1] != x)
    #define get(x) (ch[f[x]][1] == x)

    inline void update(int x)
    {
        suml[x] = suml[ch[x][0]] + suml[ch[x][1]] + val[x];
        sumv[x] = sumv[ch[x][0]] + sumv[ch[x][1]] + sum[x] + addv[x] * suml[x];
    }

    inline void rotate(int x)
    {
        int fa = f[x], gfa = f[fa], k = get(x);
        if(!isroot(fa)) ch[gfa][get(fa)] = x;
        ch[fa][k] = ch[x][k ^ 1]; f[ch[x][k ^ 1]] = fa;
        ch[x][k ^ 1] = fa; f[fa] = x;
        f[x] = gfa;
        update(fa); update(x);
    }

    inline void pushdown(int x)
    {
        if(addv[x]) {
            if(ch[x][0]) addv[ch[x][0]] += addv[x], sumv[ch[x][0]] += addv[x] * suml[ch[x][0]];
            if(ch[x][1]) addv[ch[x][1]] += addv[x], sumv[ch[x][1]] += addv[x] * suml[ch[x][1]];
            sum[x] += addv[x] * val[x];
            addv[x] = 0;
        }
        if(rev[x]) {
            rev[x] = 0;
            if(ch[x][0]) rev[ch[x][0]] ^= 1;
            if(ch[x][1]) rev[ch[x][1]] ^= 1;
            swap(ch[x][0], ch[x][1]);
        }
    }

    int stk[maxn], top;
    inline void splay(int x)
    {
        stk[top = 1] = x;
        while(!isroot(x)) stk[++top] = x = f[x];
        while(top) pushdown(stk[top--]);
        x = stk[1];
        while(!isroot(x)) {
            int fa = f[x];
            if(!isroot(fa))
                get(x) ^ get(fa) ? rotate(x) : rotate(fa);
            rotate(x);
        }
    }

    inline void access(int x)
    {
        for(int y = 0; x; y = x, x = f[x])
            splay(x), ch[x][1] = y, update(x);
    }

    inline void make_root(int x) {access(x); splay(x); rev[x] ^= 1;}

    inline void add(int u, int fa, int w) //添加新节点
    {
        if(!fa) fa = 1;
        val[u] = w; f[u] = fa;
        update(u);
    }

    inline lint query(int u, int v) //询问u,v之间的路径和
    {
        if(!u) u = 1; if(!v) v = 1;
        make_root(u); access(v); splay(v);
        return sumv[v];
    }

    inline void addright(int u) //u的right+1
    {
        make_root(1); access(u); splay(u);
        ++addv[u]; update(u);
    }

}lct;

//回文树
struct palindromic_tree
{

    int l, r, tot, s[maxn], ch[maxn][26], len[maxn], fail[maxn], pre[maxn], suf[maxn];
    int dep[maxn], f[maxn][20];

    inline void prepare() 
    {
        l = n; r = l - 1;
        len[tot = 1] = -1; fail[0] = fail[1] = 1;
        memset(s, -1, sizeof(s));
        pre[l] = pre[r] = suf[l] = suf[r] = 1;
    }

    inline void get_fa(int v)
    {
        f[v][0] = fail[v]; dep[v] = dep[fail[v]] + 1;
        for(int i = 1; i &lt;= 18; ++i) f[v][i] = f[f[v][i - 1]][i - 1];
        lct.add(v, fail[v], len[v]);
    }

    inline int addl(int c)
    {
        s[--l] = c;
        int x = pre[l + 1]; while(s[l + len[x] + 1] != s[l]) x = fail[x];
        if(!ch[x][c]) {
            int v = ++tot, k = fail[x];
            while(s[l + len[k] + 1] != s[l]) k = fail[k];
            fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v;
            get_fa(v);
        }
        return pre[l] = suf[l + len[ch[x][c]] - 1] = ch[x][c];
    }

    inline int addr(int c)
    {
        s[++r] = c;
        int x = suf[r - 1]; while(s[r - len[x] - 1] != s[r]) x = fail[x];
        if(!ch[x][c]) {
            int v = ++tot, k = fail[x];
            while(s[r - len[k] - 1] != s[r]) k = fail[k];
            fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v;
            get_fa(v);
        }
        return suf[r] = pre[r - len[ch[x][c]] + 1] = ch[x][c];
    }

    inline void rebuild()
    {
        for(int i = l; i &lt;= r; ++i) { //addr
            int x = suf[i - 1];
            while(s[i - len[x] - 1] != s[i]) x = fail[x];
            suf[i] = ch[x][s[i]];
        }
        for(int i = r; i &gt;= l; --i) { //addl
            int x = pre[i + 1];
            while(s[i + len[x] + 1] != s[i]) x = fail[x];
            pre[i] = ch[x][s[i]];
        }
    }

    inline int lca(int u, int v)
    {
        if(dep[u] &gt; dep[v]) swap(u, v);
        int p = dep[v] - dep[u];
        for(int i = 0; i &lt;= 18; ++i)
            if(p &amp; (1 &lt;&lt; i)) v = f[v][i];
        if(u == v) return u;
        for(int i = 18; i &gt;= 0; --i)
            if(f[u][i] != f[v][i]) {
                u = f[u][i]; v = f[v][i];
            }
        return f[u][0];
    }

    inline int jump(int u, int Maxlen)
    {
        for(int i = 18; i &gt;= 0; --i) if(len[f[u][i]] &gt;= Maxlen) u = f[u][i];
        return len[u] &lt;= Maxlen ? u : f[u][0];
    }

    inline lint calcl(int l1, int r1, int l2, int r2)
    {
        int u = suf[r1], v = suf[r2];
        int lenx = r1 - l1 + 1, leny = r2 - l2 + 1;
        u = jump(u, lenx); v = jump(v, leny);
        lint ret = lct.query(u, v);
        int w = lca(u, v);
        if(len[w] != lenx &amp;&amp; len[w] != leny &amp;&amp; s[r1 - len[w]] == s[r2 - len[w]])
            ret -= lct.query(w, w);
        return ret;
    }

    inline lint calcr(int l1, int r1, int l2, int r2)
    {
        int u = pre[l1], v = pre[l2];
        int lenx = r1 - l1 + 1, leny = r2 - l2 + 1;
        u = jump(u, lenx); v = jump(v, leny);
        lint ret = lct.query(u, v);
        int w = lca(u, v);
        if(len[w] != lenx &amp;&amp; len[w] != leny &amp;&amp; s[l1 + len[w]] == s[l2 + len[w]])
            ret -= lct.query(w, w);
        return ret;
    }

}pam;

struct query
{
    bool type;
    int l1, r1, l2, r2;
}q[maxn];

int main()
{
    freopen("string.in", "r", stdin);
    freopen("string.out", "w", stdout);

    n = gi(); m = gi(); pam.prepare();
    for(int c, i = 1; i &lt;= n; ++i) 
        c = gi(), lct.addright(pam.addr(c));

    char s[8];
    for(int x, l1, r1, l2, r2, i = 1; i &lt;= m; ++i) {
        scanf("%s", s);
        if (s[0] == 'a') {
            x = gi();
            if (s[3] == 'l') q[i] = (query) {0, 0, pam.addl(x)};
            else q[i] = (query) {0, 0, pam.addr(x)};
        } else {
            l1 = gi(); r1 = gi(); l2 = gi(); r2 = gi();
            q[i] = (query) {s[5] == 'r', l1 + pam.l - 1, r1 + pam.l - 1, l2 + pam.l - 1, r2 + pam.l - 1};
        }
    }

    pam.rebuild();

    for(int i = 1; i &lt;= m; ++i) {
        if (!q[i].l1) lct.addright(q[i].r1);
        else if (!q[i].type) printf("%lld\n", pam.calcl(q[i].l1, q[i].r1, q[i].l2, q[i].r2));
        else printf("%lld\n", pam.calcr(q[i].l1, q[i].r1, q[i].l2, q[i].r2));
    }

    return 0;
}
</code></pre>

完结撒花！
<img src="http://img.uoj.ac/utility/bear-applaud.gif" alt="鼓掌熊" />

感觉回文树很有趣的，大家都来学一下吧。

<img src="http://img.uoj.ac/utility/bear-flying.gif" alt="超人熊" />

最后声明一下：由于这篇文章包括了部分校内题，所以仅限会员查看。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>470</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 21:18:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 13:18:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9b%9e%e6%96%87%e6%a0%91%e6%80%bb%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%96%87%e6%a0%91-%e5%9b%9e%e6%96%87%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[回文树/回文自动机]]></category>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>77</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.17.186.151]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-03 11:33:42]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-03 03:33:42]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[和谐。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[-3]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ2748/Luogu1877][HAOI2012]音量调节（动态规划）</title>
		<link>http://sycstudio.com/archives/473</link>
		<pubDate>Fri, 02 Feb 2018 12:53:22 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=473</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都要改变一次音量。在演出开始之前，他已经做好了一个列表，里面写着在每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。
音量用一个整数描述。输入文件中给定整数beginLevel，代表吉他刚开始的音量，以及整数maxLevel，代表吉他的最大音量。音量不能小于0也不能大于maxLevel。输入文件中还给定了n个整数c1,c2,c3…..cn，表示在第i首歌开始之前吉他手想要改变的音量是多少。
吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2748">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1877">Luogu</a>

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

与其说是动态规划不如说是打标记？

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=51;
const int maxL=1010;
const int inf=2147483647;

int n,st,mx;
int C[maxN];
bool F[maxN][maxL];

int main()
{
    scanf("%d%d%d",&amp;n,&amp;st,&amp;mx);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;C[i]);
    F[0][st]=1;
    for (int i=1;i&lt;=n;i++)
        for (int j=0;j&lt;=mx;j++)
        {
            if (j-C[i]&gt;=0) F[i][j]=F[i][j]|F[i-1][j-C[i]];
            if (j+C[i]&lt;=mx) F[i][j]=F[i][j]|F[i-1][j+C[i]];
        }
    int pos=-1;
    for (int i=mx;i&gt;=0;i--) if (F[n][i]) {pos=i;break;}
    printf("%d\n",pos);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>473</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 20:53:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 12:53:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2748-luogu1877haoi2012%e9%9f%b3%e9%87%8f%e8%b0%83%e8%8a%82%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1084/Luogu2331][SCOI2005]最大子矩阵（动态规划）</title>
		<link>http://sycstudio.com/archives/474</link>
		<pubDate>Fri, 02 Feb 2018 13:02:48 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=474</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

这里有一个n&#42;m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。注意：选出的k个子矩阵
不能相互重叠。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1084">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2331">Luogu</a>

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

看到m的范围就知道是动态规划了。分&#92;(m=1&#92;)和&#92;(m=2&#92;)两种情况讨论。
先是&#92;(m=1&#92;)的。设&#92;(F[i][j]&#92;)表示前&#92;(j&#92;)个数中选出&#92;(i&#92;)个子矩阵的最大和，那么首先它可以从&#92;(F[i][j-1]&#92;)转移过来，这个的意思是取这一层这一次的最大，然后可以枚举一个&#92;(k&#92;)从&#92;(F[i-1][k]&#92;)转移过来。
对于&#92;(m=2&#92;)的则类似设&#92;(F[i][j][k]&#92;)表示第一列选到&#92;(j&#92;)，第二列选到&#92;(k&#92;)，选出&#92;(i&#92;)个子矩阵的最大和，那么类比&#92;(m=1&#92;)的转移，它首先可以从&#92;(F[i][j-1][k]&#92;)和&#92;(F[i][j][k-1]&#92;)中大的那个转移过来，再分别枚举&#92;(pos&#92;)小于&#92;(j&#92;)和小于&#92;(k&#92;)分别从前面转移过来，这个是表示选择其中的一列的子矩阵。最后若&#92;(j==k&#92;)，则还可以从同时选择两行转移过来。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101;
const int maxM=3;
const int maxK=11;
const int inf=2147483647;

int n,m,K;
int Mat[maxN][maxM],Sum[maxN][maxM];
int F1[maxK][maxN];
int F2[maxK][maxN][maxN];

void Do1();
void Do2();

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;K);
    if (m==1) Do1();
    else Do2();
    return 0;
}

void Do1()
{
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Mat[i][1]),Sum[i][1]=Sum[i-1][1]+Mat[i][1];
    F1[0][0]=0;
    for (int i=1;i&lt;=K;i++)
        for (int j=1;j&lt;=n;j++)
        {
            F1[i][j]=F1[i][j-1];//这一步保证从前面取得最优值
            for (int k=0;k&lt;j;k++)
                F1[i][j]=max(F1[i][j],F1[i-1][k]+Sum[j][1]-Sum[k][1]);
        }
    printf("%d\n",F1[K][n]);
    return;
}

void Do2()
{
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d%d",&amp;Mat[i][1],&amp;Mat[i][2]);
        Sum[i][1]=Sum[i-1][1]+Mat[i][1];
        Sum[i][2]=Sum[i-1][2]+Mat[i][2];
    }
    F2[0][0][0]=0;
    for (int i=1;i&lt;=K;i++)
        for (int j=1;j&lt;=n;j++)
            for (int k=1;k&lt;=n;k++)
            {
                F2[i][j][k]=max(F2[i][j-1][k],F2[i][j][k-1]);
                for (int pos=0;pos&lt;j;pos++) F2[i][j][k]=max(F2[i][j][k],F2[i-1][pos][k]+Sum[j][1]-Sum[pos][1]);
                for (int pos=0;pos&lt;k;pos++) F2[i][j][k]=max(F2[i][j][k],F2[i-1][j][pos]+Sum[k][2]-Sum[pos][2]);
                if (j==k)
                    for (int pos=0;pos&lt;j;pos++) F2[i][j][k]=max(F2[i][j][k],F2[i-1][pos][pos]+Sum[j][1]-Sum[pos][1]+Sum[k][2]-Sum[pos][2]);
            }
    printf("%d\n",F2[K][n][n]);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>474</wp:post_id>
		<wp:post_date><![CDATA[2018-02-02 21:02:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-02 13:02:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1084-luogu2331scoi2005%e6%9c%80%e5%a4%a7%e5%ad%90%e7%9f%a9%e9%98%b5%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1003/Luogu1772][ZJOI2006]物流运输（最短路径，动态规划）</title>
		<link>http://sycstudio.com/archives/477</link>
		<pubDate>Sat, 03 Feb 2018 03:32:48 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=477</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转
停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本尽可能地小。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1003">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1772">Luogu</a>

<h3>Tag</h3>

最短路径，动态规划

<h2>解决思路</h2>

看到数据范围，我们可以预处理出&#92;(Cost[i][j]&#92;)表示从第&#92;(i&#92;)天到第&#92;(j&#92;)天每一天的最短花费，这个直接求最短路即可。
接下来动态转移，设&#92;(F[i]&#92;)表示前&#92;(i&#92;)天的最小花费，那么枚举前面的某一天转移即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxDay=110;
const int maxN=21;
const int maxM=maxN*maxN*2;
const int maxQueue=maxN*1000;
const int inf=21474836;

int Day,n,m,K;
int Cant[maxDay];
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int Cost[maxDay][maxDay];
int Queue[maxQueue],Dist[maxN];
bool inqueue[maxN];
int F[maxDay];

void Add_Edge(int u,int v,int w);
void _Add(int u,int v,int w);
int Spfa(int l,int r);

int main()
{
    mem(Head,-1);
    scanf("%d%d%d%d",&amp;Day,&amp;n,&amp;K,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);u--;v--;
        Add_Edge(u,v,w);
    }
    int d;scanf("%d",&amp;d);
    for (int i=1;i&lt;=d;i++)
    {
        int P,l,r;scanf("%d%d%d",&amp;P,&amp;l,&amp;r);
        P--;
        for (int j=l;j&lt;=r;j++) Cant[j]|=(1&lt;&lt;P);
    }
    for (int i=1;i&lt;=Day;i++)
        for (int j=i;j&lt;=Day;j++)
            Cost[i][j]=Spfa(i,j);
    mem(F,63);F[0]=0;
    for (int i=1;i&lt;=Day;i++)
    {
        F[i]=Cost[1][i]*i;
        for (int j=0;j&lt;i;j++)
            F[i]=min(F[i],F[j]+(i-j)*Cost[j+1][i]+K);
    }
    printf("%d\n",F[Day]);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    _Add(u,v,w);_Add(v,u,w);
    return;
}

void _Add(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

int Spfa(int l,int r)
{
    int cant=0;
    for (int i=l;i&lt;=r;i++) cant|=Cant[i];
    mem(Dist,-1);Dist[0]=0;
    int h=1,t=0;Queue[1]=0;
    do
    {
        t++;if (t==maxQueue) t=0;
        int u=Queue[t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if (((1&lt;&lt;V[i])&amp;cant)==0)
                if ((Dist[V[i]]==-1)||(Dist[u]+W[i]&lt;Dist[V[i]]))
                {
                    Dist[V[i]]=Dist[u]+W[i];
                    if (inqueue[V[i]]==0)
                    {
                        h++;if (h==maxQueue) h=0;
                        inqueue[Queue[h]=V[i]]=1;
                    }
                }
        inqueue[u]=0;
    }
    while (t!=h);
    if (Dist[n-1]==-1) return inf;
    return Dist[n-1];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>477</wp:post_id>
		<wp:post_date><![CDATA[2018-02-03 11:32:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-03 03:32:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1003-luogu1772zjoi2006%e7%89%a9%e6%b5%81%e8%bf%90%e8%be%93%ef%bc%88%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%ef%bc%8c%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af"><![CDATA[最短/长路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad-%e9%95%bf%e8%b7%af%e5%be%84"><![CDATA[最短/长路径]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2132/Luogu1935]圈地计划（网络流）</title>
		<link>http://sycstudio.com/archives/478</link>
		<pubDate>Sat, 03 Feb 2018 05:46:49 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=478</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

最近房地产商GDOI(Group of Dumbbells Or Idiots)从NOI(Nuts Old Idiots)手中得到了一块开发土地。据了解，这块土地是一块矩形的区域，可以纵横划分为N×M块小区域。GDOI要求将这些区域分为商业区和工业区来开发。根据不同的地形环境，每块小区域建造商业区和工业区能取得不同的经济价值。更具体点，对于第i行第j列的区域，建造商业区将得到Aij收益，建造工业区将得到Bij收益。另外不同的区域连在一起可以得到额外的收益，即如果区域(I,j)相邻（相邻是指两个格子有公共边）有K块（显然K不超过4）类型不同于(I,j)的区域，则这块区域能增加k×Cij收益。经过Tiger.S教授的勘察，收益矩阵A,B,C都已经知道了。你能帮GDOI求出一个收益最大的方案么？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2132">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1935">Luogu</a>

<h3>Tag</h3>

网络流

<h2>解决思路</h2>

最小割模型。
转化为把所有收益求和后算出最少损失，变成最小割模型。
一个格子建工业区还是商业区这个比较好处理，但若不同类型的格子相邻产生收益这不好处理。
一个格子与其相邻四个格子产生可能的收益，我们发现这个分类与黑白染色很像。
所以我们把格子黑白染色，假设白格子先选工业区，黑格子选商业区，那么相当于一开始所有的相邻不相同的收益都是可以得到的，然后再建图跑最大流。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=101;
const int maxN=maxMap*maxMap*2;
const int maxM=(maxMap*maxMap*6)*2;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m;
int S,T;
int A[maxMap][maxMap],B[maxMap][maxMap],C[maxMap][maxMap],Id[maxMap][maxMap];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow,int opt);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;A[i][j]);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;B[i][j]);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;C[i][j]);
    int idcnt=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) Id[i][j]=++idcnt;
    S=idcnt+1;T=idcnt+2;
    int Ans=0;
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
            if ((i+j)&amp;1)//分黑白两种格子讨论
            {
                Add_Edge(S,Id[i][j],A[i][j],0);
                Add_Edge(Id[i][j],T,B[i][j],0);//先连上源汇点
                Ans+=A[i][j]+B[i][j];
                //分别讨论四个方向相邻的格子
                if (i!=1) Add_Edge(Id[i][j],Id[i-1][j],C[i][j]+C[i-1][j],1),Ans+=C[i][j]+C[i-1][j];
                if (i!=n) Add_Edge(Id[i][j],Id[i+1][j],C[i][j]+C[i+1][j],1),Ans+=C[i][j]+C[i+1][j];
                if (j!=1) Add_Edge(Id[i][j],Id[i][j-1],C[i][j]+C[i][j-1],1),Ans+=C[i][j]+C[i][j-1];
                if (j!=m) Add_Edge(Id[i][j],Id[i][j+1],C[i][j]+C[i][j+1],1),Ans+=C[i][j]+C[i][j+1];
            }
            else
            {
                Add_Edge(S,Id[i][j],B[i][j],0);
                Add_Edge(Id[i][j],T,A[i][j],0);
                Ans+=A[i][j]+B[i][j];
            }
    while (Bfs())//求最小割
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) Ans-=di;
    }
    printf("%d\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int flow,int opt)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=opt*flow;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((Depth[E[i].v]==-1)&amp;&amp;(E[i].flow&gt;0))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>478</wp:post_id>
		<wp:post_date><![CDATA[2018-02-03 13:46:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-03 05:46:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2132-luogu1935%e5%9c%88%e5%9c%b0%e8%ae%a1%e5%88%92%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2127/Luogu1646]happiness（网络流）</title>
		<link>http://sycstudio.com/archives/479</link>
		<pubDate>Sat, 03 Feb 2018 07:37:03 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=479</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

高一一班的座位表是个n&#42;m的矩阵，经过一个学期的相处，每个同学和前后左右相邻的同学互相成为了好朋友。这学期要分文理科了，每个同学对于选择文科与理科有着自己的喜悦值，而一对好朋友如果能同时选文科或者理科，那么他们又将收获一些喜悦值。作为计算机竞赛教练的scp大老板，想知道如何分配可以使得全班的喜悦值总和最大。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2127">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1646">Luogu</a>

<h3>Tag</h3>

网络流

<h2>解决思路</h2>

与<a href="http://sycstudio.com/archives/478">这一题</a>类似的，先把求最大收益转化为求最小损失，即先把所有的收益都加起来，然后求一个最小的损失即最小割。
一个人选文还是选理分别与源汇点连边，假设源点&#92;(S&#92;)表示选文，汇点&#92;(T&#92;)表示选理，这个比较好处理，但是，与旁边的人的选择就不好处理了，因为这里两人同时选文和同时选理的收益是不一样的。
怎么办呢？总共只有&#92;(4&#92;)种可能，所以我们把这四种情况列出来。
设&#92;(x->y&#92;)表示&#92;(x&#92;)到&#92;(y&#92;)这条边上的容量，设&#92;(u&#92;)表示两人同时选文的收益，&#92;(v&#92;)为两人同时选理的收益，则有：
若两人同时选文，则割掉的边是&#92;(x->T,y->T&#92;)，损失是&#92;(v&#92;)。
若两人同时选理，则割掉的边是&#92;(S->x,S->y&#92;)，损失是&#92;(u&#92;)
若&#92;(x&#92;)文&#92;(y&#92;)理，则割掉的边是&#92;(x->T,S->y,x->y&#92;)，损失是&#92;(u+v&#92;)
若&#92;(x&#92;)理&#92;(y&#92;)文，则割掉的边是&#92;(S->x,y->T,y->x&#92;)
综上，四个方程就是
&#92;((x->T)+(y->T)=v &#92;&#92; (S->x)+(S->y)=u &#92;&#92; (x->T)+(S->y)+(x->y)=u+v &#92;&#92; (S->x)+(y->T)+(y->x)=u+v&#92;)
但是这个方程是无法直接解的。考虑到实际上不管是哪一组解都是可以的，不妨设&#92;((x->T)==(y->T)==\frac{v}{2}&#92;)，同理有&#92;((S->x)==(S->y)==\frac{u}{2}&#92;)，那么就有&#92;((x->y)==(y->x)==\frac{u+v}{2}&#92;)
由于除以二会导致可能出现小数，所以考虑把所有的容量先乘以二变成整数，最后求出最小割再除以二即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=101;
const int maxN=maxMap*maxMap;
const int maxM=maxN*100;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m,S,T;
int Mat1[maxMap][maxMap],Mat2[maxMap][maxMap],Mat3[maxMap][maxMap],Mat4[maxMap][maxMap],Mat5[maxMap][maxMap],Mat6[maxMap][maxMap],Id[maxMap][maxMap];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow,int opt);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    int Ans=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;Mat1[i][j]),Ans+=Mat1[i][j];
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;Mat2[i][j]),Ans+=Mat2[i][j];
    for (int i=1;i&lt;n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;Mat3[i][j]),Ans+=Mat3[i][j];
    for (int i=1;i&lt;n;i++) for (int j=1;j&lt;=m;j++) scanf("%d",&amp;Mat4[i][j]),Ans+=Mat4[i][j];
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;m;j++) scanf("%d",&amp;Mat5[i][j]),Ans+=Mat5[i][j];
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;m;j++) scanf("%d",&amp;Mat6[i][j]),Ans+=Mat6[i][j];
    int idcnt=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) Id[i][j]=++idcnt;
    S=idcnt+1;T=idcnt+2;
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
        {
            Add_Edge(S,Id[i][j],Mat1[i][j]*2+Mat3[i][j]+Mat3[i-1][j]+Mat5[i][j]+Mat5[i][j-1],0);
            Add_Edge(Id[i][j],T,Mat2[i][j]*2+Mat4[i][j]+Mat4[i-1][j]+Mat6[i][j]+Mat6[i][j-1],0);
            if (i!=n) Add_Edge(Id[i][j],Id[i+1][j],Mat3[i][j]+Mat4[i][j],1);
            if (j!=m) Add_Edge(Id[i][j],Id[i][j+1],Mat5[i][j]+Mat6[i][j],1);
        }
    int mxflow=0;
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) mxflow+=di;
    }
    printf("%d\n",Ans-mxflow/2);
    return 0;
}

void Add_Edge(int u,int v,int flow,int opt)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=opt*flow;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for(int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((Depth[E[i].v]==Depth[u]+1)&amp;&amp;(E[i].flow&gt;0))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>479</wp:post_id>
		<wp:post_date><![CDATA[2018-02-03 15:37:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-03 07:37:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2127-luogu1646happiness%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1189/Luogu3191][HNOI2007]紧急疏散evacuate（二分，网络流）</title>
		<link>http://sycstudio.com/archives/482</link>
		<pubDate>Sun, 04 Feb 2018 10:57:03 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=482</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

发生了火警，所有人员需要紧急疏散！假设每个房间是一个N M的矩形区域。每个格子如果是'.'，那么表示这是一块空地；如果是'X'，那么表示这是一面墙，如果是'D'，那么表示这是一扇门，人们可以从这儿撤出房间。已知门一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散的时候，每一秒钟每个人都可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上就没有人数限制了（也就是说每块空地可以同时站无数个人）。但是，由于门很窄，每一秒钟只能有一个人移动到门的位置，一旦移动到门的位置，就表示他已经安全撤离了。现在的问题是：如果希望所有的人安全撤离，最短需要多少时间？或者告知根本不可能。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1189">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3191">Luogu</a>

<h3>Tag</h3>

二分，网络流

<h2>解决思路</h2>

二分时间，转化成判定问题。考虑如何限制每一个门在同一时刻只能出去一个人，若当前二分的时间为&#92;(tim&#92;)，则把门拆成&#92;(tim&#92;)个点，每一个点只与汇点连容量为一的边。对于每一个点，练到它能到的门的那个时刻的点，求最大流判断是否为人数。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=23;
const int maxN=maxMap*maxMap*maxMap;
const int maxM=maxN*10*2;
const int F1[4]={0,0,1,-1};
const int F2[4]={1,-1,0,0};
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m,S,T,doorcnt,pcnt;
char Input[maxMap][maxMap];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],Id[maxMap][maxMap],cur[maxN];

bool Check(int mid);
void Add_Edge(int u,int v,int flow);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%s",Input[i]+1);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) {if (Input[i][j]=='D') doorcnt++;if (Input[i][j]=='.') pcnt++;}
    int idcnt=0;
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) Id[i][j]=++idcnt;
    int l=1,r=n*m+2;
    int Ans=-1;
    do
    {
        int mid=(l+r)/2;
        if (Check(mid)) Ans=mid,r=mid-1;
        else l=mid+1;
    }
    while (l&lt;=r);
    if (Ans!=-1) printf("%d\n",Ans);
    else printf("impossible\n");
    return 0;
}

void Add_Edge(int u,int v,int flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

int Queue1[maxN],Queue2[maxN],Len[maxMap][maxMap],Tag[maxMap][maxMap];

bool Check(int mid)//判定
{
    edgecnt=-1;mem(Head,-1);mem(Tag,0);//Tag用来标记某一个点当前最后一个能到的门的编号，这样可以省去每一次memset的花费
    int nodecnt=n*m;
    S=n*m+mid*doorcnt+1;
    T=n*m+mid*doorcnt+2;
    int dcnt=0;
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
        {
            if (Input[i][j]=='X') continue;
            if (Input[i][j]=='.') Add_Edge(S,Id[i][j],1);
            if (Input[i][j]=='D')//每找到一个门，则从这个门开始bfs求出能到这个门的点
            {
                int h=1,t=0;
                Queue1[1]=i;Queue2[1]=j;Len[i][j]=0;
                dcnt++;
                Tag[i][j]=dcnt;
                for (int de=1;de&lt;=mid;de++)
                {
                    Add_Edge(nodecnt+de,T,1);
                    if (de!=mid) Add_Edge(nodecnt+de,nodecnt+de+1,inf);
                }
                do
                {
                    t++;int x=Queue1[t],y=Queue2[t];
                    if (Len[x][y]&gt;mid) continue;
                    Add_Edge(Id[x][y],nodecnt+Len[x][y],1);
                    for (int o=0;o&lt;4;o++)
                        if ((Input[x+F1[o]][y+F2[o]]=='.')&amp;&amp;(Tag[x+F1[o]][y+F2[o]]!=dcnt))
                        {
                            Tag[x+F1[o]][y+F2[o]]=dcnt;
                            Len[x+F1[o]][y+F2[o]]=Len[x][y]+1;
                            h++;Queue1[h]=x+F1[o];Queue2[h]=y+F2[o];
                        }
                }
                while (t!=h);
                nodecnt+=mid;
            }
        }
    int ret=0;//求解最大流
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) ret+=di;
    }
    if (ret==pcnt) return 1;
    return 0;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>482</wp:post_id>
		<wp:post_date><![CDATA[2018-02-04 18:57:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-04 10:57:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1189-luogu3191hnoi2007%e7%b4%a7%e6%80%a5%e7%96%8f%e6%95%a3evacuate%ef%bc%88%e4%ba%8c%e5%88%86%ef%bc%8c%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3531/Luogu3313][Sdoi2014]旅行（树链剖分，线段树）</title>
		<link>http://sycstudio.com/archives/483</link>
		<pubDate>Sun, 04 Feb 2018 12:31:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=483</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

S国有N个城市，编号从1到N。城市间用N-1条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，  S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。
在S国的历史上常会发生以下几种事件：
”CC x c”：城市x的居民全体改信了c教；
”CW x w”：城市x的评级调整为w;
”QS x y”：一位旅行者从城市x出发，到城市y，并记下了途中留宿过的城市的评级总和；
”QM x y”：一位旅行者从城市x出发，到城市y，并记下了途中留宿过
的城市的评级最大值。
由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3531">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3313">Luogu</a>

<h3>Tag</h3>

树链剖分，线段树

<h2>解决思路</h2>

比价好想的就是树链剖分后对每一种宗教单独开一棵线段树维护，这样的话就可以直接对每一种宗教查询了。
但空间是开不下的，考虑到其实我们只要用到其中的部分空间，所以可以动态地开线段树的点，这样就可以了。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100010;
const int inf=2147483647;

class SegData
{
public:
    int ls,rs;
    ll sum,mx;
};

int n,Q,nodecnt;
int Color[maxN],root[maxN],Val[maxN];
SegData S[maxN*100];
int Fa[maxN],Depth[maxN],Top[maxN],Hson[maxN],Size[maxN];
int idcnt=0,Id[maxN];
int edgecnt=-1,Head[maxN],Next[maxN*2],V[maxN*2];

void dfs1(int u,int fa);//树链剖分
void dfs2(int u,int top);
void Update(int now);
void Modify(int &amp;now,int l,int r,int pos,int val);//线段树单点修改
ll QSum(int u,int v);//路径查询
ll QMax(int u,int v);
ll SSum(int now,int l,int r,int ql,int qr);//线段树查询
ll SMax(int now,int l,int r,int ql,int qr);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;Q);
    for (int i=1;i&lt;=n;i++) scanf("%d%d",&amp;Val[i],&amp;Color[i]);
    for (int i=1;i&lt;n;i++)
    {
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
        edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;V[edgecnt]=u;
    }
    Depth[1]=1;
    dfs1(1,1);
    dfs2(1,1);
    for (int i=1;i&lt;=n;i++) Modify(root[Color[i]],1,n,Id[i],Val[i]);
    char opt[10];
    while (Q--)
    {
        scanf("%s",opt);
        if ((opt[0]=='C')&amp;&amp;(opt[1]=='C'))
        {
            int city,col;scanf("%d%d",&amp;city,&amp;col);
            Modify(root[Color[city]],1,n,Id[city],0);
            Modify(root[col],1,n,Id[city],Val[city]);
            Color[city]=col;
        }
        if ((opt[0]=='C')&amp;&amp;(opt[1]=='W'))
        {
            int city,val;scanf("%d%d",&amp;city,&amp;val);
            Val[city]=val;
            Modify(root[Color[city]],1,n,Id[city],val);
        }
        if ((opt[0]=='Q')&amp;&amp;(opt[1]=='S'))
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);
            printf("%lld\n",QSum(u,v));
        }
        if ((opt[0]=='Q')&amp;&amp;(opt[1]=='M'))
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);
            printf("%lld\n",QMax(u,v));
        }
    }
    return 0;
}

void dfs1(int u,int fa)
{
    Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (V[i]!=fa)
        {
            Fa[V[i]]=u;Depth[V[i]]=Depth[u]+1;
            dfs1(V[i],u);
            if (Size[V[i]]&gt;Size[Hson[u]]) Hson[u]=V[i];
            Size[u]+=Size[V[i]];
        }
    return;
}

void dfs2(int u,int top)
{
    Top[u]=top;
    Id[u]=++idcnt;
    if (Hson[u]==0) return;
    dfs2(Hson[u],top);
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=Fa[u])&amp;&amp;(V[i]!=Hson[u]))
            dfs2(V[i],V[i]);
    return;
}

void Update(int now)
{
    int ls=S[now].ls,rs=S[now].rs;
    S[now].sum=S[ls].sum+S[rs].sum;
    S[now].mx=max(S[ls].mx,S[rs].mx);
    return;
}

void Modify(int &amp;now,int l,int r,int pos,int val)
{
    if (now==0) now=++nodecnt;
    if (l==r)
    {
        S[now].sum=S[now].mx=val;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) Modify(S[now].ls,l,mid,pos,val);
    else Modify(S[now].rs,mid+1,r,pos,val);
    Update(now);
    return;
}

ll QSum(int u,int v)
{
    ll ret=0,col=Color[v];
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=ret+SSum(root[col],1,n,Id[Top[u]],Id[u]);
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    ret=ret+SSum(root[col],1,n,Id[u],Id[v]);
    return ret;
}

ll QMax(int u,int v)
{
    ll ret=0,col=Color[v];
    while (Top[u]!=Top[v])
    {
        if (Depth[Top[u]]&lt;Depth[Top[v]]) swap(u,v);
        ret=max(ret,SMax(root[col],1,n,Id[Top[u]],Id[u]));
        u=Fa[Top[u]];
    }
    if (Depth[u]&gt;Depth[v]) swap(u,v);
    ret=max(ret,SMax(root[col],1,n,Id[u],Id[v]));
    return ret;
}

ll SSum(int now,int l,int r,int ql,int qr)
{
    if (now==0) return 0;
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].sum;
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return SSum(S[now].ls,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return SSum(S[now].rs,mid+1,r,ql,qr);
    else return SSum(S[now].ls,l,mid,ql,mid)+SSum(S[now].rs,mid+1,r,mid+1,qr);
}

ll SMax(int now,int l,int r,int ql,int qr)
{
    if (now==0) return 0;
    if ((l==ql)&amp;&amp;(r==qr)) return S[now].mx;
    int mid=(l+r)&gt;&gt;1;
    if (qr&lt;=mid) return SMax(S[now].ls,l,mid,ql,qr);
    else if (ql&gt;=mid+1) return SMax(S[now].rs,mid+1,r,ql,qr);
    else return max(SMax(S[now].ls,l,mid,ql,mid),SMax(S[now].rs,mid+1,r,mid+1,qr));
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>483</wp:post_id>
		<wp:post_date><![CDATA[2018-02-04 20:31:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-04 12:31:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3531-luogu3313sdoi2014%e6%97%85%e8%a1%8c%ef%bc%88%e6%a0%91%e9%93%be%e5%89%96%e5%88%86%ef%bc%8c%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e6%a0%91%e9%93%be%e5%89%96%e5%88%86"><![CDATA[树链剖分]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>80</wp:comment_id>
			<wp:comment_author><![CDATA[宋聿辰]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[sycstudio@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-05 09:11:13]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-05 01:11:13]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我太强了。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[trash]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
				<wp:meta_value><![CDATA[1517799957]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ2120/Luogu1903]数颜色（莫队算法）</title>
		<link>http://sycstudio.com/archives/485</link>
		<pubDate>Mon, 05 Feb 2018 03:28:37 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=485</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。为了满足墨墨的要求，你知道你需要干什么了吗？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2120">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1903">Luogu</a>

<h3>Tag</h3>

莫队算法，离线

<h2>解决思路</h2>

莫队算法把询问离线下来，排序后移动左右指针得到答案。
但这里有修改操作，怎么办呢？
可以在把询问左右区间离线下来的同时记录时间，记录是第一个修改操作后的，那么回答询问的时候再移动时间指针，把要修改的修改掉，不要修改的改回去。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=5001000;
const int inf=2147483647;

class Question//询问
{
public:
    int l,r,tim,id;
};

class Modify//修改
{
public:
    int pos,before,col;
};

int n,m,nowans=0;
int L,R,Tim;
int Col[maxN],InitCol[maxN],Sum[maxN],Belong[maxN];
Question Q[maxN];
Modify M[maxN];
int Ans[maxN];

bool cmp(Question A,Question B);
void TimeMove(int pos,int col);
void PosMove(int col,int opt);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    int size=pow(n,0.66666666);
    for (int i=1;i&lt;=n;i++) Belong[i]=(i-1)/size+1;
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Col[i]),InitCol[i]=Col[i];
    int mcnt=0,qcnt=0;
    for (int i=1;i&lt;=m;i++)
    {
        char opt;cin&gt;&gt;opt;
        if (opt=='Q')
        {
            int l,r;scanf("%d%d",&amp;l,&amp;r);
            Q[++qcnt]=(Question){l,r,mcnt,qcnt};
        }
        else
        {
            int pos,col;scanf("%d%d",&amp;pos,&amp;col);
            M[++mcnt]=(Modify){pos,Col[pos],col};
            Col[pos]=col;
        }
    }
    for (int i=1;i&lt;=n;i++) Col[i]=InitCol[i];
    L=1,R=0;Tim=0;
    sort(&amp;Q[1],&amp;Q[qcnt+1],cmp);
    for (int i=1;i&lt;=qcnt;i++)
    {
        while (Tim&lt;Q[i].tim) TimeMove(M[Tim+1].pos,M[Tim+1].col),Tim++;
        while (Tim&gt;Q[i].tim) TimeMove(M[Tim].pos,M[Tim].before),Tim--;
        while (L&lt;Q[i].l) PosMove(Col[L],-1),L++;
        while (L&gt;Q[i].l) PosMove(Col[L-1],1),L--;
        while (R&gt;Q[i].r) PosMove(Col[R],-1),R--;
        while (R&lt;Q[i].r) PosMove(Col[R+1],1),R++;
        Ans[Q[i].id]=nowans;
    }
    for (int i=1;i&lt;=qcnt;i++) printf("%d\n",Ans[i]);
    return 0;
}

bool cmp(Question A,Question B)
{
    return (Belong[A.l]!=Belong[B.l])?(A.l&lt;B.l):((Belong[A.r]!=Belong[B.r])?(A.r&lt;B.r):(A.tim&lt;B.tim));
}

void TimeMove(int pos,int col)//移动时间
{
    if ((pos&gt;=L)&amp;&amp;(pos&lt;=R)) PosMove(Col[pos],-1),PosMove(col,1);
    Col[pos]=col;
    return;
}

void PosMove(int col,int opt)//移动位置
{
    nowans-=(Sum[col]&gt;0);
    Sum[col]+=opt;
    nowans+=(Sum[col]&gt;0);
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>485</wp:post_id>
		<wp:post_date><![CDATA[2018-02-05 11:28:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-05 03:28:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2120-luogu1903%e6%95%b0%e9%a2%9c%e8%89%b2%ef%bc%88%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<category domain="post_tag" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="category" nicename="%e8%8e%ab%e9%98%9f%e7%ae%97%e6%b3%95"><![CDATA[莫队算法]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%a6%bb%e7%ba%bf%e5%a4%84%e7%90%86"><![CDATA[离线处理]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3506/Luogu3165][Cqoi2014]排序机械臂（平衡树）</title>
		<link>http://sycstudio.com/archives/487</link>
		<pubDate>Mon, 05 Feb 2018 15:36:11 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=487</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。它遵循一个简单的排序规则，第一次操作找到摄低的物品的位置P1,并把左起第一个至P1间的物品反序；第二次找到第二低的物品的位置P2,并把左起第二个至P2间的物品反序...最终所有的物品都会被排好序。
上图给出<em>个示例，第</em>次操作前，菝低的物品在位置4,于是把第1至4的物品反序；第二次操作前，第二低的物品在位罝6,于是把第2至6的物品反序...
你的任务便是编写一个程序，确定一个操作序列，即每次操作前第i低的物品所在位置Pi,以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3506">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3165">Luogu</a>

<h3>Tag</h3>

平衡树

<h2>解决思路</h2>

记录下位置后平衡树维护区间翻转即可。
调了好久才发现为了方便直接把找后继的代码在&#92;(main&#92;)里面展开了，结果没有下放标记。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int inf=2147483647;

class SplayData
{
public:
    int key;
    int fa,ch[2];
    int rev,size;
};

class Data
{
public:
    int key,pos;
};

int n,root;
SplayData S[maxN];
int Stack[maxN];
Data D[maxN];

void Update(int x);
void PushDown(int x);
void Rotate(int x);
void Splay(int x,int goal);
void Outp(int now);
void Outp2(int now);
int Rank(int rth);
bool cmp(Data A,Data B);

int main()
{
    scanf("%d",&amp;n);
    S[1].key=-1;//设置1和n+2两个哨兵节点
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;S[i+1].key),D[i]=(Data){S[i+1].key,i+1};
    S[n+2].key=-1;
    S[1].fa=0;S[1].ch[1]=2;
    root=1;
    for (int i=2;i&lt;=n+1;i++) S[i].fa=i-1,S[i].ch[1]=i+1;//直接像一条链一样建树
    S[n+2].fa=n+1;
    Splay(n+2,0);
    sort(&amp;D[1],&amp;D[n+1],cmp);//排序
    for (int i=1;i&lt;=n;i++)
    {
        int l=Rank(i),r=D[i].pos;
        Splay(r,0);
        printf("%d ",S[S[r].ch[0]].size);
        r=S[r].ch[1];PushDown(r);while (S[r].ch[0]) r=S[r].ch[0],PushDown(r);//这里就是把找后继展开了，记得pushdown
        Splay(l,0);
        Splay(r,l);
        int node=S[r].ch[0];//区间翻转
        swap(S[node].ch[0],S[node].ch[1]);
        if (node) S[node].rev^=1;
    }
    return 0;
}

void Update(int x)
{
    S[x].size=S[S[x].ch[0]].size+S[S[x].ch[1]].size+1;
    return;
}

void PushDown(int x)
{
    if (S[x].rev)
    {
        S[x].rev=0;
        int lson=S[x].ch[0],rson=S[x].ch[1];
        swap(S[lson].ch[0],S[lson].ch[1]);
        swap(S[rson].ch[0],S[rson].ch[1]);
        if (lson) S[lson].rev^=1;
        if (rson) S[rson].rev^=1;
    }
    return;
}

void Rotate(int x)
{
    int y=S[x].fa,z=S[y].fa;
    int sx=(x==S[y].ch[1]);
    int sy=(y==S[z].ch[1]);
    S[x].fa=z;if (z) S[z].ch[sy]=x;
    S[y].ch[sx]=S[x].ch[sx^1];if (S[x].ch[sx^1]) S[S[x].ch[sx^1]].fa=y;
    S[y].fa=x;S[x].ch[sx^1]=y;
    Update(y);return;
}

void Splay(int x,int goal)
{
    int now=x,stacktop=1;Stack[1]=x;
    while (now!=root)
    {
        Stack[++stacktop]=S[now].fa;now=S[now].fa;
    }
    for (int i=stacktop;i&gt;=1;i--) PushDown(Stack[i]);
    while (S[x].fa!=goal)
    {
        int y=S[x].fa,z=S[y].fa;
        if (z!=goal)
            ((x==S[y].ch[0])^(y==S[z].ch[0]))?(Rotate(x)):(Rotate(y));
        Rotate(x);
    }
    if (goal==0) root=x;
    Update(x);return;
}

int Rank(int kth)
{
    int now=root;
    do
    {
        PushDown(now);
        int lson=S[now].ch[0];
        if (S[lson].size+1==kth) return now;
        if (S[lson].size&gt;=kth) now=lson;
        else kth=kth-S[lson].size-1,now=S[now].ch[1];
    }
    while (1);
}

bool cmp(Data A,Data B)
{
    if (A.key!=B.key) return A.key&lt;B.key;
    else return A.pos&lt;B.pos;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>487</wp:post_id>
		<wp:post_date><![CDATA[2018-02-05 23:36:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-05 15:36:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3506-luogu3165cqoi2014%e6%8e%92%e5%ba%8f%e6%9c%ba%e6%a2%b0%e8%87%82%ef%bc%88%e5%b9%b3%e8%a1%a1%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1483/Luogu3201][HNOI2009]梦幻布丁（平衡树，启发式合并）</title>
		<link>http://sycstudio.com/archives/488</link>
		<pubDate>Mon, 05 Feb 2018 15:44:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=488</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

N个布丁摆成一行,进行M次操作.每次将某个颜色的布丁全部变成另一种颜色的,然后再询问当前一共有多少段颜色.
例如颜色分别为1,2,2,1的四个布丁一共有3段颜色

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1483">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3201">Luogu</a>

<h3>Tag</h3>

平衡树，启发式合并

<h2>解决思路</h2>

震惊，某选手手写平衡树调一晚上没有调过，一怒之下竟然用&#92;(set&#92;)水过。
对每一种颜色维护一个平衡树存储有那些位置是这个颜色，那么把一种颜色改成另一种颜色的时候，就启发式地把两个合并。全局维护一个答案，若把这个点加入会少一些答案，那么直接减去即可。
但需要注意的是，题中明确说是把&#92;(x&#92;)合并到&#92;(y&#92;)，但我们启发式合并的时候可能是把&#92;(y&#92;)合并到&#92;(x&#92;)，这时候我们就把&#92;(x&#92;)与&#92;(y&#92;)的编号永久地交换一下，让以后找到&#92;(x&#92;)都相当于找到了&#92;(y&#92;)，&#92;(y&#92;)同理。
没错，这一题可以用&#92;(set&#92;)

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int inf=2147483647;

int n,Ans=0;
int Col[maxN],Colf[maxN];
set&lt;int&gt; S[maxN];

void Merge(int u,int v);

int main()
{
    int m;
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=1000000;i++) Colf[i]=i;//这个就是标记当前颜色真实对应到的颜色编号
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;Col[i]);
        if (Col[i]!=Col[i-1]) Ans++;
        S[Col[i]].insert(i);
    }
    while (m--)
    {
        int opt;scanf("%d",&amp;opt);
        if (opt==1)
        {
            int u,v;scanf("%d%d",&amp;u,&amp;v);
            if (u==v) continue;//相等直接跳过
            if (S[Colf[u]].size()&gt;S[Colf[v]].size()) swap(Colf[u],Colf[v]);//保证启发式合并
            Merge(Colf[u],Colf[v]);
        }
        if (opt==2) printf("%d\n",Ans);
    }
    return 0;
}

void Merge(int u,int v)
{
    for (set&lt;int&gt;::iterator i=S[u].begin();i!=S[u].end();i++)
    {
        if (Col[*i-1]==v) Ans--;//当加入这个位置会减少答案，则减少
        if (Col[*i+1]==v) Ans--;
        S[v].insert(*i);
    }
    for (set&lt;int&gt;::iterator i=S[u].begin();i!=S[u].end();i++)//统一修改标记
        Col[*i]=v;
    S[u].clear();//清空
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>488</wp:post_id>
		<wp:post_date><![CDATA[2018-02-05 23:44:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-05 15:44:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1483-luogu3201hnoi2009%e6%a2%a6%e5%b9%bb%e5%b8%83%e4%b8%81%ef%bc%88%e5%b9%b3%e8%a1%a1%e6%a0%91%ef%bc%8c%e5%90%af%e5%8f%91%e5%bc%8f%e5%90%88%e5%b9%b6%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<category domain="post_tag" nicename="%e5%90%af%e5%8f%91%e5%bc%8f"><![CDATA[启发式]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e5%b9%b3%e8%a1%a1%e6%a0%91"><![CDATA[平衡树]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%90%af%e5%8f%91%e5%bc%8f"><![CDATA[启发式]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3884/Luogu4219]上帝与集合的正确用法（扩展欧拉定理）</title>
		<link>http://sycstudio.com/archives/490</link>
		<pubDate>Tue, 06 Feb 2018 06:59:57 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=490</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

根据一些书上的记载，上帝的一次失败的创世经历是这样的：
第一天，    上帝创造了一个世界的基本元素，称做“元”。
第二天，    上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。
第三天，    上帝又创造了一个新的元素，称作“β”。“β”被定义为“α”构成的集合。容易发现，一共有四种不同的“β”。
第四天，    上帝创造了新的元素“γ”，“γ”被定义为“β”的集合。显然，一共会有16种不同的“γ”。
如果按照这样下去，上帝创造的第四种元素将会有65536种，第五种元素将会有2^65536种。这将会是一个天文数字。
然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……
然而不久，当上帝创造出最后一种元素“θ”时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。
至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素“θ”一共有多少种？
上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对p取模后的值即可。
你可以认为上帝从“α”到“θ”一共创造了10^9次元素，或10^18次，或者干脆∞次。
一句话题意：
<img src="http://sycstudio.com/bzojch/file/3884_0.png" alt="BZOJ3884" />

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3884">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P4139">Luogu</a>

<h3>Tag</h3>

扩展欧拉定理

<h2>解决思路</h2>

依照题意递归肯定是不行的（无线层诶）。首先想到的就是欧拉定理，即
&#92;[x^a \quad mod \quad p=x^{a \quad mod \quad \phi(p)} \quad mod \quad p&#92;]
当最后&#92;(\phi(i)==1&#92;)的时候，递归就结束了。
但这里给出的模数&#92;(p&#92;)并不一定是质数，所以这里要用到扩展欧拉定理，即
&#92;[x^a \quad mod \quad b=x^{a \quad mod \quad \phi(b)+\phi(b)} \quad mod \quad b&#92;]
那么根据这个求解即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

ll GetPhi(ll x);
ll Pow(ll cnt,ll Mod);
ll Calc(ll p);

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        int x;scanf("%d",&amp;x);
        printf("%lld\n",Calc(x));//递归求解
    }
}

ll GetPhi(ll x)
{
    ll ret=x;
    for (ll i=2;i*i&lt;=x;i++)
        if (x%i==0)
        {
            ret=ret/i*(i-1);
            while (x%i==0) x=x/i;
        }
    if (x!=1) ret=ret/x*(x-1);
    return ret;
}

ll Pow(ll cnt,ll Mod)
{
    ll x=2,ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret;
}

ll Calc(ll p)
{
    if (p==1) return 0;
    ll nowphi=GetPhi(p);
    return Pow(Calc(nowphi)+nowphi,p);
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>490</wp:post_id>
		<wp:post_date><![CDATA[2018-02-06 14:59:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-06 06:59:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3884-luogu4219%e4%b8%8a%e5%b8%9d%e4%b8%8e%e9%9b%86%e5%90%88%e7%9a%84%e6%ad%a3%e7%a1%ae%e7%94%a8%e6%b3%95%ef%bc%88%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86-%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86"><![CDATA[欧拉定理/扩展欧拉定理]]></category>
		<category domain="category" nicename="%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86-%e6%89%a9%e5%b1%95%e6%ac%a7%e6%8b%89%e5%ae%9a%e7%90%86"><![CDATA[欧拉定理/扩展欧拉定理]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4872/Luogu3750][Shoi2017]分手是祝愿（期望动态规划，逆元）</title>
		<link>http://sycstudio.com/archives/491</link>
		<pubDate>Tue, 06 Feb 2018 12:15:42 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=491</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Zeit und Raum trennen dich und mich.
时空将你我分开。B 君在玩一个游戏，这个游戏由 n 个灯和 n 个开关组成，给定这 n 个灯的初始状态，下标为从 1 到 n 的正整数。每个灯有两个状态亮和灭，我们用 1 来表示这个灯是亮的，用 0 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。但是当操作第 i 个开关时，所有编号为 i 的约数（包括 1 和 i）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。这个策略需要的操作次数很多， B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 k 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 k 步）操作这些开关。B 君想知道按照这个策略（也就是先随机操作，最后小于等于 k 步，使用操作次数最小的操作方法）的操作次数的期望。这个期望可能很大，但是 B 君发现这个期望乘以 n 的阶乘一定是整数，所以他只需要知道这个整数对 100003 取模之后的结果。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4872">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3750">Luogu</a>

<h3>Tag</h3>

期望动态规划，逆元

<h2>解决思路</h2>

首先考虑如何得到最少步数，由于更改一个灯的状态只会影响到比它小的灯，所以我们可以从大往小依次把灯的状态更改，&#92;(O\sqrt{n}&#92;)地枚举约数修改。可以证明其它的方法不会更优。
那么这样我们就知道有那些灯是一定会被关的，由于一盏灯被关多次是没有用的，所以这些应该被关掉的灯的顺序是与答案没有关系的。实际上，这些被关掉的灯的位置也是与计数无关的，我们只要知道需要关掉多少盏灯即可，因为最后的答案只与它有关。
那么问题转化为求在&#92;(n&#92;)个物品中，我们要选择确定的&#92;(tot&#92;)个（即要关掉的灯数），多选的其它物品可以花费一个回合丢掉（为什么是回合，没错我文明玩多了）。选择是随机的，每一次等概率选择一个物品或丢掉一个物品，而当剩下要求选的物品小于等于&#92;(K&#92;)时，直接选择这些物品。求期望步数。
那么首先有一个简单的想法，就是设&#92;(F[i]&#92;)表示还剩&#92;(i&#92;)个必选的物品没选的期望，则&#92;(F[i]&#92;)可以由&#92;(F[i+1],F[i-1]&#92;)分别转移过来，即&#92;(F[i]=\frac{i}{n}F[i+1]+\frac{n-i}{n}F[i+1]&#92;)，但这样不好解，需要通过&#92;(F[n]=F[n-1]+1&#92;)，一个一个方程地化。
我们换一个思路，考虑设&#92;(f[i]&#92;)表示从剩下了&#92;(i&#92;)个正确的物品没选到剩下了&#92;(i-1&#92;)个正确的物品没选的期望步数，那么首先对于小于等于&#92;(K&#92;)的&#92;(i&#92;)，有&#92;(f[i]=1&#92;)，&#92;(f[n]&#92;)也是&#92;(1&#92;)，因为&#92;(n&#92;)只能向&#92;(n-1&#92;)转移。
剩下的怎么转移呢？
考虑原来之前我们定义的&#92;(F&#92;)，其实就是&#92;(f&#92;)的前缀和，那么我们试着由前缀和的式子反推一下？
&#92;[F[i]=\sum&#95;{j=1}^{i}=\frac{i}{n} \sum&#95;{j=1}^{i-1} f[j]+\frac{n-i}{n} \sum&#95;{j=1}^{i+1} f[j]+1&#92;]
发现有很多可以抵掉的，化简后得
&#92;[f[i]=\frac{i}{n}+\frac{n-i}{n}(f[i+1]+f[i]+1)&#92;]
这样就只有两个变量了，移项得到
&#92;[f[i]=\frac{n+(n-i)f[i+1]}{i}&#92;]
这样就可以从后往前递推了，因为有除以&#92;(i&#92;)，所以可以提前递推求出逆元。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int Mod=100003;
const int inf=2147483647;

int n,K;
int Light[maxN];
ll Inv[maxN];
ll g[maxN];

int main()
{
    ll Fac=1;//阶乘
    scanf("%d%d",&amp;n,&amp;K);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Light[i]),Fac=Fac*i%Mod;
    int tot=0;
    for (int i=n;i&gt;=1;i--)
        if (Light[i])
        {
            for (int j=1;j*j&lt;=i;j++)
            {
                if (i%j==0) Light[j]^=1;
                if ((i%j==0)&amp;&amp;(j*j!=i)) Light[i/j]^=1;
            }
            tot++;
        }
    if (tot&lt;=K)//当tot&lt;=K时直接输出解
    {
        printf("%lld\n",tot*Fac%Mod);
        return 0;
    }
    //预处理逆元
    Inv[1]=1;for (int i=2;i&lt;=n;i++) Inv[i]=(ll)(Mod-Mod/i)*Inv[Mod%i]%Mod;
    //求解
    //先处理i&lt;=K的
    for (int i=1;i&lt;=K;i++) g[i]=1;
    g[n]=1;
    //再递推
    for (int i=n-1;i&gt;K;i--) g[i]=(ll)((n-i)*g[i+1]%Mod+n)%Mod*Inv[i]%Mod;
    ll Ans=0;
    for (int i=tot;i&gt;=1;i--) Ans=(Ans+g[i])%Mod;
    printf("%lld\n",Ans*Fac%Mod);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>491</wp:post_id>
		<wp:post_date><![CDATA[2018-02-06 20:15:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-06 12:15:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4872-luogu3750shoi2017%e5%88%86%e6%89%8b%e6%98%af%e7%a5%9d%e6%84%bf%ef%bc%88%e6%9c%9f%e6%9c%9b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e9%80%86%e5%85%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%a6%82%e7%8e%87-%e6%9c%9f%e6%9c%9b"><![CDATA[概率/期望]]></category>
		<category domain="post_tag" nicename="%e9%80%86%e5%85%83"><![CDATA[逆元]]></category>
		<category domain="category" nicename="%e6%a6%82%e7%8e%87%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[概率动态规划]]></category>
		<category domain="category" nicename="%e9%80%86%e5%85%83"><![CDATA[逆元]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4554/Luogu2825][Tjoi2016&amp;Heoi2016]游戏（网络流，二分图）</title>
		<link>http://sycstudio.com/archives/492</link>
		<pubDate>Wed, 07 Feb 2018 12:21:31 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=492</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在2016年，佳缘姐姐喜欢上了一款游戏，叫做泡泡堂。简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者躲开对手的炸弹。在玩游戏的过程中，小H想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。给定一张n&#42;m的网格地图:其中&#42;代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。x代表软石头，炸弹的威力可以穿透，不能在此放置炸弹。#代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出1&#42;4的网格地图&#42;xx&#42;，这个地图上最多只能放置一个炸弹。给出另一个1&#42;4的网格地图&#42;x#&#42;，这个地图最多能放置两个炸弹。现在小H任意给出一张n&#42;m的网格地图，问你最多能放置多少炸弹

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4554">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2825">Luogu</a>

<h3>Tag</h3>

网络流，二分图

<h2>解决思路</h2>

若没有硬石头的限制，就是一个比较简单的二分图模型，对于每一行每一列连边求最大匹配即可。
但由于有了硬石头的限制，我们可以把每一行以硬石头为界分成若干块，每一列同理，相当于拆点，再按照二分图模型连边。
这里就用网络流了。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxMap=52;
const int maxN=maxMap*maxMap*2;
const int maxM=maxN*20;
const int inf=2147483647;

class Edge
{
public:
    int v,flow;
};

int n,m,S,T;
char Input[maxMap][maxMap];
int Idx[maxMap][maxMap],Idy[maxMap][maxMap];
int nodecnt=0,edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
bool Con[maxN];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,int flow);
bool Bfs();
int dfs(int u,int flow);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%s",Input[i]+1);
    for (int i=1;i&lt;=n;i++)//接下来这两个循环分别把行和列分成若干快
        for (int j=1;j&lt;=m;j++)
        {
            if (Input[i][j]=='#')
            {
                Idx[i][j]=-1;
                continue;
            }
            if ((j==1)||(Input[i][j-1]=='#'))
            {
                Idx[i][j]=++nodecnt;
                continue;
            }
            Idx[i][j]=nodecnt;
        }
    for (int j=1;j&lt;=m;j++)
        for (int i=1;i&lt;=n;i++)
        {
            if (Input[i][j]=='#')
            {
                Idy[i][j]=-1;
                continue;
            }
            if ((i==1)||(Input[i-1][j]=='#'))
            {
                Idy[i][j]=++nodecnt;
                continue;
            }
            Idy[i][j]=nodecnt;
        }
    S=nodecnt+1;T=nodecnt+2;
    for (int i=1;i&lt;=n;i++)//二分图连边
        for (int j=1;j&lt;=m;j++)
        {
            if (Input[i][j]=='#') continue;
            if (Input[i][j]=='*') Add_Edge(Idx[i][j],Idy[i][j],1);
            if (Input[i][j]=='*')
            {
                if (Con[Idx[i][j]]==0)
                {
                    Con[Idx[i][j]]=1;
                    Add_Edge(S,Idx[i][j],1);
                }
                if (Con[Idy[i][j]]==0)
                {
                    Con[Idy[i][j]]=1;
                    Add_Edge(Idy[i][j],T,1);
                }
            }
        }
    int Ans=0;//求解最大流
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (int di=dfs(S,inf)) Ans+=di;
    }
    printf("%d\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
    }
    while (t!=h);
    if (Depth[T]==-1) return 0;
    return 1;
}

int dfs(int u,int flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((E[i].flow&gt;0)&amp;&amp;(Depth[E[i].v]==Depth[u]+1))
        {
            int di=dfs(E[i].v,min(flow,E[i].flow));
            if (di)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>492</wp:post_id>
		<wp:post_date><![CDATA[2018-02-07 20:21:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-07 12:21:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4554-luogu2825tjoi2016heoi2016%e6%b8%b8%e6%88%8f%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e4%ba%8c%e5%88%86%e5%9b%be%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3993/Luogu3324][SDOI2015]星际战争（网络流，二分）</title>
		<link>http://sycstudio.com/archives/493</link>
		<pubDate>Wed, 07 Feb 2018 12:26:56 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=493</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

3333年，在银河系的某星球上，X军团和Y军团正在激烈地作战。在战斗的某一阶段，Y军团一共派遣了N个巨型机器人进攻X军团的阵地，其中第i个巨型机器人的装甲值为Ai。当一个巨型机器人的装甲值减少到0或者以下时，这个巨型机器人就被摧毁了。X军团有M个激光武器，其中第i个激光武器每秒可以削减一个巨型机器人Bi的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y军团看到自己的巨型机器人被X军团一个一个消灭，他们急需下达更多的指令。为了这个目标，Y军团需要知道X军团最少需要用多长时间才能将Y军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3993">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3324">Luogu</a>

<h3>Tag</h3>

网络流，二分

<h2>解决思路</h2>

二分需要多少时间，转化成判定型问题。
网络流建模，从源点连到激光武器容量为这段时间武器总共的攻击输出（没错你没有看错容量是实数），从巨型机器人连到汇点连机器人的血量。求最大流看是否与血量之和相等。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define ld long double
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=120;
const int maxM=maxN/2*maxN/2*10;
const ld eps=1e-5;
const int inf=500000;

class Edge
{
public:
    int v;ld flow;
};

int n,m,S,T;
int A[maxN],B[maxN];
int sumA;
int Atta[51][51];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
int Depth[maxN],Queue[maxN],cur[maxN];

void Add_Edge(int u,int v,ld flow);
bool Check(ld tim);
bool Bfs();
ld dfs(int u,ld flow);

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]),sumA+=A[i];
    for (int i=1;i&lt;=m;i++) scanf("%d",&amp;B[i]);
    S=n+m+1;T=n+m+2;
    for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=n;j++) scanf("%d",&amp;Atta[i][j]);
    ld l=0,r=50100;
    ld Ans=0;
    do
    {
        ld mid=(l+r)/(ld)2;
        if (Check(mid)) Ans=mid,r=mid-eps;
        else l=mid+eps;
    }
    while (fabs(r-l)&gt;=eps);
    printf("%.6LF\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,ld flow)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].v=v;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].v=u;E[edgecnt].flow=0;
    return;
}

bool Check(ld tim)//二分判定
{
    edgecnt=-1;mem(Head,-1);
    for (int i=1;i&lt;=n;i++) Add_Edge(i+m,T,(ld)A[i]);
    for (int i=1;i&lt;=m;i++) Add_Edge(S,i,(ld)B[i]*tim);
    for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=n;j++) if (Atta[i][j]) Add_Edge(i,j+m,inf);
    ld mxflow=0;
    while (Bfs())
    {
        for (int i=1;i&lt;=T;i++) cur[i]=Head[i];
        while (1)
        {
            ld di=dfs(S,inf);
            mxflow+=di;
            if (fabs(di)&lt;=eps) break;
        }
    }
    if (fabs(mxflow-sumA)&lt;=eps) return 1;
    return 0;
}

bool Bfs()
{
    mem(Depth,-1);
    int h=1,t=0;Queue[1]=S;Depth[S]=1;
    do
    {
        int u=Queue[++t];
        for (int i=Head[u];i!=-1;i=Next[i])
        {
            if ((fabs(E[i].flow)&gt;=eps)&amp;&amp;(Depth[E[i].v]==-1))
                Depth[Queue[++h]=E[i].v]=Depth[u]+1;
        }
    }
    while (h!=t);
    if (Depth[T]==-1) return 0;
    return 1;
}

ld dfs(int u,ld flow)
{
    if (u==T) return flow;
    for (int &amp;i=cur[u];i!=-1;i=Next[i])
        if ((Depth[E[i].v]==Depth[u]+1)&amp;&amp;(fabs(E[i].flow)&gt;eps))
        {
            ld di=dfs(E[i].v,min(flow,E[i].flow));
            if (fabs(di)&gt;eps)
            {
                E[i].flow-=di;
                E[i^1].flow+=di;
                return di;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>493</wp:post_id>
		<wp:post_date><![CDATA[2018-02-07 20:26:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-07 12:26:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3993-luogu3324sdoi2015%e6%98%9f%e9%99%85%e6%88%98%e4%ba%89%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e4%ba%8c%e5%88%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU1512/ZOJ2334/SCU3080/Luogu1456]Monkey King（左偏树，并查集）</title>
		<link>http://sycstudio.com/archives/494</link>
		<pubDate>Wed, 07 Feb 2018 13:40:46 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=494</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Once in a forest, there lived N aggressive monkeys. At the beginning, they each does things in its own way and none of them knows each other. But monkeys can't avoid quarrelling, and it only happens between two monkeys who does not know each other. And when it happens, both the two monkeys will invite the strongest friend of them, and duel. Of course, after the duel, the two monkeys and all of there friends knows each other, and the quarrel above will no longer happens between these monkeys even if they have ever conflicted.
Assume that every money has a strongness value, which will be reduced to only half of the original after a duel(that is, 10 will be reduced to 5 and 5 will be reduced to 2).
And we also assume that every monkey knows himself. That is, when he is the strongest one in all of his friends, he himself will go to duel.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-1512">HDU</a>
<a href="https://vjudge.net/problem/ZOJ-2334">ZOJ</a>
<a href="https://vjudge.net/problem/SCU-3080">SCU</a>
<a href="https://www.luogu.org/problemnew/show/P1456">Luogu</a>

<h3>Tag</h3>

左偏树，并查集

<h2>题目大意</h2>

有若干只猴子，开始互相都不认识，两只不认识的猴子会从让它们认识的猴子中最厉害的猴子来打一架，然后就互相认识了。打架的猴子厉害值除以二，求每一次打完架后这些刚刚认识的猴子中最厉害的。

<h2>解决思路</h2>

左偏树实现可并堆，每次取堆顶分离出来，除以二再加进去，合并堆。并查集维护一只猴子所在的堆的根方便查找。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int inf=2147483647;

class HeapData
{
public:
    int key;
    int ch[2],dis;
    void init()
        {
            ch[0]=ch[1]=dis=0;
            return;
        }
};

int n,m;
int UFS[maxN];//并查集
HeapData H[maxN];

int Merge(int x,int y);//左偏树合并
void Div(int x);//把x(保证是一棵左偏树的根)的值除以二再放回去
int Find(int x);

int main()
{
    while (scanf("%d",&amp;n)!=EOF)
    {
        for (int i=1;i&lt;=n;i++) scanf("%d",&amp;H[i].key),H[i].init(),UFS[i]=i;
        int m;scanf("%d",&amp;m);
        while (m--)
        {
            int x,y;scanf("%d%d",&amp;x,&amp;y);
            if (Find(x)==Find(y))
            {
                printf("-1\n");
                continue;
            }
            x=Find(x);y=Find(y);
            if (H[x].key&lt;H[y].key) swap(x,y);
            Div(x);Div(y);x=Find(x);y=Find(y);//堆顶除以二后再找到新的堆顶
            int nrt=Merge(x,y);//合并
            UFS[x]=UFS[y]=nrt;
            printf("%d\n",H[nrt].key);
        }
    }
}

int Merge(int x,int y)
{
    if (x==0) return y;
    if (y==0) return x;
    if (H[x].key&lt;H[y].key) swap(x,y);
    H[x].ch[1]=Merge(H[x].ch[1],y);
    if (H[H[x].ch[0]].dis&lt;H[H[x].ch[1]].dis) swap(H[x].ch[0],H[x].ch[1]);
    if (H[x].ch[1]) H[x].dis=H[H[x].ch[1]].dis+1;
    else H[x].dis=0;
    return x;
}

void Div(int x)
{
    if ((H[x].ch[0]==0)&amp;&amp;(H[x].ch[1]==0))//特判只有一个元素的情况
    {
        H[x].key/=2;
        return;
    }
    int nrt=Merge(H[x].ch[0],H[x].ch[1]);//先把左右子树合并
    UFS[nrt]=nrt;UFS[x]=x;//修改并查集
    if (nrt==H[x].ch[0]) if (H[x].ch[1]) UFS[H[x].ch[1]]=nrt;
    if (nrt==H[x].ch[1]) if (H[x].ch[0]) UFS[H[x].ch[0]]=nrt;
    H[x].init();H[x].key/=2;//分离出来后，处理根
    int nnrt=Merge(x,nrt);//再把根合并回去
    UFS[nrt]=UFS[x]=nnrt;//再修改并查集关系
    return;
}

int Find(int x)
{
    if (UFS[x]!=x) UFS[x]=Find(UFS[x]);
    return UFS[x];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>494</wp:post_id>
		<wp:post_date><![CDATA[2018-02-07 21:40:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-07 13:40:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu1512-zoj2334-scu3080-luogu1456monkey-king%ef%bc%88%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%8c%e5%b9%b6%e6%9f%a5%e9%9b%86%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="post_tag" nicename="scu"><![CDATA[SCU]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="scu"><![CDATA[SCU]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="category" nicename="zoj"><![CDATA[ZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[SNMOJ280]Atom-wwt by dsl</title>
		<link>http://sycstudio.com/archives/500</link>
		<pubDate>Sat, 10 Feb 2018 14:55:31 +0000</pubDate>
		<dc:creator><![CDATA[dsl2002]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=500</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Description</h1>

<a href="http://sycstudio.com/prob" title="题面">题面</a>

<h1>Solution</h1>

考虑到一个串是一个子串的情况只可能是他在 &#92;(fail&#92;) 树上的祖先或者是回文树上的祖先。

所以把回文树和&#92;(fail&#92;)树拼在一起，每次二分最大权值，跑最长反链覆盖，判断覆盖数是否大于等于 &#92;(k&#92;) 即可。

<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;
const int maxn = 100005, Maxn = 1000005, Inf = 1 &lt;&lt; 30;

struct edge {
    int nt, to, flow, cap; 
} g[3000005];
struct Edge{
    int u,v; 
} e[1000005];

int head[maxn], q[maxn], d[maxn], a[maxn], S, T, n, k, cnt, num, ans;
char s[maxn];

inline int gi()
{
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') c = getchar();
    int sum = 0;
    while('0' &lt;= c &amp;&amp; c &lt;= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

int len[maxn], fail[maxn], ch[maxn][26], mxl[maxn], tot, last;

inline void add(int n, int c)
{
    int x = last; 
    while (s[n - len[x] - 1] != s[n]) x = fail[x];
    if (!ch[x][c]) {
        int v = ++tot, k = fail[x]; 
        while (s[n - len[k] - 1] != s[n]) k = fail[k];
        fail[v] = ch[k][c]; len[v] = len[x] + 2; ch[x][c] = v;
    }
    last = ch[x][c]; return;
}

inline void insert(int from, int to, int cap)
{
    g[++num] = (edge) {head[from], to, 0, cap}; head[from] = num;
    g[++num] = (edge) {head[to], from, 0, 0}; head[to] = num;
}

int bfs(int S, int T)
{
    memset(d, 0, sizeof(int) * (T + 1));
    int h = 0, t = 1; q[t] = S; d[S] = 1;
    while (h &lt; t) {
        int x = q[++h], v;
        for (int i = head[x]; i; i = g[i].nt) {
            v = g[i].to;
            if (!d[v] &amp;&amp; g[i].cap &gt; g[i].flow) {
                d[v] = d[x] + 1; q[++t] = v;
                if (v==T) return 1;
            }
        }
    }
    return d[T];
}

inline int dfs(int x, int T, int a)
{
    if (!a || x == T) return a; 
    int f, flow = 0;
    for(int i =head[x], v; i; i = g[i].nt) 
        if (d[v = g[i].to] == d[x] + 1 &amp;&amp; g[i].cap &gt; g[i].flow) {
            f = dfs(v, T, min(a, g[i].cap - g[i].flow));
            if (!f) {d[v] = -1; continue;}
            g[i].flow += f; g[i ^ 1].flow -= f;
            flow += f; a -= f; if (!a) return flow;
        }
    return flow;
}

inline bool check(int key)
{
    memset(head, 0, sizeof(head));
    num = 1; S = 2 * tot + 1; T = S + 1; 
    int sum = 0;
    for (int i = 2; i &lt;= tot; ++i) {
        if (mxl[i] &gt;= key) ++sum, insert(S, i, 1), insert(i + tot, T, 1);
        insert(i + tot, i, Inf);
    }
    for (int i = 1; i &lt;= cnt; ++i) insert(e[i].u, e[i].v + tot, 1);
    int flow = 0; 
    while (bfs(S, T)) flow += dfs(S, T, Inf);
    return sum - flow &gt;= k;
}

#define mid ((l + r) &gt;&gt; 1)
int main()
{
    freopen("atom.in", "r", stdin);
    freopen("atom.out", "w", stdout);
    n=gi(); k=gi(); scanf("%s", s + 1);
    for (int i = 1; i &lt;= n; ++i) a[i] = gi();
    len[fail[0] = tot = 1] = -1;
    for (int i = 1; i &lt;= n; ++i)
        add(i, s[i] - 'a'), mxl[last] = max(mxl[last], a[i]);

    for (int i=tot;i;--i)
        mxl[fail[i]]=max(mxl[fail[i]],mxl[i]);

    for(int i = tot; i; --i)
        mxl[fail[i]] = max(mxl[fail[i]], mxl[i]);

    for (int i = 2; i &lt;= tot; ++i)
        for (int j = 0; j &lt; 26; ++j)
            if (ch[i][j]) e[++cnt] = (Edge) {i, ch[i][j]};

    for (int i = tot; i; --i) if (fail[i]) e[++cnt] = (Edge) {fail[i], i};
    sort(a + 1, a + n + 1), n = unique(a + 1, a + n + 1) -  a - 1; 
    int l = 1, r = n, ans = 0;
    while (l &lt;= r) {
        if (check(a[mid])) ans = a[mid], l = mid + 1; 
        else r = mid - 1;
    }

    if (ans) printf("%d\n", ans);
    else puts("NEGATIVE"); 

    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>500</wp:post_id>
		<wp:post_date><![CDATA[2018-02-10 22:55:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-10 14:55:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[snmoj280atom-wwt]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%9e%e6%96%87%e6%a0%91-%e5%9b%9e%e6%96%87%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[回文树/回文自动机]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="post_tag" nicename="snmoj"><![CDATA[SNMOJ]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1061/Luogu3980][Noi2008]志愿者招募（网络流，单纯型）</title>
		<link>http://sycstudio.com/archives/502</link>
		<pubDate>Sun, 11 Feb 2018 14:26:50 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=502</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要N 天才能完成，其中第i 天至少需要Ai 个人。 布布通过了解得知，一共有M 类志愿者可以招募。其中第i 类可以从第Si 天工作到第Ti 天，招募费用是每人Ci 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1061">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3980">Luogu</a>

<h3>Tag</h3>

网络流，单纯型

<h2>解决思路</h2>

又是一道网络流神题。先看一个例子
假设总共&#92;(5&#92;)天，有四类志愿者，分别是&#92;(1-2,1-5,2-4,3-5&#92;)，设&#92;(P[i]&#92;)表示第&#92;(i&#92;)天需要的人数，&#92;(P[i]'&#92;)表示第&#92;(i&#92;)天实际的人数，&#92;(X[i]&#92;)表示第&#92;(i&#92;)类志愿者的人数，则有下列不等式组
&#92;[P[1]'=X[1]+X[2]>=P[1] &#92;&#92; P[2]'=X[1]+X[2]+X[3]>=P[2] &#92;&#92; P[3]'=X[2]+X[3]+X[4]>=P[3] &#92;&#92; P[4]'=X[2]+X[3]+X[4]>=P[4] &#92;&#92; P[5]'=X[2]+X[4]>=P[5]&#92;]
对每一个式子补充一个&#92;(Y[i]&#92;)把不等式变成等式
&#92;[P[1]'=X[1]+X[2]-Y[1]=P[1] &#92;&#92; P[2]'=X[1]+X[2]+X[3]-Y[2]=P[2] &#92;&#92; P[3]'=X[2]+X[3]+X[4]-Y[3]=P[3] &#92;&#92; P[4]'=X[2]+X[3]+X[4]-Y[4]=P[4] &#92;&#92; P[5]'=X[2]+X[4]-Y[5]=P[5]&#92;]
设有&#92;(P[0]=P[6]=0&#92;)，相邻两式相减，得到
&#92;[P[1]'-P[0]'=X[1]+X[2]-Y[1]=P[1] &#92;&#92; P[2]'-P[1]'=X[3]-Y[2]+Y[1]=P[2]-P[1] &#92;&#92; P[3]'-P[2]'=X[4]-Y[3]-X[1]+Y[2]=P[3]-P[2] &#92;&#92; P[4]'-P[3]'=-Y[4]+Y[3]=P[4]-P[3] &#92;&#92; P[5]'-P[4]'=-Y[5]-X[3]+Y[4]=P[5]-P[4] &#92;&#92; P[6]'-P[5]'=-X[2]-X[4]+Y[5]=-P[5] &#92;]
发现，每一个&#92;(X[i]&#92;)和每一个&#92;(Y[i]&#92;)都在这些式子中恰好出现了一次。并且这些式子的和为&#92;(0&#92;)，这里有没有想到与网络流的流量平衡有一些关系？
把左边去掉，留下中间的和右边的，移项得到
&#92;[P[1]-X[1]-X[2]+Y[1]=0 &#92;&#92; P[2]-P[1]-X[3]+Y[2]-Y[1]=0 &#92;&#92; P[3]-P[2]-X[4]+Y[3]+X[1]-Y[2]=0 &#92;&#92; P[4]-P[3]+Y[4]-Y[3]=0 &#92;&#92; P[5]-P[4]+Y[5]+X[3]-Y[4]=0 &#92;&#92; P[6]-P[5]+X[2]+X[4]-Y[5]=0&#92;]
这样，把每一个等式看作一个点，前面符号为&#92;(+&#92;)的为流入的流量，符号为&#92;(-&#92;)的为流出的流量，当出入平衡时，这个方程组就有解。而&#92;(P[i]-P[i-1]&#92;)的常数项就相当于与源汇点连的边，这个值为正则是从源点流出来的，否则则是流向汇点的。
观察到对于一类可以从第&#92;(i&#92;)天到第&#92;(j&#92;)天的志愿者，他对应的&#92;(X[]&#92;)在第&#92;(i&#92;)个等式中为负，在第&#92;(j+1&#92;)个等式中为正，那么就从&#92;(i&#92;)到&#92;(j+1&#92;)连一条容量为无穷大费用为志愿者费用的边。对于&#92;(Y[i]&#92;)则同理，只是此时是没有费用的。建完图后跑最小费用流即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1010;
const int maxM=(10100+maxN*2)*2;
const int maxQueue=maxN*10;
const int inf=2147483647;
const ll INF=1e15;

class Edge
{
public:
    ll u,v,flow,w;
};

int n,m,S,T;
int Pl[maxN];
int edgecnt=-1,Head[maxN],Next[maxM];
Edge E[maxM];
ll Dist[maxN],inqueue[maxN],Queue[maxQueue];
ll Flow[maxN],Path[maxN];

void Add_Edge(int u,int v,int flow,int w);
bool spfa();

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);S=n+2;T=n+3;
    for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Pl[i]);
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        Add_Edge(u,v+1,inf,w);//对于每一类志愿者分别连边
    }
    for (int i=1;i&lt;=n+1;i++)
    {
        int p=Pl[i]-Pl[i-1];//对于常数项，讨论正负性分别与源汇点连边
        if (p&gt;=0) Add_Edge(S,i,p,0);
        if (p&lt;0) Add_Edge(i,T,-p,0);
        if (i&gt;1) Add_Edge(i,i-1,inf,0);//这里连Y的边
    }
    ll Ans=0;
    while (spfa())
    {
        Ans=Ans+Dist[T]*Flow[T];
        int now=T;
        while (now!=S)
        {
            E[Path[now]].flow-=Flow[T];
            E[Path[now]^1].flow+=Flow[T];
            now=E[Path[now]].u;
        }
    }
    printf("%lld\n",Ans);
    return 0;
}

void Add_Edge(int u,int v,int flow,int w)
{
    //cout&lt;&lt;"Add:"&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;flow&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;E[edgecnt].u=u;E[edgecnt].v=v;E[edgecnt].w=w;E[edgecnt].flow=flow;
    edgecnt++;Next[edgecnt]=Head[v];Head[v]=edgecnt;E[edgecnt].u=v;E[edgecnt].v=u;E[edgecnt].w=-w;E[edgecnt].flow=0;
    return;
}

bool spfa()
{
    mem(inqueue,0);
    for (int i=1;i&lt;=T;i++) Dist[i]=INF;
    int h=1,t=0;Queue[1]=S;Dist[S]=0;inqueue[S]=1;Flow[S]=inf;
    do
    {
        t++;if (t&gt;=maxQueue) t=0;
        int u=Queue[t];
        //cout&lt;&lt;"u:"&lt;&lt;u&lt;&lt;endl;
        for (int i=Head[u];i!=-1;i=Next[i])
        {
            //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;E[i].v&lt;&lt;" "&lt;&lt;E[i].flow&lt;&lt;" "&lt;&lt;E[i].w&lt;&lt;endl;
            if ((E[i].flow&gt;0)&amp;&amp;(Dist[E[i].v]&gt;Dist[u]+E[i].w))
            {
                Dist[E[i].v]=Dist[u]+E[i].w;
                Path[E[i].v]=i;Flow[E[i].v]=min(Flow[u],E[i].flow);
                if (inqueue[E[i].v]==0)
                {
                    h++;if (h&gt;=maxQueue) h=0;
                    inqueue[Queue[h]=E[i].v]=1;
                }
            }
        }
        inqueue[u]=0;
    }
    while (t!=h);
    //for (int i=1;i&lt;=T;i++) cout&lt;&lt;Dist[i]&lt;&lt;" ";cout&lt;&lt;endl;
    if (Dist[T]==INF) return 0;
    return 1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>502</wp:post_id>
		<wp:post_date><![CDATA[2018-02-11 22:26:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-11 14:26:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1061-luogu3980noi2008%e5%bf%97%e6%84%bf%e8%80%85%e6%8b%9b%e5%8b%9f%ef%bc%88%e7%bd%91%e7%bb%9c%e6%b5%81%ef%bc%8c%e5%8d%95%e7%ba%af%e5%9e%8b%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3140/Luogu3231][Hnoi2013]消毒（二分图）</title>
		<link>http://sycstudio.com/archives/503</link>
		<pubDate>Sun, 11 Feb 2018 15:08:23 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=503</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

最近在生物实验室工作的小T遇到了大麻烦。
由于实验室最近升级的缘故，他的分格实验皿是一个长方体,其尺寸为a&#42;b&#42;c，a、b、c 均为正整数。为了实验的方便，它被划分为a&#42;b&#42;c个单位立方体区域，每个单位立方体尺寸为1&#42;1&#42;1。用(i,j,k)标识一个单位立方体，1 ≤i≤a，1≤j≤b，1≤k≤c。这个实验皿已经很久没有人用了，现在，小T被导师要求将其中一些单位立方体区域进 行消毒操作（每个区域可以被重复消毒）。而由于严格的实验要求，他被要求使用一种特定 的F试剂来进行消毒。 这种F试剂特别奇怪，每次对尺寸为x&#42;y&#42;z的长方体区域（它由x&#42;y&#42;z个单位立方体组 成）进行消毒时，只需要使用min{x,y,z}单位的F试剂。F试剂的价格不菲，这可难倒了小 T。现在请你告诉他，最少要用多少单位的F试剂。(注：min{x,y,z}表示x、y、z中的最小 者。)

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3140">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3231">Luogu</a>

<h3>Tag</h3>

二分图

<h2>解决思路</h2>

首先要知道，不需要消毒的地方也是可以消毒的！这是前提。
考虑如果某一维我们取&#92;(1&#92;)，那么剩下的两维取最大是最优的，那么也就是说我们可以一次消毒一层。
那么如果是两维，根据上面的贪心，我们每一次消掉一行或一列是最优的，那么这就变成了选择若干行或若干列使得所有需要消毒的格子都被包含进去。把行和列分别看作两个集合，对于需要消毒的格子&#92;(x,y&#92;)，从行的&#92;(x&#92;)连边到&#92;(y&#92;)，求最小点覆盖，即选出最少的点使得所有的边都至少有一个端点在点集中。在二分图中，最小点覆盖&#92;(=&#92;)最大匹配。所以对于二维的，直接匈牙利算法求解最大匹配。
但现在是三维，那么会出现的情况就是某几层可能是直接一层一层消去的，考虑到&#92;(a&#42;b&#42;c&#92;)最多只有&#92;(5000&#92;)，也就是说这三个数中最小的不会超过&#92;(17&#92;)，那么可以枚举最小这一维，枚举其中每一层是直接一层地消毒还是用另外两维来消。直接消的就统计层数即可，剩下的由于我们上面的贪心原则，可以把剩下的所有面全部压缩到一个平面上，这样就变成二维的情况了，运用匈牙利算法解决。
注意在应该&#92;(continue&#92;)的地方都要可行性剪枝。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=6000;
const int maxM=maxN*2;
const int inf=2147483647;

class Pos
{
public:
    int x,y,z;
};

int a,b,c,nodecnt,nowdepth=0;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
int vis[maxN],Match[maxN];
Pos P[maxN];

void Add_Edge(int u,int v);
int dfs(int u);

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        nodecnt=0;
        scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
        for (int i=1;i&lt;=a;i++) for (int j=1;j&lt;=b;j++) for (int k=1;k&lt;=c;k++)
                                                      {
                                                          int opt;scanf("%d",&amp;opt);
                                                          if (opt==1) P[++nodecnt]=(Pos){i,j,k};
                                                      }
        //这里是为了保证a&lt;b&lt;c，方便后面的枚举
        if (a&gt;b){
            swap(a,b);for (int i=1;i&lt;=nodecnt;i++) swap(P[i].x,P[i].y);
        }
        if (a&gt;c){
            swap(a,c);for (int i=1;i&lt;=nodecnt;i++) swap(P[i].x,P[i].z);
        }
        if (b&gt;c){
            swap(b,c);for (int i=1;i&lt;=nodecnt;i++) swap(P[i].y,P[i].z);
        }
        int Ans=inf;
        for (int S=0;S&lt;(1&lt;&lt;a);S++)//枚举哪些层直接整层消毒
        {
            edgecnt=0;for (int i=1;i&lt;=c;i++) Head[i]=Match[i]=-1;
            int ret=0;
            for (int i=1;i&lt;=a;i++) if ((S&amp;(1&lt;&lt;(i-1)))!=0) ret++;//直接消毒的，每一层的代价都是1
            if (ret&gt;=Ans) continue;
            for (int i=1;i&lt;=nodecnt;i++) if ((S&amp;(1&lt;&lt;(P[i].x-1)))==0) Add_Edge(P[i].y,P[i].z);//建二分图
            for (int i=1;i&lt;=c;i++)//匈牙利算法
            {
                nowdepth++;
                ret+=dfs(i);
                if (ret&gt;=Ans) break;
            }
            Ans=min(Ans,ret);
        }
        printf("%d\n",Ans);
    }
    return 0;
}

int dfs(int u)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]!=nowdepth)
        {
            vis[V[i]]=nowdepth;
            if ((Match[V[i]]==-1)||(dfs(Match[V[i]])))
            {
                Match[V[i]]=u;return 1;
            }
        }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>503</wp:post_id>
		<wp:post_date><![CDATA[2018-02-11 23:08:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-11 15:08:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3140-luogu3231hnoi2013%e6%b6%88%e6%af%92%ef%bc%88%e4%ba%8c%e5%88%86%e5%9b%be%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>后缀自动机的一点点理解 by yyb</title>
		<link>http://sycstudio.com/archives/505</link>
		<pubDate>Tue, 13 Feb 2018 03:04:19 +0000</pubDate>
		<dc:creator><![CDATA[yyb]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=505</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>后缀自动机的一点点理解</h1>

<a href="http://www.cnblogs.com/cjyyb/p/8446205.html">潜在可能格式挂了，yyb博客地址</a>

<h2>前言</h2>

最近心血来潮，想学学SAM，于是花了一晚上+一上午
勉强打了出来（但是还是不理解）
虽说张口就讲我做不到
但是一些其他的东西还是有所感触的
索性，乱口胡点东西，谢谢关于SAM的一些简单的理解

<h2>资料</h2>

<a href="https://max.book118.com/html/2016/1007/57498384.shtm">丽洁姐WC PPT</a>
<a href="http://hihocoder.com/problemset/problem/1441">hihocoder上的后缀自动机</a>

<h2>一些概念</h2>

这些概念都不读懂，接下来真的是步履维艰

本来我们要的是一个能够处理所有后缀的数据结构
但是我们发现，如果对于每一个后缀都要插入进Trie树
空间复杂度完全背不动（$$O(n^2)$$级别）
于是，后缀自动机出现了
后缀自动机相比于Trie树
在空间上有了很大的改善，他的空间复杂度是$$O(n)$$级别的
（详见丽洁姐的PPT）

杂七杂八的没有什么太多写的必要，网上一找一大堆
写写一些概念

<h3>right/endpos</h3>

hihocoder上写的是$$endpos$$集合
其他的大部分地方写的是$$right$$集合
这就是最基础的概念了
叫做$$endpos$$的话应该很好理解，所以我就写$$endpos$$吧
$$endpos$$就是一个子串结束位置组成的集合
对于所有结束位置相同的子串
也就是$$endpos$$相同的两个子串
他们一个一定是另一个的后缀

至于证明，简单的想一下，如果一个子串出现在了若干个位置
那么他的后缀也一定出现在了这些位置（只可能出现在更多未知，不可能更少）

同时，得到了一个推论：
两个字符串如果有一个是另一个的后缀，
那么，较长串的$$endpos$$一定是较短串的$$endpos$$的子集
（就是上面写的，只可能多，不可能少）
同样的，如果没有后缀的关系，那么它们的$$endpos$$的交集一定是空集

而后缀自动机的每个节点就是依照$$endpos$$来划分
对于$$endpos$$相同的子串，我们可以划分在一起
我们不难得出一点，对于一堆$$endpos$$相同的子串
他们一定互为后缀，并且他们长度连续

首先证明互为后缀，那就是上面的那个推论，
如果不是互为后缀的话，$$endpos$$就不可能相等
而长度连续？
既然互为后缀，那就一定有一个最长的串，不妨记为$$longest$$
那么，所有的其他串一定是他的后缀
随着后缀长度的减小，
那么从某一个后缀开始，就可能出现在了更多的位置
那么，这个后缀以及比它更短的后缀的$$endpos$$一定会变大
此时他们就会分到别的节点去了
因此，具有相同$$endpos$$的子串一定长度连续，互为后缀
另外一个简单的结论，确定了$$endpos$$和长度$$len$$就能确定唯一的子串

<h3>trans</h3>

$$trans$$不难理解是转移的意思
设$$trans(s,c)$$表示当前在$$s$$状态，接受一个字符$$c$$之后所到达的状态
一个状态$$s$$表示若干$$endpos$$相同的连续子串
那么，此时相当于在后面加上了一个字符$$c$$
那么，我们对于任意一个串直接加上一个字符$$c$$之后
组成的串的$$endpos$$还是相同的
所以$$trans(s,c)$$就会指向这个状态
换句话说，随便在当前状态$$s$$中找一个串（比如$$longest$$）
然后在后面接上一个$$c$$
那么，就指向包含这个新字符串的状态

<h3>Parent/Suffix Links</h3>

本质上也是一个东西，不同的地方写的不一样而已
不妨设一个状态中包含的最短的串叫做$$shortest$$
那么，我们就知道$$shortest$$的任意一个非自己的后缀一定就会出现在了更多位置
他的最长的那个后缀，也就是减去了第一个字符后的串
就会出现在另外一个状态里面，并且是那个状态的$$longest$$
为什么？因为出现在了更多的位置，我们还是知道他是连续的子串
如果存在一个更长的串
那么，只可能是当前状态的$$shortest$$，
但是$$shortest$$属于当前状态，而没有出现在更多的位置
因此，$$longest$$一定是当前状态的$$shortest$$减去最前面字符形成的串

那么，当前位置的$$parent$$就会指向那个状态

当然，还是有几个很有趣的性质
假设当状态是$$s$$
$$s.shortest.len=parent.longest.len+1$$
这个就是前面所说的东西，所以，对于每个状态，就没有必要记录$$shortest$$
因为你只要知道$$parent$$就可以算出来了

其次，$$s$$的$$endpos$$是$$parent$$的子集
这个不难证明，因为$$parent$$包含了更多的位置

如果$$trans(s,c)\neq NULL$$
那么，$$trans(parent,c)\neq NULL$$
因为如果$$trans(s,c)$$存在这个状态
那么$$parent$$的串加上$$c$$之后，一定还是$$s+c$$后的后缀
所以也一定存在$$trans(parent,c)$$
所以，你可以认为$$parent$$是一个完全包含了$$s$$的状态
也正因为如此，$$parent$$的$$endpos$$就是所有儿子$$endpos$$的并集

将所有的$$parent$$反过来，我们就得到了$$parent$$树
如果要处理什么，就需要$$parent$$树的拓扑序
（因为$$parent$$相当于包含了所有的他的子树，都需要更新上去）
其实不需要拓扑排序
我们知道$$s$$的$$endpos$$完全被$$parent$$的$$endpos$$包含
$$s.longest$$一定长于$$parent.longest$$
所以，一个状态的$$longest$$越长，它一定要被更先访问
所以，按照$$longest$$的长度进行桶排序就可以解决拓扑序了

<h3>extend</h3>

对于一个$$SAM$$的构造
我们当然在线了（因为我只会这个）
我们依次加入字符$$c$$，来进行构造

假设原来的字符串是$$T$$
首先，一定会有一个新节点
因为新加入了一个字符后，一定出现了这个新的字符串$$T+c$$
此时$$endpos$$一定是新的位置
同时，原来的$$T$$的最后一个位置也可以通过$$+c$$变到这个新位置
设原来的最后一个位置的状态是$$last$$，新的状态是$$np$$
所以$$trans(last,c)=np$$
根据前面的东西，我们知道$$last$$的祖先们一定也会有这个$$trans$$
我们要怎么解决他呀

令$$p=last$$
一直沿着$$parent$$往前跳，也就是不断令$$p=p.parent$$
所以$$p$$代表的，就是越来越短的$$T$$的后缀
因为要更新的是最后的位置，
只有当存在$$T$$的最后一个位置时才能更新

如果$$trans(p,c)=NULL$$，直接令$$trans(p,c)=np$$
很显然是可以直接在后面添加一个$$c$$到达$$np$$的
如果跳完后发现没有$$parent$$了，直接把$$np.parent$$指向$$1$$
也就是空串所代表的状态

如果某个$$trans(p,c)$$不为$$NULL$$
那么，设$$q=trans(p,c)$$
如果有$$longest(p)+1=longest(q)$$
什么意思？
在$$p$$的串后面添上一个$$c$$之后就是$$q$$状态
没有任何问题，直接在作为$$T$$的后缀的那一个子串上
直接添加一个$$c$$显然也可以到达$$q$$状态
又因为$$np$$所代表的$$endpos$$更小，
所以$$np.parent=q$$

在否则的话
也就是$$longest(q)>longest(p)+1$$
具体的反例看丽洁姐PPT第$$35$$页
如果直接插入的话（也就是$$np.parent=q$$）
相当于给$$q$$的$$endpos$$强行插入一个$$q$$
但是，我们发现，如果强行插入进去
这个$$T+c$$的后缀会出现在更多的位置，应该属于另外一个状态
然后就$$GG$$了
此时，我们新建一个点$$nq$$
相当于把$$q$$拆成两部分：
一部分是$$T+c$$的那个后缀，一个是$$longest(p)+c$$
也就是$$longest(nq)=longest(p)+1$$
显然$$T+c$$的后缀是包含了状态较少的，
拆分出来的一部分$$q$$是长度较长的
所以$$q.parent=np.parent=nq$$
同时，继续沿着$$p$$的$$parent$$往上走
把所有的$$q$$都替换成$$nq$$

看起来很有道理，但是我也是似懂非懂的感觉

<h2>End</h2>

这就是我自己的一些没有什么用的总结了
我觉得题目才能真正反映SAM的作用
到时候再补点题目上去

补一份后缀自动机$$extend$$的代码

<pre><code class="cpp">int tot=1,last=1;
struct Node
{
    int son[26];
    int ff,len;
}t[MAX&lt;&lt;1];
void extend(int c)
{
    int p=last,np=++tot;last=np;
    t[np].len=t[p].len+1;
    while(p&amp;&amp;!t[p].son[c])t[p].son[c]=np,p=t[p].ff;
    if(!p)t[np].ff=1;
    else
    {
        int q=t[p].son[c];
        if(t[p].len+1==t[q].len)t[np].ff=q;
        else
        {
            int nq=++tot;
            t[nq]=t[q];t[nq].len=t[p].len+1;
            t[q].ff=t[np].ff=nq;
            while(p&amp;&amp;t[p].son[c]==q)t[p].son[c]=nq,p=t[p].ff;
        }
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>505</wp:post_id>
		<wp:post_date><![CDATA[2018-02-13 11:04:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-13 03:04:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%90%8e%e7%bc%80%e8%87%aa%e5%8a%a8%e6%9c%ba%e7%9a%84%e4%b8%80%e7%82%b9%e7%82%b9%e7%90%86%e8%a7%a3-by-yyb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[后缀自动机]]></category>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>95</wp:comment_id>
			<wp:comment_author><![CDATA[zhoushuyu]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[978982520@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.19.61.45]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-13 14:57:36]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-13 06:57:36]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你跑到这里占萝卜坑干嘛]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>7</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>96</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/cjyyb</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.17.180.93]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-13 14:59:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-13 06:59:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这不是您查水表的理由]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>95</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[wpdiscuz_votes]]></wp:meta_key>
				<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>97</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[222.240.92.29]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-13 22:08:38]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-13 14:08:38]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[强！！向yyb学习]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>98</wp:comment_id>
			<wp:comment_author><![CDATA[yyb]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1357828232@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cnblogs.com/cjyyb</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[106.121.69.85]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-13 22:09:48]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-13 14:09:48]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这不是掩盖您是大佬的理由]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>97</wp:comment_parent>
			<wp:comment_user_id>8</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>99</wp:comment_id>
			<wp:comment_author><![CDATA[xzz_233]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xuzhouzi@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.247.55.67]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-14 22:57:00]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-14 14:57:00]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[为什么我自己不膜拜我自己这个巨♂佬]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>98</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>102</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-21 21:07:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-21 13:07:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[难道称赞同学都不行吗]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>99</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[BZOJ4003/Luogu3261][JLOI2015]城池攻占（可并堆，左偏树）</title>
		<link>http://sycstudio.com/archives/507</link>
		<pubDate>Fri, 16 Feb 2018 05:12:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=507</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

小铭铭最近获得了一副新的桌游，游戏中需要用 m 个骑士攻占 n 个城池。
这 n 个城池用 1 到 n 的整数表示。除 1 号城池外，城池 i 会受到另一座城池 fi 的管辖，其中 fi  i。也就是说，所有城池构成了一棵有根树。这 m 个骑士用 1 到 m 的整数表示，其中第 i 个骑士的初始战斗力为 si，第一个攻击的城池为 ci。每个城池有一个防御值 hi，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 1 号城池，或牺牲为止。除 1 号城池外，每个城池 i 会给出一个战斗力变化参数 ai;vi。若 ai =0，攻占城池 i 以后骑士战斗力会增加 vi；若 ai =1，攻占城池 i 以后，战斗力会乘以 vi。注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4003">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3261">Luogu</a>

<h3>Tag</h3>

可并堆，左偏树

<h2>解决思路</h2>

考虑到每一个骑士是单独算的，那么我们可以用堆来维护到达每一个点的骑士的攻击值，弹出那些不能攻占的，剩下的打上乘或加的标记。
那么考虑到有把堆合并的操作，这里采用左偏树实现可并堆。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=300100;
const int inf=2147483647;

class Heap//左偏树
{
public:
    ll key,plus,mul;//plus加标记，mul乘标记
    int ch[2],dis;
    Heap()
        {
            plus=0;mul=1;
            return;
        }
};

int n,m;
int edgecnt=-1,Head[maxN],Next[maxN*2],V[maxN*2];
int Id[maxN];//这里用Id表示树上某个点对应的堆的根节点
ll Def[maxN],Opt[maxN],Val[maxN],Depth[maxN];
int St[maxN],Ed[maxN],Fail[maxN];//St记录每一个骑士出发的点，Ed记录每一个骑士牺牲的点，两点深度之差就是骑士攻占的城市个数，Fail记录在某城市牺牲的骑士个数
Heap H[maxN];

int Merge(int r1,int r2);
void PushDown(int rt);//标记下放
void Mark(int rt,ll plus,ll mul);//标记
void dfs(int u);//dfs从下到上合并

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) scanf("%lld",&amp;Def[i]);
    for (int i=2;i&lt;=n;i++)
    {
        int fa;scanf("%d%lld%lld",&amp;fa,&amp;Opt[i],&amp;Val[i]);
        edgecnt++;Next[edgecnt]=Head[fa];Head[fa]=edgecnt;V[edgecnt]=i;
    }
    for (int i=1;i&lt;=m;i++)
    {
        scanf("%lld%d",&amp;H[i].key,&amp;St[i]);
        if (Id[St[i]]==0) Id[St[i]]=i;
        else Id[St[i]]=Merge(Id[St[i]],i);
    }
    Depth[1]=1;dfs(1);
    for (int i=1;i&lt;=n;i++) printf("%d\n",Fail[i]);
    for (int i=1;i&lt;=m;i++) printf("%lld\n",Depth[St[i]]-Depth[Ed[i]]);
    return 0;
}

int Merge(int r1,int r2)//左偏树合并核心操作
{
    if (r1==0) return r2;
    if (r2==0) return r1;
    PushDown(r1);PushDown(r2);
    if (H[r1].key&gt;H[r2].key) swap(r1,r2);
    H[r1].ch[1]=Merge(H[r1].ch[1],r2);
    if (H[H[r1].ch[0]].dis&lt;H[H[r1].ch[1]].dis) swap(H[r1].ch[0],H[r1].ch[1]);
    if (H[r1].ch[1]) H[r1].dis=H[H[r1].ch[1]].dis+1;
    else H[r1].dis=0;
    return r1;
}

void PushDown(int rt)
{
    if (H[rt].ch[0]) Mark(H[rt].ch[0],H[rt].plus,H[rt].mul);
    if (H[rt].ch[1]) Mark(H[rt].ch[1],H[rt].plus,H[rt].mul);
    H[rt].mul=1;H[rt].plus=0;return;
}

void Mark(int rt,ll plus,ll mul)
{
    H[rt].key=H[rt].key*mul+plus;
    H[rt].plus=H[rt].plus*mul+plus;
    H[rt].mul=H[rt].mul*mul;
    return;
}

void dfs(int u)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        Depth[V[i]]=Depth[u]+1,dfs(V[i]);
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        if (Id[V[i]]==0) continue;
        if (Id[u]==0) Id[u]=Id[V[i]];
        else Id[u]=Merge(Id[u],Id[V[i]]);
    }
    while ((Id[u])&amp;&amp;(H[Id[u]].key&lt;Def[u]))
    {
        Fail[u]++;Ed[Id[u]]=u;
        PushDown(Id[u]);Id[u]=Merge(H[Id[u]].ch[0],H[Id[u]].ch[1]);
    }
    if (Id[u])
    {
        if (Opt[u]==0) Mark(Id[u],Val[u],1);
        if (Opt[u]==1) Mark(Id[u],0,Val[u]);
    }
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>507</wp:post_id>
		<wp:post_date><![CDATA[2018-02-16 13:12:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-16 05:12:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4003-luogu3261jloi2015%e5%9f%8e%e6%b1%a0%e6%94%bb%e5%8d%a0%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1087/Luogu1896][SCOI2005]互不侵犯King（动态规划，状态压缩）</title>
		<link>http://sycstudio.com/archives/508</link>
		<pubDate>Fri, 16 Feb 2018 05:24:07 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=508</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上
左下右上右下八个方向上附近的各一个格子，共8个格子。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1087">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1896">Luogu</a>

<h3>Tag</h3>

动态规划，状态压缩

<h2>解决思路</h2>

设&#92;(F[i][j][S]&#92;)表示处理到第&#92;(i&#92;)行，当前摆放了&#92;(j&#92;)个国王，当前行状态为&#92;(S&#92;)的方案数，枚举上一行的合法方案累加转移即可。
为了方便，可以先预处理出某一行每一种拜访方式是否合法，以及有几个国王。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=10;
const int inf=2147483647;

int n,K;
ll F[maxN][maxN*maxN][1&lt;&lt;maxN];
bool Put[1&lt;&lt;maxN];//标记某一种状态是否可行
int Num[1&lt;&lt;maxN];//某一状态摆了多少个王

int main()
{
    scanf("%d%d",&amp;n,&amp;K);
    for (int i=0;i&lt;(1&lt;&lt;n);i++)//预处理
        if ((i&amp;(i&lt;&lt;1))==0)
        {
            Put[i]=1;
            for (int j=0;j&lt;n;j++) if (((1&lt;&lt;j)&amp;i)!=0) Num[i]++;
            F[1][Num[i]][i]=1;
        }
    for (int i=2;i&lt;=n;i++)
        for (int j=0;j&lt;=K;j++)
            for (int S=0;S&lt;(1&lt;&lt;n);S++)//枚举当前行状态
                if (Put[S]==1)
                    for (int S2=0;S2&lt;(1&lt;&lt;n);S2++)//枚举上一行状态
                        if ((Put[S2]==1)&amp;&amp;((S&amp;S2)==0)&amp;&amp;(j-Num[S]&gt;=0)&amp;&amp;((S&amp;(S2&lt;&lt;1))==0)&amp;&amp;(((S&lt;&lt;1)&amp;S2)==0))
                            F[i][j][S]=(F[i][j][S]+F[i-1][j-Num[S]][S2]);
    ll Ans=0;
    for (int i=0;i&lt;(1&lt;&lt;n);i++) Ans=Ans+F[n][K][i];
    printf("%lld\n",Ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>508</wp:post_id>
		<wp:post_date><![CDATA[2018-02-16 13:24:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-16 05:24:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1087-luogu1896scoi2005%e4%ba%92%e4%b8%8d%e4%be%b5%e7%8a%afking%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%8c%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[状态压缩动态规划]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1801/Luogu2051][Ahoi2009]chess 中国象棋（动态规划）</title>
		<link>http://sycstudio.com/archives/509</link>
		<pubDate>Fri, 16 Feb 2018 05:33:15 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=509</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在N行M列的棋盘上，放若干个炮可以是0个，使得没有任何一个炮可以攻击另一个炮。 请问有多少种放置方法，中国像棋中炮的行走方式大家应该很清楚吧.

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1801">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2051">Luogu</a>

<h3>Tag</h3>

动态规划

<h2>解决思路</h2>

考虑中国象棋中炮的攻击方式，发现其实就是要求任意一行或任意一列不能摆放超过两个炮。并且我们发现，每一个炮具体摆的位置不影响最后的结果，只贡献组合数。那么我们枚举行，考虑列。
设&#92;(F[i][j][k]&#92;)表示当前处理到第&#92;(i&#92;)行，前&#92;(i&#92;)行中，一个炮都没有的列有&#92;(j&#92;)个，只有一个炮的列有&#92;(k&#92;)个，分别转移。
首先，这一行可以什么也不摆，那就直接转移到&#92;(F[i+1][j][k]&#92;)。
可以选择摆一个炮，那么这个炮可以摆在原来一个炮都没有的某一列，转移到&#92;(F[i+1][j-1]&#92;[k+1]&#92;)，并乘上方案数&#92;(j&#92;)；同理，这一个炮也可以摆在原来已经有一个炮的某一列上，转移到&#92;(F[i+1][j][k-1]&#92;)，并乘上方案数&#92;(k&#92;)。
那么摆两个炮的也是同理，分为两个都摆在原来一个炮丢没有的列上、两个都摆在原来已经有一个的列上和一个在没有一个在已经有一个的列上，这三种情况讨论，乘上对应的系数。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101;
const int Mod=9999973;
const int inf=2147483647;

int n,m;
ll F[maxN][maxN][maxN];

ll QPow(ll x,ll cnt);

int main()
{
    int inv2=QPow(2,Mod-2);
    scanf("%d%d",&amp;n,&amp;m);
    F[0][m][0]=1;
    for (ll i=0;i&lt;n;i++)
        for (ll p1=0;p1&lt;=m;p1++)
            for (ll p2=0;p1+p2&lt;=m;p2++)
            {
                if (F[i][p1][p2]==0) continue;
                F[i+1][p1][p2]=(F[i+1][p1][p2]+F[i][p1][p2])%Mod;//什么都不放
                if (p1&gt;=1) F[i+1][p1-1][p2+1]=(F[i+1][p1-1][p2+1]+F[i][p1][p2]*(ll)p1%Mod)%Mod;//在空的某一列摆上一个
                if (p2&gt;=1) F[i+1][p1][p2-1]=(F[i+1][p1][p2-1]+F[i][p1][p2]*(ll)p2%Mod)%Mod;//在有一个的某一列摆上一个
                if (p1&gt;=2) F[i+1][p1-2][p2+2]=(F[i+1][p1-2][p2+2]+1ll*F[i][p1][p2]*p1%Mod*(p1-1ll)%Mod*inv2%Mod)%Mod;//在两列空的上面分别摆上一个
                if (p2&gt;=2) F[i+1][p1][p2-2]=(F[i+1][p1][p2-2]+1ll*F[i][p1][p2]*p2%Mod*(p2-1ll)%Mod*inv2%Mod)%Mod;//在两个已经摆了一个的上面再分别摆一个
                if ((p1&gt;=1)&amp;&amp;(p2&gt;=1)) F[i+1][p1-1][p2]=(F[i+1][p1-1][p2]+1ll*F[i][p1][p2]*p1%Mod*p2%Mod)%Mod;//在空列和摆了一个的一列摆上一个
            }
    int Ans=0;
    for (int p1=0;p1&lt;=m;p1++)
        for (int p2=0;p1+p2&lt;=m;p2++)
            Ans=(Ans+F[n][p1][p2])%Mod;
    printf("%d\n",Ans);
    return 0;
}

ll QPow(ll x,ll cnt)
{
    ll ret=1;
    while (cnt)
    {
        if (cnt&amp;1) ret=ret*x%Mod;
        x=x*x%Mod;
        cnt=cnt&gt;&gt;1;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>509</wp:post_id>
		<wp:post_date><![CDATA[2018-02-16 13:33:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-16 05:33:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1801-luogu2051ahoi2009chess-%e4%b8%ad%e5%9b%bd%e8%b1%a1%e6%a3%8b%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2809/Luogu1552][Apio2012]dispatching（可并堆，左偏树，贪心）</title>
		<link>http://sycstudio.com/archives/511</link>
		<pubDate>Sat, 17 Feb 2018 12:31:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=511</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。
在这个帮派里，有一名忍者被称之为Master。除了Master以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。
现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。
你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。
写一个程序，给定每一个忍者i的上级Bi，薪水Ci，领导力Li，以及支付给忍者们的薪水总预算M，输出在预算内满足上述要求时顾客满意度的最大值。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2809">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1552">Luogu</a>

<h3>Tag</h3>

可并堆，左偏树，贪心

<h2>解决思路</h2>

由于满意度是派遣的忍者总数&#42;管理者的领导水平，并且管理者可以不被派遣，那么得到一个贪心的做法，就是从大往小删去尽量少的忍者，这样就可以保证数量最大。
为了方便取大，可以用堆来实现。又是树的结构，那么就可以用可并堆来实现从儿子向父亲的合并，这里用左偏树实现。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int inf=2147483647;

class Heap
{
public:
    ll key;
    int ch[2],dis;
};

int n,M,root;
int Id[maxN];//Id记录树上编号为i的点对应此时在左偏树中的根
ll Ans,Sum[maxN],Mast[maxN],Size[maxN];//Sum记录和，Size记录忍者数量
Heap H[maxN];
int edgecnt=-1,Head[maxN],Next[maxN*2],V[maxN*2];

void dfs(int u);
int Merge(int r1,int r2);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;M);
    for (int i=1;i&lt;=n;i++)
    {
        Id[i]=i;
        int fa;scanf("%d%lld%lld",&amp;fa,&amp;H[i].key,&amp;Mast[i]);
        if (fa==0){//初始化
            root=i;continue;
        }
        edgecnt++;Next[edgecnt]=Head[fa];Head[fa]=edgecnt;V[edgecnt]=i;
    }
    dfs(root);
    printf("%lld\n",Ans);
    return 0;
}

void dfs(int u)//dfs从下往上求解
{
    Sum[u]=H[u].key;Size[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        dfs(V[i]);
        Sum[u]+=Sum[V[i]];Size[u]+=Size[V[i]];
    }
    for (int i=Head[u];i!=-1;i=Next[i])//合并
        Id[u]=Merge(Id[u],Id[V[i]]);
    while (Sum[u]&gt;M)//删去大的
    {
        Sum[u]-=H[Id[u]].key;Size[u]--;
        Id[u]=Merge(H[Id[u]].ch[0],H[Id[u]].ch[1]);
    }
    Ans=max(Ans,Size[u]*Mast[u]);
    return;
}

int Merge(int r1,int r2)
{
    if (r2==0) return r1;
    if (r1==0) return r2;
    if (H[r1].key&lt;H[r2].key) swap(r1,r2);
    H[r1].ch[1]=Merge(H[r1].ch[1],r2);
    if (H[H[r1].ch[0]].dis&lt;H[H[r1].ch[1]].ch[1]) swap(H[r1].ch[0],H[r1].ch[1]);
    if (H[r1].ch[1]) H[r1].dis=H[H[r1].ch[1]].dis+1;
    else H[r1].dis=0;
    return r1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>511</wp:post_id>
		<wp:post_date><![CDATA[2018-02-17 20:31:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-17 12:31:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2809-luogu1552apio2012dispatching%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%8c%e8%b4%aa%e5%bf%83%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="category" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<category domain="post_tag" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<category domain="category" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ4071/Luogu3644][Apio2015]巴邻旁之桥 （线段树，数论，离散化）</title>
		<link>http://sycstudio.com/archives/512</link>
		<pubDate>Sat, 17 Feb 2018 13:14:40 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=512</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 A 和区域 B。
每一块区域沿着河岸都建了恰好 1000000001 栋的建筑，每条岸边的建筑都从 0 编号到 1000000000。相邻的每对建筑相隔 1 个单位距离，河的宽度也是 1 个单位长度。区域 A 中的 i 号建筑物恰好与区域 B 中的 i 号建筑物隔河相对。
城市中有 N 个居民。第 i 个居民的房子在区域 Pi 的 Si 号建筑上，同时他的办公室坐落在 Qi 区域的 Ti 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 K 座横跨河流的大桥。
由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。当政府建造最多 K 座桥之后，设 Di 表示第 i 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 D1+D2+⋯+DN 最小。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4071">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3644">Luogu</a>

<h3>Tag</h3>

线段树，数论，离散化

<h2>解决思路</h2>

看到&#92;(K&#92;)的数据范围，要根据&#92;(K==1&#92;)和&#92;(K==2&#92;)分别讨论。
先把只在一边的单独算掉，排除在外。
首先&#92;(K==1&#92;)的情况，只有一座桥，那么就是所有人都要经过这个桥，假设这个桥的位置是pos，那么式子就是&#92;(\sum (|A[i]-pos|+|B[i]-pos|)&#92;)，直接把&#92;(A[i]&#92;)和&#92;(B[i]&#92;)放在一起排序求出中位数即可。
然后是&#92;(K==2&#92;)的情况。有了前面的例子，我们可以知道，一个人一定是走离自己两边位置的中位数更近的那一座桥，那么可以把人按照中位数排序，枚举分割成两部分，两部分分别按照&#92;(K==1&#92;)的方式来算。
那么接下来的问题就是动态求中位数，这里用权值线段树的方式来求，具体来说就是找到中间的&#92;(rank&#92;)，分割查看左边的大小与当前要查询的&#92;(rank&#92;)作比较，如果左边大于&#92;(rank&#92;)则走左边，否则走右边，类似于平衡树中求第&#92;(K&#92;)大。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=500100;
const int inf=2147483647;
const ll INF=1e18;

ll size,Num[maxN];//离散化并排序去重后的值域

class Segment//权值线段树
{
public:
    ll S[maxN*4];//记录区间数量和
    ll Sum[maxN*4];//记录区间权值和
    Segment()
        {
            mem(S,0);
        }
    void Modify(int now,int l,int r,int pos,ll opt)//单点修改
        {
            if (l==r){
                S[now]+=opt;Sum[now]+=opt*Num[l];return;
            }
            int mid=(l+r)&gt;&gt;1;
            if (pos&lt;=mid) Modify(now*2,l,mid,pos,opt);
            if (pos&gt;=mid+1) Modify(now*2+1,mid+1,r,pos,opt);
            S[now]=S[now*2]+S[now*2+1];Sum[now]=Sum[now*2]+Sum[now*2+1];
            return;
        }
    int GetMid()//得到中位数
        {
            return Querymid(1,1,size,S[1]/2);
        }
    int Querymid(int now,int l,int r,int q)//查询中位数
        {
            if (l==r) return l;
            int mid=(l+r)&gt;&gt;1;
            if (S[now*2]&gt;=q) return Querymid(now*2,l,mid,q);
            else return Querymid(now*2+1,mid+1,r,q-S[now*2]);
        }
    ll Querysum(int now,int l,int r,int ql,int qr)//查询区间和
        {
            if ((l==ql)&amp;&amp;(r==qr)) return Sum[now];
            int mid=(l+r)&gt;&gt;1;
            if (qr&lt;=mid) return Querysum(now*2,l,mid,ql,qr);
            if (ql&gt;=mid+1) return Querysum(now*2+1,mid+1,r,ql,qr);
            return Querysum(now*2,l,mid,ql,mid)+Querysum(now*2+1,mid+1,r,mid+1,qr);
        }
    ll Querycnt(int now,int l,int r,int ql,int qr)//查询区间数字个数
        {
            if ((l==ql)&amp;&amp;(r==qr)) return S[now];
            int mid=(l+r)&gt;&gt;1;
            if (qr&lt;=mid) return Querycnt(now*2,l,mid,ql,qr);
            if (ql&gt;=mid+1) return Querycnt(now*2+1,mid+1,r,ql,qr);
            return Querycnt(now*2,l,mid,ql,mid)+Querycnt(now*2+1,mid+1,r,mid+1,qr);
        }
};

class RANGE
{
public:
    ll l,r;
};

bool operator &lt; (RANGE A,RANGE B){//定义排序规则为按照中位数排序
    return A.l+A.r&lt;B.l+B.r;
}

ll n,pl,K;
ll Ans=0;
ll L[maxN],R[maxN];
Segment S1,S2;
RANGE Range[maxN];

int Find(int key);

int main()
{
    ios::sync_with_stdio(false);//这一题输入如果用scanf好像有奇怪的错误，似乎是因为交替输入了字符和数字，所以这里用cin
    cin&gt;&gt;K&gt;&gt;n;
    for (int i=1;i&lt;=n;i++)
    {
        char opt1,opt2;ll a,b;
        cin&gt;&gt;opt1&gt;&gt;a&gt;&gt;opt2&gt;&gt;b;
        if (opt1==opt2) Ans=Ans+abs(a-b);//在同一边的就直接加
        else
        {
            if (a&gt;b) swap(a,b);
            pl++;L[pl]=a;R[pl]=b;
        }
    }
    if (K==1)//k=1直接排序处理
    {
        for (int i=pl+1;i&lt;=pl+pl;i++) L[i]=R[i-pl];
        sort(&amp;L[1],&amp;L[pl+pl+1]);
        int pos=L[pl];
        for (int i=1;i&lt;=pl+pl;i++) Ans=Ans+abs(L[i]-pos);
        printf("%lld\n",Ans+1ll*pl);
    }
    if (K==2)
    {
        if (pl==0){//特判剩余没有人的情况
            printf("%lld\n",Ans);
            return 0;
        }
        for (int i=1;i&lt;=pl;i++){
            Num[i]=L[i];Num[i+pl]=R[i];
            Range[i].l=L[i];Range[i].r=R[i];
        }
        sort(&amp;Num[1],&amp;Num[pl+pl+1]);size=unique(&amp;Num[1],&amp;Num[pl+pl+1])-Num-1;sort(&amp;Range[1],&amp;Range[pl+1]);//离散化，同时将人排序

        for (int i=1;i&lt;=pl;i++) S2.Modify(1,1,size,Find(Range[i].l),1),S2.Modify(1,1,size,Find(Range[i].r),1);//先把所有人都丢入第二棵线段树

        ll Ans2;int mid=S2.GetMid();//得到只建一座桥的答案
        Ans2=Num[mid]*S2.Querycnt(1,1,size,1,mid)-S2.Querysum(1,1,size,1,mid)+S2.Querysum(1,1,size,mid,size)-Num[mid]*S2.Querycnt(1,1,size,mid,size);

        for (int i=1;i&lt;=pl;i++)
        {
            S1.Modify(1,1,size,Find(Range[i].l),1);S1.Modify(1,1,size,Find(Range[i].r),1);
            S2.Modify(1,1,size,Find(Range[i].l),-1);S2.Modify(1,1,size,Find(Range[i].r),-1);
            int md1=S1.GetMid(),md2=S2.GetMid();
            ll nowans
                =Num[md1]*S1.Querycnt(1,1,size,1,md1)-S1.Querysum(1,1,size,1,md1)+S1.Querysum(1,1,size,md1,size)-Num[md1]*S1.Querycnt(1,1,size,md1,size)
                +Num[md2]*S2.Querycnt(1,1,size,1,md2)-S2.Querysum(1,1,size,1,md2)+S2.Querysum(1,1,size,md2,size)-Num[md2]*S2.Querycnt(1,1,size,md2,size);
            Ans2=min(Ans2,nowans);
        }
        printf("%lld\n",Ans+Ans2+pl);
    }
    return 0;
}

int Find(int key)
{
    int l=1,r=size,ret=0;
    do
    {
        int mid=(l+r)&gt;&gt;1;
        if (Num[mid]&lt;=key) ret=mid,l=mid+1;
        else r=mid-1;
    }
    while (l&lt;=r);
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>512</wp:post_id>
		<wp:post_date><![CDATA[2018-02-17 21:14:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-17 13:14:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4071-luogu3644apio2015%e5%b7%b4%e9%82%bb%e6%97%81%e4%b9%8b%e6%a1%a5-%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%ef%bc%8c%e6%95%b0%e8%ae%ba%ef%bc%8c%e7%a6%bb%e6%95%a3%e5%8c%96%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="post_tag" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="apio"><![CDATA[APIO]]></category>
		<category domain="category" nicename="%e7%a6%bb%e6%95%a3%e5%8c%96"><![CDATA[离散化]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5709]Claris Loves Painting（线段树合并，主席树）</title>
		<link>http://sycstudio.com/archives/513</link>
		<pubDate>Sun, 18 Feb 2018 09:07:55 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=513</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Claris loves painting very much, so he painted a tree with beautiful colors.
The tree is a rooted tree with n nodes which are conveniently labeled by 1,2,...,n. Its root is the 1-st node, and the i-th node is painted with color ci. If ci=cj, then we think these two nodes have the same color.
We define depthi as the distance between the i-th node and the root, and simply, the distance between two adjacent nodes is always 1.
Standing in front of this beautiful tree, Claris comes up with m questions.
In each question, there are two integers x and d, which means that Claris wants to know the number of different kinds of colors occur in S, where S={v|v in x′s subtree and depthv≤depthx+d}.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5709">HDU</a>

<h3>Tag</h3>

线段树合并，主席树

<h2>题目大意</h2>

一棵有根树，树上每一个点有可能相同的颜色，现在要求回答若干个询问，求在&#92;(u&#92;)的子树内与&#92;(u&#92;)相距不超过&#92;(d&#92;)的点有多少种颜色。强制在线。

<h2>解决思路</h2>

先不考虑颜色的限制，假设问题是询问在一个点的子树中与&#92;(u&#92;)相距不超过&#92;(d&#92;)的节点个数，那么这个可以用线段树来维护。具体来说，对于每一个点维护一棵线段树，线段树维护的区间&#92;([l,r]&#92;)表示深度在&#92;([l,r]&#92;)内的节点个数。这个可以直接从儿子线段树合并转移过来。
再考虑加上颜色的限制。由于一种颜色只算一次，不妨我们对于每一种颜色就只算深度最浅的那个，那么我们对于每一个点再维护一棵线段树，这个树中的第&#92;(i&#92;)号位置维护在这棵子树内颜色为&#92;(i&#92;)的最浅的点的深度，那么，合并的时候就取两者中更浅的那个点作为当前的值，然后由于这时颜色有了冲突，于是再修改第一棵线段树中的值，具体来说就是在第一棵线段树中把更深的那个减掉，因为如果我们依次合并的话一次只会有一个冲突。
直接这么做是会爆空间的，考虑到实际从下往上合并的时候，实际用到的空间并不多，并且还有很多重复，所以可以借助主席树的思想，动态开点并重复利用已知信息。
另外，由于题目中给出了一个点的父亲编号小于自己的编号，所以树&#92;(dfs&#92;)可以直接用&#92;(for&#92;)代替。
少用&#92;(memset&#92;)。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int inf=2147483647;

class SegmentData
{
public:
    int key,ls,rs;
};

int n,m,nodecnt;
int Fa[maxN],Col[maxN],Depth[maxN];//父节点，颜色，深度
SegmentData S[maxN*110];//线段树
int T1[maxN],T2[maxN];//分别对应两棵线段树的根

int Modify(int rt,int l,int r,int pos,int opt);//修改
int Merge1(int r1,int r2,int l,int r);//合并第一棵线段树
int Merge2(int r1,int r2,int l,int r,int u);//合并第二棵线段树
int Query(int now,int l,int r,int d);//查询深度小于d的颜种数

int main()
{
    int T;scanf("%d",&amp;T);
    while (T--)
    {
        nodecnt=0;
        scanf("%d%d",&amp;n,&amp;m);
        for (int i=1;i&lt;=n;i++) scanf("%d",&amp;Col[i]);
        for (int i=2;i&lt;=n;i++) scanf("%d",&amp;Fa[i]);
        Depth[1]=1;for (int i=2;i&lt;=n;i++) Depth[i]=Depth[Fa[i]]+1;//得到深度
        for (int i=1;i&lt;=n;i++)//初始化每一棵线段树
        {
            T1[i]=Modify(0,1,n,Depth[i],1);//注意这里的0
            T2[i]=Modify(0,1,n,Col[i],Depth[i]);
        }
        for (int i=n;i&gt;=2;i--)//把子树信息合并
        {
            T1[Fa[i]]=Merge1(T1[Fa[i]],T1[i],1,n);
            T2[Fa[i]]=Merge2(T2[Fa[i]],T2[i],1,n,Fa[i]);
        }
        int lastans=0;
        for (int i=1;i&lt;=m;i++)
        {
            int u,dep;scanf("%d%d",&amp;u,&amp;dep);
            u^=lastans;dep^=lastans;
            printf("%d\n",lastans=Query(T1[u],1,n,min(Depth[u]+dep,n)));
        }
    }
    return 0;
}

int Modify(int rt,int l,int r,int pos,int opt)
{
    int nrt=++nodecnt;S[nrt].key=S[rt].key+opt;
    if (l==r) return nrt;
    int mid=(l+r)&gt;&gt;1;
    if (pos&lt;=mid) S[nrt].ls=Modify(S[rt].ls,l,mid,pos,opt),S[nrt].rs=S[rt].rs;
    else S[nrt].ls=S[rt].ls,S[nrt].rs=Modify(S[rt].rs,mid+1,r,pos,opt);
    return nrt;
}

int Merge1(int r1,int r2,int l,int r)
{
    if ((r1==0)||(r2==0)) return r1+r2;
    int nrt=++nodecnt;S[nrt].key=S[r1].key+S[r2].key;
    if (l==r) return nrt;
    int mid=(l+r)&gt;&gt;1;
    S[nrt].ls=Merge1(S[r1].ls,S[r2].ls,l,mid);
    S[nrt].rs=Merge1(S[r1].rs,S[r2].rs,mid+1,r);
    return nrt;
}

int Merge2(int r1,int r2,int l,int r,int u)
{
    if ((r1==0)||(r2==0)) return r1+r2;
    int nrt=++nodecnt;
    if (l==r)
    {
        if (S[r1].key&gt;S[r2].key){
            S[nrt].key=S[r2].key;T1[u]=Modify(T1[u],1,n,S[r1].key,-1);
        }
        else{
            S[nrt].key=S[r1].key;T1[u]=Modify(T1[u],1,n,S[r2].key,-1);
        }
        return nrt;
    }
    int mid=(l+r)&gt;&gt;1;
    S[nrt].ls=Merge2(S[r1].ls,S[r2].ls,l,mid,u);
    S[nrt].rs=Merge2(S[r1].rs,S[r2].rs,mid+1,r,u);
    return nrt;
}

int Query(int now,int l,int r,int d)
{
    if (now==0) return 0;
    if (r&lt;=d) return S[now].key;
    int mid=(l+r)&gt;&gt;1;
    int ret=Query(S[now].ls,l,mid,d);
    if (d&gt;=mid+1) ret+=Query(S[now].rs,mid+1,r,d);
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>513</wp:post_id>
		<wp:post_date><![CDATA[2018-02-18 17:07:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-18 09:07:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5709claris-loves-painting%ef%bc%88%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6%ef%bc%8c%e4%b8%bb%e5%b8%ad%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6"><![CDATA[线段树合并]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6"><![CDATA[线段树合并]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5818]Joint Stacks（可并堆，左偏树）</title>
		<link>http://sycstudio.com/archives/514</link>
		<pubDate>Sun, 18 Feb 2018 13:31:07 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=514</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

A stack is a data structure in which all insertions and deletions of entries are made at one end, called the "top" of the stack. The last entry which is inserted is the first one that will be removed. In another word, the operations perform in a Last-In-First-Out (LIFO) manner.
A mergeable stack is a stack with "merge" operation. There are three kinds of operation as follows:
- push A x: insert x into stack A
- pop A: remove the top element of stack A
- merge A B: merge stack A and B

After an operation "merge A B", stack A will obtain all elements that A and B contained before, and B will become empty. The elements in the new stack are rearranged according to the time when they were pushed, just like repeating their "push" operations in one stack. See the sample input/output for further explanation.
Given two mergeable stacks A and B, implement operations mentioned above.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5818">HDU</a>

<h3>Tag</h3>

可并堆，左偏树

<h2>题目大意</h2>

维护一个“可并栈”，要求支持弹入、弹出和合并的操作，合并两个栈后，新栈的元素排列按照原来两个栈中的时间戳从大往小排列。

<h2>解决思路</h2>

看到合并两个栈的方式，发现就是按照时间戳排序，直接用可并堆维护即可，堆中用于比较大小的是时间戳。
这里使用左偏树实现可并堆。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=101000;
const int inf=2147483647;

class Heap
{
public:
    int key,wth;//值，时间戳
    int ls,rs,dis;
    void init(){
            ls=rs=dis=0;return;
        }
};

int n;
Heap H[maxN];

int Merge(int r1,int r2);

int main()
{
    int cas=0;
    ios::sync_with_stdio(false);
    while (scanf("%d",&amp;n))
    {
        if (n==0) break;
        printf("Case #%d:\n",++cas);
        int rt[3],nodecnt=0,tim=0;
        rt[1]=rt[2]=0;//初始化
        char opt[20];
        while (n--)
        {
            cin&gt;&gt;opt;
            if ((opt[0]=='p')&amp;&amp;(opt[1]=='u'))//加入一个元素
            {
                char hp;int key;cin&gt;&gt;hp&gt;&gt;key;hp=hp-'A'+1;
                tim++;nodecnt++;
                H[nodecnt].init();
                H[nodecnt].key=key;H[nodecnt].wth=tim;
                rt[hp]=Merge(rt[hp],nodecnt);
            }
            if ((opt[0]=='p')&amp;&amp;(opt[1]=='o'))//弹出
            {
                char hp;cin&gt;&gt;hp;hp=hp-'A'+1;
                printf("%d\n",H[rt[hp]].key);
                rt[hp]=Merge(H[rt[hp]].ls,H[rt[hp]].rs);
            }
            if (opt[0]=='m')//合并
            {
                char hp1,hp2;cin&gt;&gt;hp1&gt;&gt;hp2;
                hp1=hp1-'A'+1;hp2=hp2-'A'+1;
                rt[hp1]=Merge(rt[hp1],rt[hp2]);
                rt[hp2]=0;
            }
        }
    }
    return 0;
}

int Merge(int r1,int r2)
{
    if (r1==0) return r2;
    if (r2==0) return r1;
    if (H[r1].wth&lt;H[r2].wth) swap(r1,r2);
    H[r1].rs=Merge(H[r1].rs,r2);
    if (H[H[r1].ls].dis&lt;H[H[r1].rs].dis) swap(H[r1].ls,H[r1].rs);
    if (H[r1].rs) H[r1].dis=H[H[r1].rs].dis+1;
    else H[r1].dis=0;
    return r1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>514</wp:post_id>
		<wp:post_date><![CDATA[2018-02-18 21:31:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-18 13:31:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5818joint-stacks%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU3031]To Be Or Not To Be（可并堆，左偏树）</title>
		<link>http://sycstudio.com/archives/515</link>
		<pubDate>Sun, 18 Feb 2018 13:46:52 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=515</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

That's a question. Now Happy (Xi Yangyang) has been caught by Wolffy (Hui Tailang). As Wolffy is busy preparing the big meal, a good idea comes to Happy. He proposes a game that only Wolffy had won, he can eat Happy. Wolffy always believes he is the cleverest one, so they reach a consensus. And they both agree with Wolnie (Hong Tailang) when the referee. A theater will be beat to die by Wolnie's pan. 
<img src="http://sycstudio.com/media/HDU/HDU3031-1.jpeg" alt="HDU3031-1" />
The game is defined as follow.
There are multiple test cases.
In each case there are R (R &lt; 10) rounds of the game, R is an odd number to guarantee that there must be a winner in the end.
In each round: There is a pile of n (10 &lt;= n &lt;= 200) Special-cards and m (1 &lt;= m &lt;= 100) piles of Point-card on the table. The Point-card piles are ordered from 1 to m. Wolffy and Happy take turns to get one card from the top of Special-cards pile. Wolffy always takes first in the game. When all the Special-cards have been taken, the round is over and the one with more cards in the hands gains one point. If there is a tie, Wolffy gains one point.(Wolffty and Happy both have 0 point before the game).
There are 5 kinds of Special-cards besides the Point-card in the game.
0) Point-card: a card with a point X (1 &lt;= X &lt;= 2000000).
1) Challenge-card: no matter who takes this card, they both take one card with the maximum point from their own hands. After a comparison, if Happy's card has a larger point, He takes all the Wolffy's in-hands cards, vice versa; If there is a tie no more operation.
2) Loss-card: the one who takes this card, He must throw a card with the maximum point.
3) Add-card: a card with P point, the one who gets this card will make the card with maximum point P point larger, i.e. if a Point-card with X point is the maximum, its point will change to X + P. An Add-card can only work on one Point-card.
4) Exchange-card: a card with Q point. The one who gets this card must change one maximum-point card's point to Q.
5) Take-card: a card with a integer K, indicates one can get the all the cards of Kth Point-card pile. In one round no two Take-card have the same K.
You can assume that when one gets the Loss-card, Add-card, Exchange-card, He has at least one card in the hands, when one gets a Challenge-card, they both have at least one card in the hands.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-3031">HDU</a>

<h3>Tag</h3>

可并堆，左偏树

<h2>题目大意</h2>

若干轮，每一轮给出&#92;(n&#92;)张特殊卡牌和&#92;(m&#92;)堆分值卡牌。两人轮流操作，每一次从特殊卡牌中抽出一张，使用完后丢弃。特殊卡牌有一下几种
&#92;(Challenge-card&#92;)，不管是谁抽到这一张，将两人分别数值最大的卡牌比较，分值大的一方获得另一方的所有卡牌。
&#92;(Loss-card&#92;)，抽到这一张卡牌的人要弃掉他分值最大的卡牌。
&#92;(Add-card&#92;)，抽到这一张卡牌的人将他分值最大的卡牌加上&#92;(Add-card&#92;)上对应的数值。
&#92;(Exchange-card&#92;)，抽到这一张卡牌的人将他分值最大的卡牌的分值变成&#92;(Exchange-card&#92;)上对应的分值。
&#92;(Take-card&#92;)，抽到这一张卡牌的人获得&#92;(Take-card&#92;)上数值对应的第几堆分值卡牌。
每一轮后，统计两人手中有的分值卡牌的个数，多的人得一分。
最后得分高的人胜。

<h2>解决思路</h2>

看到所有的卡牌操作，发现所有的操作都与取&#92;(max&#92;)有关，那么就想到用堆来维护两人分别的手牌。由于涉及到合并操作，那么就可以用可并堆来实现合并操作。
有部分细节需要注意。
这里使用左偏树实现可并堆。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100*10000+100;
const int inf=2147483647;

class Heap
{
public:
    int key;
    int ls,rs,dis;
    void init(){
            ls=rs=dis=0;return;
        }
};

int R;
int n,m,Pile[maxN],Pnum[maxN];//Pile维护第i堆分值卡牌对应在可并堆中的堆顶，Pnum维护第i堆分值卡牌中卡牌的数量。
Heap H[maxN];//左偏树

int Merge(int r1,int r2);

int main()
{
    ios::sync_with_stdio(false);
    while (cin&gt;&gt;R)
    {
        int hap=0,wof=0;//统计两人的得分
        while (R--)
        {
            int nodecnt=0;mem(Pile,0);
            cin&gt;&gt;n&gt;&gt;m;
            for (int i=1;i&lt;=m;i++) cin&gt;&gt;Pnum[i];//输入，并把每一堆初始分值卡牌构造成堆的形式
            for (int i=1;i&lt;=m;i++)
                for (int j=1;j&lt;=Pnum[i];j++)
                {
                    ++nodecnt;H[nodecnt].init();
                    cin&gt;&gt;H[nodecnt].key;
                    Pile[i]=Merge(Pile[i],nodecnt);
                }
            int Id[3];Id[1]=Id[2]=0;//记录两个人当前手中牌的堆顶
            int Size[3];Size[1]=Size[2]=0;//记录两人手中当前牌的数量
            for (int now=1;now&lt;=n;now++)
            {
                int pl=(now-1)%2+1;//当前操作的人
                char opt;cin&gt;&gt;opt;
                if (opt=='T')//Take-card
                {
                    int kth;cin&gt;&gt;kth;
                    Id[pl]=Merge(Id[pl],Pile[kth]);
                    Size[pl]+=Pnum[kth];
                }
                if (opt=='C')//Challenge-card
                {
                    if (H[Id[2]].key&gt;H[Id[1]].key){
                        Id[2]=Merge(Id[1],Id[2]);Id[1]=0;
                        Size[2]+=Size[1];Size[1]=0;
                    }
                    else if (H[Id[1]].key&gt;H[Id[2]].key){
                        Id[1]=Merge(Id[1],Id[2]);Id[2]=0;
                        Size[1]+=Size[2];Size[2]=0;
                    }
                }
                if (opt=='L'){//Lost-card
                    Id[pl]=Merge(H[Id[pl]].ls,H[Id[pl]].rs);Size[pl]--;
                }
                if (opt=='A'){//Add-card
                    int key;cin&gt;&gt;key;H[Id[pl]].key+=key;
                }
                if (opt=='E')//Exchange-card
                {
                    int key;cin&gt;&gt;key;
                    int id=Id[pl];Id[pl]=Merge(H[Id[pl]].ls,H[Id[pl]].rs);
                    H[id].key=key;Id[pl]=Merge(Id[pl],id);
                }
            }
            printf("%d:%d\n",Size[1],Size[2]);
            if (Size[1]&gt;=Size[2]) wof++;
            else hap++;
        }
        if (wof&gt;hap) printf("Hahaha...I win!!\n");
        else printf("I will be back!!\n");
    }
    return 0;
}

int Merge(int r1,int r2)
{
    if (r1==0) return r2;
    if (r2==0) return r1;
    if (H[r1].key&lt;H[r2].key) swap(r1,r2);
    H[r1].rs=Merge(H[r1].rs,r2);
    if (H[H[r1].ls].dis&lt;H[H[r1].rs].dis) swap(H[r1].ls,H[r1].rs);
    if (H[r1].rs) H[r1].dis=H[H[r1].rs].dis+1;
    else H[r1].dis=0;
    return r1;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>515</wp:post_id>
		<wp:post_date><![CDATA[2018-02-18 21:46:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-18 13:46:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu3031to-be-or-not-to-be%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU1358/UVA1328/SPOJ PERIDO/POJ1961/ZOJ2177]Period（KMP）</title>
		<link>http://sycstudio.com/archives/516</link>
		<pubDate>Tue, 20 Feb 2018 01:50:44 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=516</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

For each prefix of a given string S with N characters (each character has an ASCII code between 97 and 126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i (2 &lt;= i &lt;= N) we want to know the largest K > 1 (if there is one) such that the prefix of S with length i can be written as A K , that is A concatenated K times, for some string A. Of course, we also want to know the period K.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-1358">HDU</a>
<a href="https://vjudge.net/problem/UVA-1328">UVA</a>
<a href="https://vjudge.net/problem/SPOJ-PERIOD">SPOJ</a>
<a href="https://vjudge.net/problem/POJ-1961">POJ</a>
<a href="https://vjudge.net/problem/ZOJ-2177">ZOJ</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给出一个字符串，求所有能表示成若干循环串的前缀以及这些前缀的循环节个数。

<h2>解决思路</h2>

我们知道&#92;(KMP&#92;)算法求出的&#92;(Next&#92;)数组表示的是这个前缀的最长相同前缀后缀，那么，如果i是&#92;(i-Next[i]&#92;)的非&#92;(1&#92;)整数倍，就说明以&#92;(i&#92;)结尾的这个前缀是一个循环串，循环节长度为&#92;(i-Next[i]&#92;)，循环节个数就为&#92;(\frac{i}{i-Next[i]}&#92;)。
为什么这样是对的呢？比如下面这个前缀
<img src="http://sycstudio.com/media/HDU/HDU1358-1.png" alt="HDU-1358-1" />
根据&#92;(Next[i]&#92;)的定义，那么前面长度为&#92;(L'&#92;)的前缀&#92;([1,L']&#92;)一定与&#92;([L'+1,2L']&#92;)这一段相同，就是下面紫色和黄色的段。
<img src="http://sycstudio.com/media/HDU/HDU1358-2.png" alt="HDU-1358-1" />
那么同理又有&#92;([2L'+1,3L']&#92;)相同，即下面黄色与橙色段。
<img src="http://sycstudio.com/media/HDU/HDU1358-3.png" alt="HDU-1358-1" />
依次类推，可知如果&#92;(L&#92;)是&#92;(L'&#92;)的倍数，那么这个前缀就一定是循环的。

<pre><code class="cpp">## 代码
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int inf=2147483647;

int n;
char str[maxN];
int F[maxN];

int main()
{
    int cas=0;
    ios::sync_with_stdio(false);
    while (cin&gt;&gt;n)
    {
        if (n==0) break;
        cin&gt;&gt;(str+1);
        F[1]=0;F[0]=-1;
        for (int i=2;i&lt;=n;i++)//得到Next数组
        {
            int j=F[i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=F[j];
            if (str[j+1]==str[i]) F[i]=j+1;
            else F[i]=0;
        }
        printf("Test case #%d\n",++cas);
        for (int i=2;i&lt;=n;i++)
            if ((F[i]!=0)&amp;&amp;(i%(i-F[i])==0)) printf("%d %d\n",i,i/(i-F[i]));
        printf("\n");
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>516</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 09:50:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 01:50:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu1358-uva1328-spoj-perido-poj1961-zoj2177period%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="uva"><![CDATA[UVA]]></category>
		<category domain="post_tag" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="category" nicename="uva"><![CDATA[UVA]]></category>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="category" nicename="zoj"><![CDATA[ZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU6153]A Secret（KMP）</title>
		<link>http://sycstudio.com/archives/517</link>
		<pubDate>Tue, 20 Feb 2018 02:21:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=517</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Today is the birthday of SF,so VS gives two strings S1,S2 to SF as a present,which have a big secret.SF is interested in this secret and ask VS how to get it.There are the things that VS tell:
  Suffix(S2,i) = S2[i...len].Ni is the times that Suffix(S2,i) occurs in S1 and Li is the length of Suffix(S2,i).Then the secret is the sum of the product of Ni and Li.
  Now SF wants you to help him find the secret.The answer may be very large, so the answer should mod 1000000007.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-6153">HDU</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给出两个串，求第二个串的每一个后缀在第一个串中出现的次数。

<h2>解决思路</h2>

首先把两个串都翻过来变成处理前缀，因为&#92;(KMP&#92;)就是处理前缀的嘛。
首先考虑一个稍微暴力一点的办法，那就是对于每一个&#92;(B&#92;)串的前缀，我们都与&#92;(A&#92;)串作一次匹配。这样的复杂度是&#92;(O(n^2)&#92;)。
复杂度为什么会这么高呢？考虑我们算了哪些重复的东西，比如若前缀&#92;(abbcdefg&#92;)在&#92;(A&#92;)串中出现了，那么&#92;(a,ab,abc,abcd,abcde,abcdef&#92;)这些都出现了，而且我们每个都算了一遍。
怎么去掉这些重复计算的呢？我们把每一个前缀出现的次数拆开，转化成算&#92;(A&#92;)串中的某一个位置对于&#92;(B&#92;)串的哪些位置有贡献，有多少贡献。
但这样还是不好算，这时借助&#92;(KMP&#92;)中&#92;(Next&#92;)的性质，即&#92;(Next[i]&#92;)表示以&#92;(i&#92;)结尾的后缀的最长相同前缀后缀，那么一定就有若&#92;(A&#92;)串中的位置&#92;(pos&#92;)能匹配&#92;(B&#92;)串以&#92;(i&#92;)结尾的前缀，那一定也能匹配以&#92;(Next[i]&#92;)结尾的前缀，依次类推，也能匹配&#92;(Next[Next[i]]&#92;)，&#92;(Next[Next[Next[i]]]&#92;)，……
所以我们只要求出&#92;(A&#92;)串的每一个位置对哪个&#92;(B&#92;)串的<strong>最长前缀</strong>有贡献。注意这里是<strong>对B串求Next</strong>然后<strong>在B串中匹配A串</strong>。求完之后，再倒过来循环把上面包含关系的贡献加上，具体来说就是记&#92;(Cnt[i]&#92;)表示前缀&#92;(i&#92;)出现的次数，那么倒着循环&#92;(i&#92;)，&#92;(Cnt[Next[i]]+=Cnt[i]&#92;)。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int Mod=1e9+7;
const int inf=2147483647;

int n1,n2;
char str1[maxN],str2[maxN];
int F[maxN];
ll Cnt[maxN];

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;(str1+1)&gt;&gt;(str2+1);
        n1=strlen(str1+1);n2=strlen(str2+1);
        //翻转两个串
        for (int i=1;(i&lt;=n1)&amp;&amp;(i&lt;(n1-i+1));i++) swap(str1[i],str1[n1-i+1]);
        for (int i=1;(i&lt;=n2)&amp;&amp;(i&lt;(n2-i+1));i++) swap(str2[i],str2[n2-i+1]);
        F[0]=-1;F[1]=0;//求出Next数组
        for (int i=2;i&lt;=n2;i++)
        {
            int j=F[i-1];
            while ((j!=0)&amp;&amp;(str2[j+1]!=str2[i])) j=F[j];
            if (str2[j+1]==str2[i]) F[i]=j+1;
            else F[i]=0;
        }
        mem(Cnt,0);//在第二个串中匹配第一个串，同时记录贡献数
        for (int i=1,j=0;i&lt;=n1;i++)
        {
            while ((j!=0)&amp;&amp;(str2[j+1]!=str1[i])) j=F[j];
            if (str2[j+1]==str1[i]) j++,Cnt[j]++;
        }
        for (int i=n2;i&gt;=1;i--) Cnt[F[i]]+=Cnt[i];//把有包含关系的贡献数加上
        ll Ans=0;
        for (ll i=n2;i&gt;=1;i--) Ans=(Ans+Cnt[i]*i%Mod)%Mod;
        printf("%lld\n",Ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>517</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 10:21:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 02:21:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu6153a-secret%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1064/Luogu1477][Noi2008]假面舞会（图论，gcd）</title>
		<link>http://sycstudio.com/archives/518</link>
		<pubDate>Tue, 20 Feb 2018 13:46:17 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=518</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一 个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。为了使舞会更有神秘感，主办方把面具分为k (k≥3)类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第i 类面具的人才能看到戴第i+1 类面具的人的编号，戴第k 类面具的人能看到戴第1 类面具的人的编号。 参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。 栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第2号面具的人看到了第5 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信 息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了k≥3，所以你必须将这条信息也考虑进去。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1064">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P1477">Luogu</a>

<h3>Tag</h3>

图论，gcd

<h2>解决思路</h2>

大致的思路就是找出图中所有的环，对所有的环长取&#92;(gcd&#92;)。但由于是有向图，不好直接找出所有的环及环长。那么把有向图变成带权无向图，原来&#92;(u->v&#92;)的这样一条边拆成两条边，&#92;(u->v&#92;)权值为&#92;(1&#92;)，&#92;(v->u&#92;)权值为&#92;(-1&#92;)，这样从原来某一个"联通块"的任意一点出发就可以遍历整个联通块，加上权值就可以得到每一个点对应的"深度"，这个"深度"是相对的，因为有可能有负数。那么当我们从某一个点出发碰到了一个已经存在深度的点，说明我们碰到了一个"环"，直接求&#92;(gcd&#92;)即可。由于深度可能为负，所以需要取&#92;(abs&#92;)。
最后需要注意的是，如果整张图中都不存在任意一个"环"，那么此时的答案应该是每一个联通块的最长链之和。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxM=1001000*2;
const int inf=2147483647;

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
bool vis[maxN];
int Depth[maxN],Queue[maxN],Fa[maxN];

void Add_Edge(int u,int v,int w);
int gcd(int a,int b);

int main()
{
    mem(Head,-1);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=m;i++)
    {
        int a,b;scanf("%d%d",&amp;a,&amp;b);
        Add_Edge(a,b,1);Add_Edge(b,a,-1);//添加正反两条边
    }
    int length=0,chain=0;//length记录当前所有环长的gcd，chain记录每一个联通块的最长链之和
    for (int i=1;i&lt;=n;i++)
        if (vis[i]==0)//对每一个联通块Bfs求解
        {
            Depth[i]=0;
            int h=1,t=0;Queue[1]=i;vis[i]=1;
            int mx=-inf,mn=inf;//mx和mn分别记录深度的最大值和最小值
            do
            {
                int u=Queue[++t];mx=max(mx,Depth[u]),mn=min(mn,Depth[u]);
                for (int i=Head[u];i!=-1;i=Next[i])
                {
                    if (V[i]==Fa[u]) continue;
                    if (vis[V[i]]==0) vis[Queue[++h]=V[i]]=1,Depth[V[i]]=Depth[u]+W[i],Fa[V[i]]=u;//当这个点还没有被访问，则访问
                    else//否则，说明找到了一个环，更新答案
                    {
                        if (length==0) length=abs(Depth[u]-Depth[V[i]]+W[i]);
                        else length=gcd(length,abs(Depth[u]-Depth[V[i]]+W[i]));
                    }
                }
            }
            while (h!=t);
            chain=chain+mx-mn+1;
        }
    if (length==0)//整图无环
    {
        if (chain&lt;3) printf("-1 -1\n");
        else printf("%d 3\n",chain);
    }
    else//有环
    {
        if (length&lt;3) printf("-1 -1\n");
        else
        {
            printf("%d ",length);//最大值就为环长gcd
            for (int i=3;i&lt;=length;i++) if (length%i==0) {length=i;break;}
            printf("%d\n",length);//最小值为环长的最小因数
        }
    }
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

int gcd(int a,int b)
{
    int tmp;
    while (b) tmp=b,b=a%b,a=tmp;
    return a;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>518</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 21:46:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 13:46:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1064-luogu1477noi2008%e5%81%87%e9%9d%a2%e8%88%9e%e4%bc%9a%ef%bc%88%e5%9b%be%e8%ae%ba%ef%bc%8cgcd%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1924/Luogu2403][Sdoi2010]所驼门王的宝藏（Tarjan，动态规划）</title>
		<link>http://sycstudio.com/archives/519</link>
		<pubDate>Tue, 20 Feb 2018 14:00:13 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=519</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的Alpaca L. Sotomon是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天Henry Curtis故事的起点。Henry是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。
整座宫殿呈矩阵状，由R×C间矩形宫室组成，其中有N间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这N间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：
“横天门”：由该门可以传送到同行的任一宫室；
“纵寰门”：由该门可以传送到同列的任一宫室；
“自由门”：由该门可以传送到以该门所在宫室为中心周围8格中任一宫室（如果目标宫室存在的话）。
深谋远虑的Henry当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。
现在Henry已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉Henry这条路线最多行经不同藏宝宫室的数目。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1924">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2403">Luogu</a>

<h3>Tag</h3>

Tarjan，动态规划

<h2>题目大意</h2>

在有向图上求一条可以经过重复点的经过点最多的路径。

<h2>解决思路</h2>

思路比较简单，首先&#92;(Tarjan&#92;)缩点后记录每一个缩的点的位置，然后按&#92;(Top&#92;)序在&#92;(DAG&#92;)上动态规划求出最长链。
至于实现，开始建图可以用&#92;(Map&#92;)的方式存下所有有用的点，对行和列分别建立虚点，前两种门就分别只与对应行和列的虚点连边，第三种门直接扫描周围八个点是否存在进行连边。这样做的话，&#92;(Tarjan&#92;)缩点的时候就要注意不要把虚点统计进&#92;(Size&#92;)，需要判断一下。
然后在新图上建边，注意这里最好用&#92;(Set&#92;)标记一下，以防建太多的重复边。

<h2>代码</h2>

<pre><code class="cpp">//这份代码在Luogu上有三个点MLE，暂未改出
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100001*3;
const int maxMap=1000001;
const int maxM=maxN*8;
const int F1[9]={0,-1,-1,-1,0,1,1,1,0};
const int F2[9]={0,-1,0,1,1,1,0,-1,-1};
const int inf=2147483647;

int n,R,C;
int Ans=0;
int nodecnt=0,nnodecnt;
int edgecnt=-1,Head[maxN],Next[maxM],V[maxM];
map&lt;int,int&gt; Map[maxMap],Opt[maxMap];
int dfncnt=0,dfn[maxN],low[maxN],Id[maxN];

int idcnt=0,Size[maxN];
int stacktop=0,Stack[maxN];
bool instack[maxN];
int edgecnt2=0,Head2[maxN],Next2[maxN*2],V2[maxN*2],Indegree[maxN*2];
int Queue[maxN],F[maxN];
int Hang[maxMap],Lie[maxMap];
set&lt;int&gt; Set[maxN];

void Add_Edge(int u,int v);
void Add_Edge2(int u,int v);
void dfs(int u,int fa);
int GetHang(int h);
int GetLie(int l);

int main()
{
    ios::sync_with_stdio(false);
    mem(Head,-1);mem(Head2,-1);
    cin&gt;&gt;n&gt;&gt;R&gt;&gt;C;
    for (int i=1;i&lt;=n;i++)
    {
        int x,y,opt;cin&gt;&gt;x&gt;&gt;y&gt;&gt;opt;
        Map[x][y]=++nodecnt;Opt[x][y]=opt;//Opt记录这个宫室的类型
    }
    nnodecnt=nodecnt;
    for (int i=1;i&lt;=R;i++)
        for (map&lt;int,int&gt;::iterator j=Map[i].begin();j!=Map[i].end();j++)//建图
        {
            Add_Edge(GetHang(i),j-&gt;second);Add_Edge(GetLie(j-&gt;first),j-&gt;second);//首先从对应的行和列连边过来
            if (Opt[i][j-&gt;first]==1) Add_Edge(j-&gt;second,GetHang(i));//第一种门
            else if (Opt[i][j-&gt;first]==2) Add_Edge(j-&gt;second,GetLie(j-&gt;first));//第二种门
            else for (int f=1;f&lt;=8;f++) if (Map[i+F1[f]].count(j-&gt;first+F2[f])!=0) Add_Edge(j-&gt;second,Map[i+F1[f]][j-&gt;first+F2[f]]);//第三种门
        }
    for (int i=1;i&lt;=nodecnt;i++)//Tarjan缩点
        if (dfn[i]==0) dfs(i,i);
    for (int i=1;i&lt;=nodecnt;i++)//建立缩完点后的新图
        for (int j=Head[i];j!=-1;j=Next[j])
            if ((Id[i]!=Id[V[j]])&amp;&amp;(Set[i].count(V[j])==0))
                Add_Edge2(Id[i],Id[V[j]]),Set[i].insert(V[j]);
    int h=0,t=0;//Top序动态规划求最长链
    for (int i=1;i&lt;=idcnt;i++) if (Indegree[i]==0) Queue[++h]=i;
    do
    {
        int u=Queue[++t];
        for (int i=Head2[u];i!=-1;i=Next2[i])
        {
            F[V2[i]]=max(F[V2[i]],F[u]+Size[u]);
            Indegree[V2[i]]--;if (Indegree[V2[i]]==0) Queue[++h]=V2[i];
        }
    }
    while (t!=h);
    for (int i=1;i&lt;=idcnt;i++) Ans=max(Ans,F[i]+Size[i]);//取最优解
    printf("%d\n",Ans);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void Add_Edge2(int u,int v)
{
    edgecnt2++;Next2[edgecnt2]=Head2[u];Head2[u]=edgecnt2;V2[edgecnt2]=v;
    Indegree[v]++;
    return;
}

void dfs(int u,int fa)//Tarjan
{
    dfn[u]=low[u]=++dfncnt;
    Stack[++stacktop]=u;instack[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
    {
        if (dfn[V[i]]==0){
            dfs(V[i],u);low[u]=min(low[u],low[V[i]]);
        }
        else if (instack[V[i]]) low[u]=min(low[u],dfn[V[i]]);
    }
    if (dfn[u]==low[u]){
        int size=0,v;idcnt++;
        do{
            v=Stack[stacktop--];Id[v]=idcnt;instack[v]=0;if (v&lt;=nnodecnt) size++;//注意这里if一句，是保证只有实点才被统计进Size中
        }
        while (u!=v);
        Size[idcnt]=size;
    }
    return;
}

int GetHang(int h)
{
    if (Hang[h]==0) Hang[h]=++nodecnt;
    return Hang[h];
}

int GetLie(int l)
{
    if (Lie[l]==0) Lie[l]=++nodecnt;
    return Lie[l];
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>519</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 22:00:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 14:00:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1924-luogu2403sdoi2010%e6%89%80%e9%a9%bc%e9%97%a8%e7%8e%8b%e7%9a%84%e5%ae%9d%e8%97%8f%ef%bc%88tarjan%ef%bc%8c%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%9b%be%e4%b8%8a%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[图上动态规划]]></category>
		<category domain="category" nicename="tarjan"><![CDATA[Tarjan]]></category>
		<category domain="category" nicename="%e5%be%85%e5%a1%ab%e5%9d%91-%e5%be%85%e6%9b%b4%e6%96%b0"><![CDATA[待填坑/待更新]]></category>
		<category domain="post_tag" nicename="tarjan"><![CDATA[Tarjan]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ1143][CTSC2008]祭祀river（二分图）</title>
		<link>http://sycstudio.com/archives/520</link>
		<pubDate>Tue, 20 Feb 2018 14:52:57 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=520</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

在遥远的东方，有一个神秘的民族，自称Y族。他们世代居住在水面上，奉龙王为神。每逢重大庆典， Y族都会在水面上举办盛大的祭祀活动。我们可以把Y族居住地水系看成一个由岔口和河道组成的网络。每条河道连接着两个岔口，并且水在河道内按照一个固定的方向流动。显然，水系中不会有环流。由于人数众多的原因，Y族的祭祀活动会在多个岔口上同时举行。出于对龙王的尊重，这些祭祀地点的选择必须非常慎重。准确地说，Y族人认为，如果水流可以从一个祭祀点流到另外一个祭祀点，那么祭祀就会失去它神圣的意义。族长希望在保持祭祀神圣性的基础上，选择尽可能多的祭祀的地点。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1143">BZOJ</a>

<h3>Tag</h3>

二分图

<h2>题目大意</h2>

给定一个&#92;(DAG&#92;)求最长反链。

<h2>解决思路</h2>

首先给出定义，&#92;(DAG&#92;)上的链指的是一个点的集合，这个点的集合满足其中任意两个点&#92;(u,v&#92;)，要么&#92;(u&#92;)能到&#92;(v&#92;)，要么&#92;(v&#92;)能到&#92;(u&#92;)。
那么反链就是指的一个点集使得其中任意两个点&#92;(u,v&#92;)都不能互相可达。
最长反链=最小链覆盖，最小链覆盖就是用最少的链使得图中每一个点都遍历到。这个证明可以参考<a href="http://vfleaking.blog.163.com/blog/static/1748076342012918105514527/">vfk的博客</a>。
那么怎么求最小链覆盖呢？最小链覆盖就是可以重复经过点的最小路径覆盖，而最小路径覆盖可以通过二分图建模的方式解决。
具体来说，对于原图的一个点&#92;(i&#92;)，拆成两个点&#92;(i,i'&#92;)，对于原图的一条边&#92;(u->v&#92;)，变成边&#92;(u->v'&#92;)，这样构成二分图。那么，总点数-最大匹配就是最小路径覆盖。为什么呢？可以想象开始的时候有&#92;(n&#92;)个点，就有&#92;(n&#92;)条路径来覆盖，每在二分图中选择了一条边&#92;(u->v'&#92;)，相当于把以&#92;(u&#92;)结尾的路径和与&#92;(v&#92;)开头的两条路径合并，又因为是最大匹配，所以不可能有路径相交，所以最大匹配数就是合并次数，总点数-合并次数就是最小路径覆盖。
那么如何从最小路径覆盖变成最小链覆盖呢？我们观察发现，用路径覆盖图的时候，有可能一条路径把另一条切断了，那么为了实现链覆盖，我们需要有一条在这条链上的边"跨过"这一条路径。没错，就是对每一个点求出它能到的点和能到它的点。这个就是传递闭包，可以用&#92;(Floyed&#92;)实现。
所以，为了把链覆盖转化为求路径覆盖，可以传递闭包后再在新图上求二分图最大匹配。
这里用匈牙利算法求二分图最大匹配。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=111;
const int maxM=1011;
const int inf=2147483647;

int n,m,dep;
int Map[maxN][maxN];
int edgecnt=0,Head[maxN*2],Next[maxN*maxN*2],V[maxN*maxN*2];
int Match[maxN*2];
int vis[maxN*2];

void Add_Edge(int u,int v);
bool Hungary(int u);//匈牙利算法求二分图最大匹配

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=m;i++){
        int u,v;cin&gt;&gt;u&gt;&gt;v;Map[u][v]=1;
    }
    for (int k=1;k&lt;=n;k++)//Floyed传递闭包
        for (int i=1;i&lt;=n;i++)
            if (Map[i][k])
                for (int j=1;j&lt;=n;j++)
                    if (Map[k][j])
                        Map[i][j]|=(Map[i][k]&amp;Map[k][j]);
    mem(Match,-1);mem(Head,-1);
    for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (Map[i][j]) Add_Edge(i,j+n);//构造二分图
    int cnt=0;
    for (int i=1;i&lt;=n;i++) dep++,cnt+=Hungary(i);
    printf("%d\n",n-cnt);
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

bool Hungary(int u)
{
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]!=dep)
        {
            vis[V[i]]=dep;
            if ((Match[V[i]]==-1)||(Hungary(Match[V[i]])))
            {
                Match[V[i]]=u;return 1;
            }
        }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>520</wp:post_id>
		<wp:post_date><![CDATA[2018-02-20 22:52:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-20 14:52:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj1143ctsc2008%e7%a5%ad%e7%a5%80river%ef%bc%88%e4%ba%8c%e5%88%86%e5%9b%be%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="ctsc"><![CDATA[CTSC]]></category>
		<category domain="post_tag" nicename="ctsc"><![CDATA[CTSC]]></category>
		<category domain="category" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU4763]Theme Section（KMP）</title>
		<link>http://sycstudio.com/archives/522</link>
		<pubDate>Wed, 21 Feb 2018 06:45:25 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=522</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

It's time for music! A lot of popular musicians are invited to join us in the music festival. Each of them will play one of their representative songs. To make the programs more interesting and challenging, the hosts are going to add some constraints to the rhythm of the songs, i.e., each song is required to have a 'theme section'. The theme section shall be played at the beginning, the middle, and the end of each song. More specifically, given a theme section E, the song will be in the format of 'EAEBE', where section A and section B could have arbitrary number of notes. Note that there are 26 types of notes, denoted by lower case letters 'a' - 'z'.
To get well prepared for the festival, the hosts want to know the maximum possible length of the theme section of each song. Can you help us?

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-4763">HDU</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给出一个字符串，求最长的满足&#92;(ABACA&#92;)形式的串&#92;(A&#92;)的长度

<h2>解决思路</h2>

由于要求首尾都是&#92;(A&#92;)，那么必然要满足前后缀相同，&#92;(KMP&#92;)求出&#92;(Next&#92;)数组后，由于要满足结尾，那么可以从结尾开始跳&#92;(Next&#92;)，标记出所有与结尾后缀相同的所有前缀，同时注意，这些标记出来的子串长度不能超过&#92;(\frac{n}{2}&#92;)，要不然就会有重复了。再从这些标记了的前缀出发，寻找某一个它能包含的前缀，并满足长度不会使三个字符串重叠。这样就找到了一组三个不重叠的相同子串。取最大长度即可。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=1001000;
const int inf=2147483647;

int n;
char str[maxN];
int Next[maxN];
bool GoLast[maxN];

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        mem(GoLast,0);
        cin&gt;&gt;(str+1);n=strlen(str+1);
        Next[0]=-1;Next[1]=0;
        for (int i=2;i&lt;=n;i++)//求Next
        {
            int j=Next[i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=Next[j];
            if (str[j+1]==str[i]) Next[i]=j+1;
            else Next[i]=0;
        }
        int Ans=0;
        for (int i=n;i!=0;i=Next[i]) if (i+i&lt;=n) GoLast[i]=1;//给能与结尾匹配上的前缀打上标记
        for (int i=n-1;i&gt;=1;i--)
        {
            int now=i;
            while (now)//寻找合法前缀
            {
                if ((GoLast[now])&amp;&amp;(now+now&lt;=i)&amp;&amp;(now+i&lt;=n)){
                    Ans=max(Ans,now);break;//更新最大值
                }
                now=Next[now];
            }
        }
        printf("%d\n",Ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>522</wp:post_id>
		<wp:post_date><![CDATA[2018-02-21 14:45:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-21 06:45:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu4763theme-section%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ3670/Luogu2375][Noi2014]动物园（KMP）</title>
		<link>http://sycstudio.com/archives/523</link>
		<pubDate>Wed, 21 Feb 2018 07:11:45 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=523</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。
某天，园长给动物们讲解KMP算法。
园长：“对于一个字符串S，它的长度为L。我们可以在O(L)的时间内，求出一个名为next的数组。有谁预习了next数组的含义吗？”
熊猫：“对于字符串S的前i个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作next[i]。”
园长：“非常好！那你能举个例子吗？”
熊猫：“例S为abcababc，则next[5]=2。因为S的前5个字符为abcab，ab既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出next[1] = next[2] = next[3] = 0，next[4] = next[6] = 1，next[7] = 2，next[8] = 3。”
园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在O(L)的时间内求出next数组。
下课前，园长提出了一个问题：“KMP算法只能求出next数组。我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。例如S为aaaaa，则num[4] = 2。这是因为S的前4个字符为aaaa，其中a和aa都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] = num[3] = 1,num[5] = 2。”
最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出num数组呢？
特别地，为了避免大量的输出，你不需要输出num[i]分别是多少，你只需要输出所有num[i]的乘积，对1,000,000,007取模的结果即可。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3670">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2375">Luogu</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给定一个字符串，求每一个前缀中不重叠的相同前后缀个数。

<h2>解决思路</h2>

考虑一个暴力一点的算法，&#92;(KMP&#92;)求出&#92;(Next&#92;)数组后，对于每一个位置我们都暴力地跳&#92;(Next&#92;)遍历它包含的所有前缀，而这些前缀中长度小于当前位置的二分之一的就是要统计进&#92;(Num&#92;)的。
优化一下，对于每一个位置，我们再记录一个&#92;(Cnt[i]&#92;)表示它包含的前缀个数（包括它自己），那么我们再跳的时候一旦跳到一个长度小于当前前缀长度/2的就停止，直接从这个地方累加&#92;(Cnt&#92;)过来。
再优化一下，前面跳的过程可以用倍增来实现，这样，复杂度就降到&#92;(O(nlogn)&#92;)，大力卡常是可以过的。
当然这样的算法不够优美。我们考虑我们把复杂度浪费在了哪里呢？没错，就是每次倍增的复杂度。每一次都倍增求一次位置很耗时间，所以我们考虑用&#92;(pos&#92;)记录上一次找到的合法位置，设当前需要计算的位是&#92;(i&#92;)，类似&#92;(KMP&#92;)中移动&#92;(j&#92;)指针寻找与&#92;(str[i]&#92;)匹配的&#92;(str[j+1]&#92;)，我们跳&#92;(pos&#92;)指针找到第一个与&#92;(str[i]&#92;)匹配的&#92;(str[pos+1]&#92;)，在找到之后，再判断&#92;(2&#42;pos&#92;)是不是小于&#92;(i&#92;)，如果不小于，则还要跳&#92;(Next[pos]&#92;)直到满足小于关系。
这样，寻找合法位置的复杂度就与&#92;(KMP&#92;)同阶了。

<h2>代码</h2>

倍增算法，最慢&#92;(0.9s+&#92;)

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register

const int maxN=1000010;
const int Mod=1e9+7;
const int maxBit=20;
const int inf=2147483647;

int n;
char str[maxN];
int Next[maxBit+1][maxN],Size[maxBit+1][maxN];//Next是原KMP中Next的跳转，Size记录跳转中实际经过了几个点
int Num[maxN],Tot[maxN];

int main()
{
    ios::sync_with_stdio(false);
    RG int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;(str+1);n=strlen(str+1);
        mem(Next[0],0);mem(Size[0],0);
        Next[0][0]=-1;Next[0][1]=0;
        for (RG int i=2;i&lt;=n;++i)//构造Next
        {
            RG int j=Next[0][i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=Next[0][j];
            if (str[j+1]==str[i]) Next[0][i]=j+1;
            else Next[0][i]=0;
            Size[0][i]=1;
        }
        //初始化倍增
        for (RG int i=1;i&lt;=maxBit;++i)
            for (RG int j=1;j&lt;=n;++j)
                Next[i][j]=Next[i-1][Next[i-1][j]],Size[i][j]=Size[i-1][j]+Size[i-1][Next[i-1][j]];
        mem(Num,0);mem(Tot,0);Num[0]=-1;
        for (RG int i=1;i&lt;=n;++i)//求解Num
        {
            RG int now=i;//倍增求出i对应的合法位置
            for (RG int j=maxBit;j&gt;=0;--j) if (Next[j][now]*2&gt;i) now=Next[j][now],Tot[i]=Tot[i]+Size[j][now];
            now=Next[0][now];
            Tot[i]+=Tot[now]+1;//Tot记录前缀i包含多少个前缀
            Num[i]=Tot[now];
        }
        RG ll Ans=1;
        for (RG int i=1;i&lt;=n;++i) Ans=Ans*(ll)(Num[i]+1)%Mod;
        printf("%lld\n",Ans);
    }
    return 0;
}
</code></pre>

类&#92;(KMP&#92;)的&#92;(pos&#92;)跳转，最慢&#92;(0.040s&#92;)

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define RG register

const int maxN=1000100;
const int Mod=1e9+7;
const int inf=2147483647;

int n;
char str[maxN];
int Next[maxN];
int Cnt[maxN];

int main()
{
    ios::sync_with_stdio(false);
    RG int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;(str+1);n=strlen(str+1);
        Cnt[1]=1;
        RG int pos=0;
        RG ll Ans=1;
        for (RG int i=2;i&lt;=n;i++)//求解Next的同时跳转pos
        {
            RG int j=Next[i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=Next[j];
            if (str[j+1]==str[i]) Next[i]=j+1;
            else Next[i]=0;
            Cnt[i]=Cnt[Next[i]]+1;//Cnt记录前缀i包含多少个前缀
            while ((pos!=0)&amp;&amp;(str[pos+1]!=str[i])) pos=Next[pos];
            if (str[pos+1]==str[i]) pos++;//将pos跳转到一个匹配的位置
            while (pos*2&gt;i) pos=Next[pos];//再跳转到一个合法的位置
            Ans=Ans*(ll)(Cnt[pos]+1)%Mod;
        }
        printf("%lld\n",Ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>523</wp:post_id>
		<wp:post_date><![CDATA[2018-02-21 15:11:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-21 07:11:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj3670-luogu2375noi2014%e5%8a%a8%e7%89%a9%e5%9b%ad%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="noi"><![CDATA[NOI]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2753/Luogu2573][SCOI2012]滑雪与时间胶囊（生成树）</title>
		<link>http://sycstudio.com/archives/524</link>
		<pubDate>Wed, 21 Feb 2018 07:27:39 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=524</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

a180285非常喜欢滑雪。他来到一座雪山，这里分布着M条供滑行的轨道和N个轨道之间的交点（同时也是景点），而且每个景点都有一编号i（1&lt;=i&lt;=N）和一高度Hi。a180285能从景点i 滑到景点j 当且仅当存在一条i 和j 之间的边，且i 的高度不小于j。 与其他滑雪爱好者不同，a180285喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。于是a180285拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是a180285 滑行的距离）。请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285站在1号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2753">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2573">Luogu</a>

<h3>Tag</h3>

生成树

<h2>题目大意</h2>

给定一个有特殊性质的有向图，求最小树形图。

<h2>解决思路</h2>

直接把求最小树形图的朱刘算法拿过来是不行的，时间复杂度太高。
注意到这一道题中有向图的特殊性质，边总是从高的向低的走的，可以想象是按高度从高到低分成若干段来考虑。这个对于贪心很有帮助。
首先考虑为什么无向图的最小生成树算法不能直接照搬到有向图中。以&#92;(Prim&#92;)为例，无向图的生成树算法基于贪心原理，即若选当前距离最短的点进来不会差。但这个贪心在有向图中是不成立的，因为边有向。
放到这个题，由于边总是从高的连向低的，那么<strong>先考虑高的点不会更差</strong>，因为海拔更低的点不会更新高的点，所以我们可以类似从高到低地来考虑。又因为海拔相同的点，边相当于是无向的。所以就可以直接用无向图的最小生成树来解。
这里选择用&#92;(Prim&#92;)算法实现最小生成树，那么与常规的算法不一样的是，这里的比较就要优先比较海拔，再比较距离，这样才能满足上面的贪心。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int maxM=1000100*2;
const int inf=2147483647;

class Queue_Data
{
public:
    int u;
    ll dis;
};

ll Height[maxN];

bool operator &lt; (Queue_Data A,Queue_Data B){//定义比较函数，注意先比较海拔
    if (Height[A.u]!=Height[B.u]) return Height[A.u]&lt;Height[B.u];
    else return A.dis&gt;B.dis;
}

int n,m;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM];
ll W[maxM];
ll Dis[maxN];
bool vis[maxN];
priority_queue&lt;Queue_Data&gt; Q;

void Add_Edge(int u,int v,int w);

int main()
{
    mem(Head,-1);
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    for (int i=1;i&lt;=n;i++) cin&gt;&gt;Height[i];
    for (int i=1;i&lt;=m;i++)
    {
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;//从高海拔向低海拔连比
        if (Height[u]&gt;=Height[v]) Add_Edge(u,v,w);
        if (Height[v]&gt;=Height[u]) Add_Edge(v,u,w);
    }
    mem(Dis,-1);Dis[1]=0;
    Q.push((Queue_Data){1,0});
    ll Ans=0,Sum=0;
    do//堆优化求解最小生成树
    {
        Queue_Data u=Q.top();Q.pop();
        if (vis[u.u]) continue;
        vis[u.u]=1;
        Ans++;Sum=Sum+(ll)Dis[u.u];
        for (int i=Head[u.u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;((Dis[V[i]]==-1)||(Dis[V[i]]&gt;W[i]))){
                Dis[V[i]]=W[i];Q.push((Queue_Data){V[i],Dis[V[i]]});
            }
    }
    while (!Q.empty());
    printf("%lld %lld\n",Ans,Sum);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>524</wp:post_id>
		<wp:post_date><![CDATA[2018-02-21 15:27:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-21 07:27:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2753-luogu2573scoi2012%e6%bb%91%e9%9b%aa%e4%b8%8e%e6%97%b6%e9%97%b4%e8%83%b6%e5%9b%8a%ef%bc%88%e7%94%9f%e6%88%90%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>100</wp:comment_id>
			<wp:comment_author><![CDATA[dsl2002]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[778315932@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-21 17:16:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-21 09:16:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[泥萌又在切我要讲的题]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>13</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>101</wp:comment_id>
			<wp:comment_author><![CDATA[sycstudio]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1726016246@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://sycstudio.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-02-21 17:34:04]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-02-21 09:34:04]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你要讲这道？
这道题我是在某一次找生成树的题目时找到的。真是巧了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>100</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>[HDU3746]Cyclic Nacklace（KMP）</title>
		<link>http://sycstudio.com/archives/532</link>
		<pubDate>Thu, 22 Feb 2018 09:24:23 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=532</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

CC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of "HDU CakeMan", he wants to sell some little things to make money. Of course, this is not an easy task.
As Christmas is around the corner, Boys are busy in choosing christmas presents to send to their girlfriends. It is believed that chain bracelet is a good choice. However, Things are not always so simple, as is known to everyone, girl's fond of the colorful decoration to make bracelet appears vivid and lively, meanwhile they want to display their mature side as college students. after CC understands the girls demands, he intends to sell the chain bracelet called CharmBracelet. The CharmBracelet is made up with colorful pearls to show girls' lively, and the most important thing is that it must be connected by a cyclic chain which means the color of pearls are cyclic connected from the left to right. And the cyclic count must be more than one. If you connect the leftmost pearl and the rightmost pearl of such chain, you can make a CharmBracelet. Just like the pictrue below, this CharmBracelet's cycle is 9 and its cyclic count is 2:
Now CC has brought in some ordinary bracelet chains, he wants to buy minimum number of pearls to make CharmBracelets so that he can save more money. but when remaking the bracelet, he can only add color pearls to the left end and right end of the chain, that is to say, adding to the middle is forbidden.
CC is satisfied with his ideas and ask you for help.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-3746">HDU</a>

<h3>Tag</h3>

KMP

<h2>题目大意</h2>

给出一个串，求在这个串的两侧添加最少的字符使得它成为一个完整的循环串。

<h2>解决思路</h2>

首先知道，在串的两边加字符与只在一边加效果是一样的，因为是循环串，那么问题转化为在一个字符串后面加上若干个字符使得整个字符串成为一个循环串。
那么先来看这个循环串需要满足的条件，它的循环节的前缀一定是整个原字符串的后缀，因为可以将原字符串看作若干个循环节后面接上一个不完整的循环节的前缀。所以可以从最后一个字符开始跳&#92;(Next&#92;)，这样就可以标记出所有包含原串后缀的所有前缀，即能匹配上。
然后我们从前往后枚举循环节的长度。首先判断是不是真的是循环的。由于已经知道了长度，那么我们就可以求出这个循环节完整的最后一次结束的位置，假设这个位置是&#92;(pos&#92;)，当前循环节的长度为&#92;(i&#92;)，那么若&#92;(\frac{pos}{pos-Next[pos]}&#92;)为整数并且&#92;(pos-Next[pos]==i&#92;)，则这个循环节是合法的（证明可以参考<a href="http://sycstudio.com/archives/516">这里</a>）。接着判断剩下的&#92;(n-pos&#92;)位是否能构成合法一个残缺的循环节（即剩下的&#92;(n-pos&#92;)位能匹配循环节的前&#92;(n-pos&#92;)位），这个直接看原串的第&#92;(n-pos&#92;)位在我们的第一步中是否被标记即可。最后需要注意的是，当枚举循环节长度枚举到最后一位时，要特殊判断整个原串是否本身就是循环的，此时答案为&#92;(0&#92;)。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=100100;
const int inf=2147483647;

int n;
char str[maxN];
int Next[maxN];
bool Pre[maxN];

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;(str+1);n=strlen(str+1);
        Next[0]=-1;Next[1]=0;
        for (int i=2;i&lt;=n;i++)//构造Next
        {
            int j=Next[i-1];
            while ((j!=0)&amp;&amp;(str[j+1]!=str[i])) j=Next[j];
            if (str[j+1]==str[i]) Next[i]=j+1;
            else Next[i]=0;
        }
        mem(Pre,0);Pre[0]=1;//标记出所有合法前缀
        for (int i=n;i!=0;i=Next[i]) Pre[i]=1;
        int mn=n;//记录最短补全长度
        for (int i=1;i&lt;=n;i++)
        {
            int cnt=n/i,pos=cnt*i;//cnt求出循环多少次，pos求出最后一个完整的循环节结束的位置
            if ((pos%(pos-Next[pos])!=0)||(pos-Next[pos]!=i)) continue;//判断这个循环节是否真的是循环的
            if (Pre[n-pos]==0) continue;//判断后面剩下的几位是否能匹配
            cnt=pos/(pos-Next[pos]);//求出循环次数
            if ((pos==n)&amp;&amp;(cnt&gt;1)) mn=0;//特判原串就是
            mn=min(mn,pos+i-n);
        }
        printf("%d\n",mn);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>532</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 17:24:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 09:24:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu3746cyclic-nacklace%ef%bc%88kmp%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[POJ1741]Tree（点分治）</title>
		<link>http://sycstudio.com/archives/533</link>
		<pubDate>Thu, 22 Feb 2018 11:07:32 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=533</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Give a tree with n vertices,each edge has a length(positive integer less than 1001).
Define dist(u,v)=The min distance between node u and v.
Give an integer k,for every pair (u,v) of vertices is called valid if and only if dist(u,v) not exceed k.
Write a program that will count how many pairs which are valid for a given tree.

<h3>Http</h3>

<a href="https://vjudge.net/problem/POJ-1741">HDU</a>

<h3>Tag</h3>

点分治

<h2>题目大意</h2>

给出一棵树，求其中路径长度不超过一个给定的数&#92;(K&#92;)的点对个数

<h2>解决思路</h2>

考虑点分治，每一层从当前根出发&#92;(bfs&#92;)求出深度，然后组合出所有不超过&#92;(K&#92;)的方案。但这样就会有不合法的情况，所以要减去不经过当前根的答案，再递归求解。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=10100;
const int maxM=maxN*2;
const int inf=2147483647;

int n,K,Ans;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int root,Size[maxN],mxSon[maxN],nowsum;
bool vis[maxN];
int Depth[maxN],scnt,SortData[maxN];
int Queue[maxN],Fa[maxN];

void Add_Edge(int u,int v,int w);
void GetRoot(int u,int fa);
void Solve(int u);
int Calc(int u,int dep);

int main()
{
    ios::sync_with_stdio(false);
    while (cin&gt;&gt;n&gt;&gt;K)
    {
        if ((n==0)&amp;&amp;(K==0)) break;
        edgecnt=0;Ans=0;mem(Head,-1);mem(vis,0);
        for (int i=1;i&lt;n;i++)
        {
            int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
            Add_Edge(u,v,w);Add_Edge(v,u,w);
        }
        mxSon[0]=inf;
        root=0;nowsum=n;
        GetRoot(1,0);
        Solve(root);
        printf("%d\n",Ans);
    }
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void GetRoot(int u,int fa)//求重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//递归求解
{
    Ans+=Calc(u,0);
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            Ans-=Calc(V[i],W[i]);nowsum=Size[V[i]];
            root=0;GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

int Calc(int u,int dep)//计算答案
{
    Depth[u]=dep;scnt=0;Fa[u]=0;
    int h=1,t=0;Queue[1]=u;
    do
    {
        int u=Queue[++t];
        SortData[++scnt]=Depth[u];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;(V[i]!=Fa[u]))
            {
                Fa[V[i]]=u;Depth[V[i]]=Depth[u]+W[i];
                Queue[++h]=V[i];
            }
    }
    while (t!=h);
    sort(&amp;SortData[1],&amp;SortData[scnt+1]);
    int l=1,r=scnt,ret=0;
    while (l&lt;r)
    {
        if (SortData[l]+SortData[r]&lt;=K) ret=ret+r-l,l++;
        else r--;
    }
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>533</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 19:07:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 11:07:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[poj1741tree%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="category" nicename="poj"><![CDATA[POJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2152/Luogu2634]聪聪可可（点分治）</title>
		<link>http://sycstudio.com/archives/534</link>
		<pubDate>Thu, 22 Feb 2018 11:14:10 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=534</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画n个“点”，并用n-1条“边”把这n个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是3的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2152">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P2634">Luogu</a>

<h3>Tag</h3>

点分治

<h2>题目大意</h2>

给出一棵边带权的树，求所有路径长度是三的倍数的路径数量。

<h2>解决思路</h2>

点分治求解，对于每一次找到的重心，&#92;(bfs&#92;)求点的深度，分别统计深度除三余零、一、二的数的个数，组合答案，再减去不经过重心的答案，然后递归求解。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=20100;
const int maxM=maxN*2;
const int inf=2147483647;

int n,root,nowsum,Ans;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],W[maxM];
int Size[maxN],mxSon[maxN];
int histcnt=0,Hist[maxN],Depth[maxN],Queue[maxN];
bool vis[maxN];

void Add_Edge(int u,int v,int w);
void GetRoot(int u,int fa);
void Solve(int u);
int Calc(int u,int dep);
int gcd(int a,int b);

int main()
{
    ios::sync_with_stdio(false);
    mem(Head,-1);
    cin&gt;&gt;n;
    for (int i=1;i&lt;n;i++)
    {
        int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;w=w%3;
        Add_Edge(u,v,w);Add_Edge(v,u,w);
    }
    mxSon[0]=inf;root=0;nowsum=n;
    GetRoot(1,0);
    Solve(root);
    int Sum=n*n;
    int g=gcd(Ans,Sum);
    printf("%d/%d\n",Ans/g,Sum/g);
    return 0;
}

void Add_Edge(int u,int v,int w)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;W[edgecnt]=w;
    return;
}

void GetRoot(int u,int fa)//得到重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0))
        {
            GetRoot(V[i],u);Size[u]+=Size[V[i]];
            mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//递归求解
{
    Ans+=Calc(u,0);
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            Ans-=Calc(V[i],W[i]);
            nowsum=Size[V[i]];root=0;
            GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

int Calc(int u,int dep)//计算答案
{
    Depth[u]=dep;histcnt++;Hist[u]=histcnt;
    int h=1,t=0;Queue[1]=u;
    int Cnt[4]={0,0,0,0};
    do
    {
        int u=Queue[++t];Cnt[Depth[u]%3]++;
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;(Hist[V[i]]!=histcnt))
            {
                Hist[V[i]]=histcnt;Depth[V[i]]=(Depth[u]+W[i]);
                Queue[++h]=V[i];
            }
    }
    while (t!=h);
    return Cnt[0]+Cnt[0]*(Cnt[0]-1)+Cnt[1]*Cnt[2]*2;
}

int gcd(int a,int b)
{
    int tmp;
    while (b) tmp=a,a=b,b=tmp%b;
    return a;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>534</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 19:14:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 11:14:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2152-luogu2634%e8%81%aa%e8%81%aa%e5%8f%af%e5%8f%af%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[SPOJ TLE]Time Limit Exceeded（数位DP，计数DP，高维前缀和）</title>
		<link>http://sycstudio.com/archives/535</link>
		<pubDate>Thu, 22 Feb 2018 12:25:51 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=535</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

Given integers N (1 ≤ N ≤ 50) and M (1 ≤ M ≤ 15), compute the number of sequences a1, ..., aN such that:
0 ≤ ai &lt; 2M
ai is not divisible by ci (0 &lt; ci ≤ 2M)
ai &amp; ai+1 = 0 (that is, ai and ai+1 have no common bits in their binary representation)

<h3>Http</h3>

<a href="http://www.spoj.com/problems/TLE/">SPOJ</a>

<h3>Tag</h3>

动态规划，高维前缀和

<h2>题目大意</h2>

给出一列数，要求求出满足条件的数列的方案数。

<h2>解决思路</h2>

由数据范围容易想到，设&#92;(F[i][j]&#92;)表示前&#92;(i&#92;)个数，第&#92;(i&#92;)个数是&#92;(j&#92;)的方案数，那么有转移方程
&#92;[ F[i][j]=\sum&#95;{k\&amp;j==0} F[i-1][k]&#92;]
不难发现，这里要求的&#92;(k&#92;)就是&#92;(j&#92;)的补集的子集，为了方便计算，我们可以记&#92;(Sum[S]&#92;)表示&#92;(S&#92;)及&#92;(S&#92;)子集的方案数总和，需要的时候直接赋值进去就好。
怎么求这个呢？这里用到一种叫做<strong>高维前缀和</strong>的科技，可以在&#92;(O(n&#42;2^n)&#92;)时间范围内求得子集之和。具体来说，是这样

<pre><code class="cpp">for (int i=0;i&lt;m;i++)
    for (int j=0;j&lt;(1&lt;&lt;m);j++)
        if ((j&amp;(1&lt;&lt;i))!=0) Sum[j]+=Sum[j^(1&lt;&lt;i)];
</code></pre>

正确性暂不会证明。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=51;
const int maxM=15;
const int Mod=1000000000;
const int inf=2147483647;

int n,m;
int C[maxN];
ll F[maxN][1&lt;&lt;(maxM+1)];
ll Sum[1&lt;&lt;(maxM+1)];

int main()
{
    ios::sync_with_stdio(false);
    int T;cin&gt;&gt;T;
    while (T--)
    {
        cin&gt;&gt;n&gt;&gt;m;
        for (int i=1;i&lt;=n;i++) cin&gt;&gt;C[i];
        mem(F,0);mem(Sum,0);
        //先把第一位的方案计算出来
        for (int i=0;i&lt;(1&lt;&lt;m);i++) if (i%C[1]!=0) F[1][i]=Sum[i]=1;
        for (int i=0;i&lt;m;i++)//高维前缀和
            for (int j=0;j&lt;(1&lt;&lt;m);j++)
                if ((j&amp;(1&lt;&lt;i))!=0) Sum[j]=(Sum[j]+Sum[j^(1&lt;&lt;i)])%Mod;
        for (int i=2;i&lt;=n;i++)
        {
            for (int j=0;j&lt;(1&lt;&lt;m);j++) if (j%C[i]!=0) F[i][j]=Sum[j^((1&lt;&lt;m)-1)];//转移
            mem(Sum,0);//准备统计新的一次的答案
            for (int j=0;j&lt;(1&lt;&lt;m);j++) Sum[j]=F[i][j];
            for (int j=0;j&lt;m;j++)//高维前缀和
                for (int k=0;k&lt;(1&lt;&lt;m);k++)
                    if ((k&amp;(1&lt;&lt;j))!=0) Sum[k]=(Sum[k]+Sum[k^(1&lt;&lt;j)])%Mod;
        }
        ll Ans=0;
        for (int i=0;i&lt;(1&lt;&lt;m);i++) if (i%C[n]!=0) Ans=(Ans+F[n][i])%Mod;
        printf("%lld\n",Ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>535</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 20:25:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 12:25:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[spoj-tletime-limit-exceeded%ef%bc%88%e6%95%b0%e4%bd%8ddp%ef%bc%8c%e8%ae%a1%e6%95%b0dp%ef%bc%8c%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="spoj"><![CDATA[SPOJ]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%95%b0%e4%bd%8d%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[数位动态规划]]></category>
		<category domain="category" nicename="%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c"><![CDATA[高维前缀和]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c"><![CDATA[高维前缀和]]></category>
		<category domain="category" nicename="%e8%ae%a1%e6%95%b0%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[计数动态规划]]></category>
		<category domain="category" nicename="spoj"><![CDATA[SPOJ]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[HDU5977]Garden of Eden（点分治，高维前缀和）</title>
		<link>http://sycstudio.com/archives/536</link>
		<pubDate>Thu, 22 Feb 2018 12:41:36 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=536</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

When God made the first man, he put him on a beautiful garden, the Garden of Eden. Here Adam lived with all animals. God gave Adam eternal life. But Adam was lonely in the garden, so God made Eve. When Adam was asleep one night, God took a rib from him and made Eve beside him. God said to them, “here in the Garden, you can do everything, but you cannot eat apples from the tree of knowledge.”
One day, Satan came to the garden. He changed into a snake and went to live in the tree of knowledge. When Eve came near the tree someday, the snake called her. He gave her an apple and persuaded her to eat it. Eve took a bite, and then she took the apple to Adam. And Adam ate it, too. Finally, they were driven out by God and began a hard journey of life.
The above is the story we are familiar with. But we imagine that Satan love knowledge more than doing bad things. In Garden of Eden, the tree of knowledge has n apples, and there are k varieties of apples on the tree. Satan wants to eat all kinds of apple to gets all kinds of knowledge.So he chooses a starting point in the tree,and starts walking along the edges of tree,and finally stops at a point in the tree(starting point and end point may be same).The same point can only be passed once.He wants to know how many different kinds of schemes he can choose to eat all kinds of apple. Two schemes are different when their starting points are different or ending points are different.

<h3>Http</h3>

<a href="https://vjudge.net/problem/HDU-5977">HDU</a>

<h3>Tag</h3>

点分治，高维前缀和，状态压缩

<h2>题目大意</h2>

给出一棵树，这棵树上的每一个点有一个类别，求经过每一种类别的点至少一次的路径条数。

<h2>解决思路</h2>

点分治求解。考虑到&#92;(K&#92;)即种类数的范围只有&#92;(10&#92;)，所以可以对每一个点维护一个二进制状态表示它到当前点分治的根的路径上经过的点的种类集合。每一次计算出当前根的答案再减去不经过当前根的答案即可，递归求解。
这题的关键在于如何计算每一次的答案。一个点到根的路径上的点种类集合这个比较好求，直接&#92;(bfs&#92;)即可，关键是如何组合出经过所有类别的路径。根据题意我们可以得到一个计算公式。
记&#92;(nowAns&#92;)表示这一次的答案，&#92;(nown&#92;)表示这一次遍历的点的数量，&#92;(Path[u]&#92;)表示&#92;(u&#92;)这个点到当前根的路径上的点类型的集合，&#92;(Cnt[S]&#92;)表示到根的路径上点类型的集合为&#92;(S&#92;)的点有多少个，那么有
&#92;[nowAns=\sum&#95;{i=1}^{nown} \sum&#95;{S|Path[i]==(1 &lt; &lt; K)-1} Cnt[S]&#92;]
那么现在的问题就是如何统计一个集合&#92;(S&#92;)的超集之和。（超集，比如对于F[0101]，超集之和为F[0101]+F[1101]+F[0111]+F[1111]）。
这个可以用高维前缀和解决，具体来说可以这样求

<pre><code class="cpp">for (int i=0;i&lt;K;i++)
    for (int j=0;j&lt;(1&lt;&lt;K);j++)
        if ((j&amp;(1&lt;&lt;i))==0) Cnt[j]+=Cnt[j|(1&lt;&lt;i)];
</code></pre>

正确性暂不会证。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=50010;
const int maxM=maxN*2;
const int maxBit=10;
const int inf=2147483647;

int n,K;
ll Ans;
int edgecnt=0,Head[maxN],Next[maxM],V[maxM],NodeW[maxN];
int root,nowsum,Size[maxN],mxSon[maxN];
int histcnt,Hist[maxN];
int Queue[maxN],Path[maxN];
ll Cnt[1&lt;&lt;(maxBit+1)];
int Stack[maxN];
bool vis[maxN];

void Add_Edge(int u,int v);
void GetRoot(int u,int fa);
void Solve(int u);
ll Calc(int u,int init);

int main()
{
    ios::sync_with_stdio(false);
    while (cin&gt;&gt;n&gt;&gt;K)
    {
        edgecnt=0;mem(Head,-1);mem(vis,0);Ans=0;
        for (int i=1;i&lt;=n;i++){
            cin&gt;&gt;NodeW[i];NodeW[i]=1&lt;&lt;(NodeW[i]-1);
        }
        for (int i=1;i&lt;n;i++)
        {
            int u,v;cin&gt;&gt;u&gt;&gt;v;
            Add_Edge(u,v);Add_Edge(v,u);
        }
        root=0;mxSon[0]=inf;nowsum=n;
        GetRoot(1,0);
        Solve(root);
        printf("%lld\n",Ans);
    }
    return 0;
}

void Add_Edge(int u,int v)
{
    edgecnt++;Next[edgecnt]=Head[u];Head[u]=edgecnt;V[edgecnt]=v;
    return;
}

void GetRoot(int u,int fa)//得到重心
{
    Size[u]=1;mxSon[u]=0;
    for (int i=Head[u];i!=-1;i=Next[i])
        if ((V[i]!=fa)&amp;&amp;(vis[V[i]]==0)){
            GetRoot(V[i],u);Size[u]+=Size[V[i]];mxSon[u]=max(mxSon[u],Size[V[i]]);
        }
    mxSon[u]=max(mxSon[u],nowsum-Size[u]);
    if (mxSon[u]&lt;mxSon[root]) root=u;
    return;
}

void Solve(int u)//递归求解
{
    Ans+=Calc(u,0);
    vis[u]=1;
    for (int i=Head[u];i!=-1;i=Next[i])
        if (vis[V[i]]==0)
        {
            Ans-=Calc(V[i],NodeW[u]);
            nowsum=Size[V[i]];root=0;
            GetRoot(V[i],0);
            Solve(root);
        }
    return;
}

ll Calc(int u,int init)
{
    mem(Cnt,0);
    histcnt++;Hist[u]=histcnt;
    Path[u]=init|NodeW[u];
    int h=1,t=0;Queue[1]=u;
    int stacktop=0;
    do//bfs求出每一个点到当前根的路径上的点类型的集合
    {
        int u=Queue[++t];Cnt[Path[u]]++;Stack[++stacktop]=Path[u];
        for (int i=Head[u];i!=-1;i=Next[i])
            if ((vis[V[i]]==0)&amp;&amp;(Hist[V[i]]!=histcnt))
            {
                Hist[V[i]]=histcnt;Path[V[i]]=Path[u]|NodeW[V[i]];
                Queue[++h]=V[i];
            }
    }
    while (t!=h);
    for (int i=0;i&lt;K;i++)//高维前缀和
        for (int j=0;j&lt;(1&lt;&lt;K);j++)
            if ((j&amp;(1&lt;&lt;i))==0) Cnt[j]+=Cnt[j|(1&lt;&lt;i)];
    ll ret=0;
    for (int i=1;i&lt;=stacktop;i++) ret=ret+Cnt[Stack[i]^((1&lt;&lt;K)-1)];//统计答案
    return ret;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>536</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 20:41:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 12:41:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu5977garden-of-eden%ef%bc%88%e7%82%b9%e5%88%86%e6%b2%bb%ef%bc%8c%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdu"><![CDATA[HDU]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="post_tag" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
		<category domain="category" nicename="%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c"><![CDATA[高维前缀和]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e7%bb%b4%e5%89%8d%e7%bc%80%e5%92%8c"><![CDATA[高维前缀和]]></category>
		<category domain="category" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="hdu"><![CDATA[HDU]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>关于回文树的理解 by yyb</title>
		<link>http://sycstudio.com/archives/537</link>
		<pubDate>Thu, 22 Feb 2018 12:49:54 +0000</pubDate>
		<dc:creator><![CDATA[yyb]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=537</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>前言</h2>

这段时间搞字符串上了瘾？
看起来是的
那就继续搞吧

<h2>Part1一些名词</h2>

<h3>回文串</h3>

不想解释什么意思

<h3>回文子串</h3>

一个串的子串，它是回文串，那么它就是回文子串

<h3>最长回文后缀</h3>

对于一个长度小于自己的后缀，如果它是回文串，并且不存在比它更长的回文后缀，那么它就是最长回文后缀

<h3>最长回文前缀</h3>

基本和上面一样

<h2>Part2 回文树的形态</h2>

<h3>长成啥样啊？</h3>

我们很容易知道，回文串有两种，一种长度是奇数，一种长度是偶数
而在回文树上走，我们肯定不是一次只在后面添加一个字符
显然是在前后各添加一个字符
所以我们不难得出一点，如果串可以变成另外一个回文串
那么它的长度一定加上了一个偶数
所以在回文树上，为了区分这两种不同的回文串
所以回文树相当于一个森林
有两棵树，一棵的代表长度为奇数的回文串，另一棵代表长度为偶数的回文串

就像后缀自动机，Trie树，AC自动机这些东西一样
每一个节点代表的都是一个（些）串
回文树的每个节点也是代表着一个串
对于每个点的转移，比如说
对于某个点代表的回文串"aba"
假如它有一个'c'的转移
那么，"aba"就会指向一个代表着"cabac"的串

同样的，类似于AC自动机有$$fail$$，后缀自动机有$$parent$$
当失配的时候回文树也有$$fail$$向上跳
那么，我们来考虑一些这个东西是什么？

假设当前加入的位置是$$r$$
如果之前已经匹配出了一个回文$$S_{l..r-1}$$
那么，如果有$$S_{l-1}=S_r$$就没有失配
如果失配了，因为$$r$$位置是不能变动的
所以挪动的只有$$l$$位置
而$$S_{l..r}$$显然也要是一个回文串
所以$$l$$挪动到的位置就是$$S_{l..r-1}$$的最长回文后缀的开始位置

<h3>一些小小的结论</h3>

综上所述，我们知道了两点：
<strong><em>1.对于回文树上的两个节点，如果存在字符c的连边，那么，就会从串x，变成cxc</em></strong>
<strong><em>2.对于回文树上的失配(fail)指针，指向这个点所代表的字符串的最长回文后缀所在的节点</em></strong>

<h3>一些小小的证明</h3>

接下来，我们还可以知道几点
<strong><em>1.对于任何一个串S，它的本质不同的回文串的个数不会超过|S|个</em></strong>
<strong><em>2.如果在串S后面加入一个字符，新增的本质不同的回文串的个数不会超过1个</em></strong>

怎么证明？

利用数学归纳法来证明

当$$|S|=1$$时，显然成立

如果我们知道$$|S|=x-1$$时成立，现在插入$$x$$位置，字符为$$c$$
如果以$$x$$位置结尾出现了两个新的本质不同的回文串
假设较长的从$$l1$$开始，较短的从$$l2$$开始
因为$$|S_{l1..r}|&gt;|S_{l2..r}|$$
又根据回文串对称的性质
所以$$S_{l2..r}$$在$$S_{l1..l1+r-l2}$$必定出现过
所以不存在两个本质不同的回文串
所以最多新增一个本质不同的回文串
所以到$$x$$位置出现的本质不同的回文串的个数最多为$$x$$个

同时，我们也证明了每次插入一个新的字符，最多增加一个本质不同的回文子串

<h2>Part3 回文树的构造</h2>

看完了上面，应该就知道了回文树上的东西代表着什么
我们的构造采用增量法，也就是类似于后缀自动机的$$extend$$

假设前面已经构造出了$$1..x-1$$的回文树，现在要加入第$$x$$个字符$$c$$
因为要接在$$x-1$$的后面，我们又知道最多一个产生一个新的本质不同的回文串
也就是$$S_{1..x-1}$$中，最长的某个回文后缀$$S_{l..x-1}$$，
同时能够满足$$S_{l-1}=S_x$$
因为只需要不停地寻找最长回文后缀

根据回文树上的$$fail$$指针的含义
我们很容易知道知道，
只需要从上一个位置添加完之后的最后一个位置
（也就是以$$x-1$$为结束位置的最长回文子串）
所代表的节点开始，沿着$$fail$$一路上跳
检查是否满足$$S_{l-1}=S_x$$就行了

假设这样找到的一个位置是$$p$$
不难证明这个位置$$p$$一定存在（为啥？长度为1的回文串呀）
如果$$p.son[c]$$也就是连边$$c$$已经存在
那就什么都不用干，因为这个回文子串已经存在过
不需要重新建边
否则，重新建一个点表示这个回文子串,假设点是$$np$$吧
然后$$p.son[c]=np$$

现在我们要找$$np$$的$$fail$$啦
因为要找的是最长回文后缀，不能是自己
所以令$$k=p.fail$$
然后就像前面一样的，找到第一个满足$$S[l_k-1]=S[n]$$的点
让$$k$$沿着$$fail$$向上跳
然后$$np.fail=k$$，表示找到啦

这样，我们的回文树就利用增量法构建出来啦

当然，两棵树的根节点的长度分别是$$-1$$和$$0$$
然后为$$0$$的根节点的$$fail$$连向$$-1$$的根节点
$$-1$$个根节点的$$fail$$也连向自己
为啥？自己想
初始情况下的$$last=0,tot=1$$（代表什么可以参考程序）

这是一棵回文树

<pre><code class="cpp">struct Palindromic_Tree
{
        struct Node
        {
                int son[26];
                int ff,len;
        }t[MAX];
        int last,tot;
        void init()
        {
                t[++tot].len=-1;
                t[0].ff=t[1].ff=1;
        }
        void extend(int c,int n)
        {
                int p=last;
                while(s[n-t[p].len-1]!=s[n])p=t[p].ff;
                if(!t[p].son[c])
                {
                        int v=++tot,k=t[p].ff;
                        t[v].len=t[p].len+2;
                        while(s[n-t[k].len-1]!=s[n])k=t[k].ff;
                        t[v].ff=t[k].son[c];
                        t[p].son[c]=v;
                }
                last=t[p].son[c];
                size[t[p].son[c]]++;
        }
};
</code></pre>

<h2>Part4 后记</h2>

这篇博客十分简短
因此肯定有很多很多不严谨的地方
更加详细的请参考
国家集训队$$2017$$年的论文

当然了，这些东西也只是我自己的理解
而回文树也有很多很神奇的用法，
等我做了一些题之后我会再回来写的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>537</wp:post_id>
		<wp:post_date><![CDATA[2018-02-22 20:49:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-22 12:49:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e5%9b%9e%e6%96%87%e6%a0%91%e7%9a%84%e7%90%86%e8%a7%a3-by-yyb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%a0%94%e7%a9%b6%e6%80%bb%e7%bb%93"><![CDATA[研究总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[BZOJ2333/Luogu3273][SCOI2011]棘手的操作（可并堆，左偏树）</title>
		<link>http://sycstudio.com/archives/539</link>
		<pubDate>Fri, 23 Feb 2018 12:17:58 +0000</pubDate>
		<dc:creator><![CDATA[sycstudio]]></dc:creator>
		<guid isPermaLink="false">http://sycstudio.com/?p=539</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Description</h3>

有N个节点，标号从1到N，这N个节点一开始相互不连通。第i个节点的初始权值为a[i]，接下来有如下一些操作：
U x y: 加一条边，连接第x个节点和第y个节点
A1 x v: 将第x个节点的权值增加v
A2 x v: 将第x个节点所在的连通块的所有节点的权值都增加v
A3 v: 将所有节点的权值都增加v
F1 x: 输出第x个节点当前的权值
F2 x: 输出第x个节点所在的连通块中，权值最大的节点的权值
F3: 输出所有节点中，权值最大的节点的权值

<h3>Http</h3>

<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2333">BZOJ</a>
<a href="https://www.luogu.org/problemnew/show/P3273">Luogu</a>

<h3>Tag</h3>

可并堆，左偏树

<h2>解决思路</h2>

考虑到题目中所有的询问操作都是求最大值，再看到第一种操作只有合并没有分离，那么可以想到用可并堆来维护每一个联通块，至于整个连通块的修改可以用&#92;(lazy&#92;)标记来维护。下面依次具体来看每一个操作。
<strong>U x y: 加一条边，连接第x个节点和第y个节点</strong>，这个直接分别找到&#92;(x&#92;)和&#92;(y&#92;)所在的可并堆的根，若不在同一个可并堆则合并两个可并堆。注意，这里跳祖先不能用并查集，具体原因下面会说。时间复杂度&#92;(O(logn)&#92;)
<strong>A1 x v: 将第x个节点的权值增加v</strong>，在可并堆中分离出节点&#92;(x&#92;)，然后把&#92;(x&#92;)的权值修改了后再与&#92;(x&#92;)原来所在的可并堆合并。注意，由于有&#92;(lazy&#92;)标记，在分离之前要把从根到&#92;(x&#92;)路径上的所有&#92;(lazy&#92;)都下放。具体分离的步骤是先把&#92;(x&#92;)的两个儿子合并，然后把儿子合并后的新根连上原来&#92;(x&#92;)的父亲，同时修改父亲对应的儿子指针。时间复杂度&#92;(O(logn)&#92;)
<strong>A2 x v: 将第x个节点所在的连通块的所有节点的权值都增加v</strong>，跳到&#92;(x&#92;)所在可并堆的根，对根打上&#92;(lazy&#92;)标记。时间复杂度&#92;(O(logn)&#92;)
<strong>A3 v: 将所有节点的权值都增加v</strong>，在全局维护一个&#92;(allsum&#92;)表示所有&#92;(A3&#92;)操作之和，每一次要输出的时候再加上即可。时间复杂度&#92;(O(1)&#92;)
<strong>F1 x: 输出第x个节点当前的权值</strong>，类似的，要先从根向下下放所有的&#92;(lazy&#92;)标记再得到值。时间复杂度&#92;(O(logn)&#92;)
<strong>F2 x: 输出第x个节点所在的连通块中，权值最大的节点的权值</strong>，跳到根后输出根的值。时间复杂度&#92;(O(logn)&#92;)
<strong>F3: 输出所有节点中，权值最大的节点的权值</strong>，由于权值最大的值一定是可并堆的根，所以可以在全局再维护一个代删除的堆，每一次有对可并堆的堆顶的修改时就在这个全局的堆中进行修改，那么&#92;(F3&#92;)操作就直接输出这个堆顶即可。为了方便，可以用两个系统堆来实现带删除的堆的操作，具体来说，用一个堆表示实际的堆，另一个标记垃圾堆，每一次要删除实际堆中的元素时，把这个元素丢入垃圾堆中，当实际堆与垃圾堆的堆顶相同时，同时弹出两个堆的堆顶。时间复杂度&#92;(O(logn)&#92;)
至于为什么不能用路径压缩并查集来维护堆顶。由于这里再可并堆上有&#92;(lazy&#92;)标记用来下放，那么至少需要带权并查集来维护，又因为&#92;(lazy&#92;)是在不断下放的，那么可能并查集还没有更新到，&#92;(lazy&#92;)就已经下放了。再加上有分离出某一个点修改再丢回去的操作，这时候带权并查集的权就会更加混乱。所以不能路径压缩。
这里用左偏树实现可并堆。

<h2>代码</h2>

<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=300100;
const int inf=2147483647;

class Heap
{
public:
    int key;
    int ls,rs,dis,fa,lazy;
};

int n;
Heap H[maxN];
priority_queue&lt;int&gt; Q1,Q2;//Q1，Q2分别是全局的实际堆和垃圾堆

int Merge(int r1,int r2);
void PushDown(int r);
void Mark(int r,int lazy);
int GetRt(int x);//得到堆顶
void PushLazy(int x);//从堆顶下放所有lazy标记
void QPush(int x);//这三个操作是维护全局的堆顶的值的
void QDel(int x);
int QTop();

int main()
{
    ios::sync_with_stdio(false);
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++){
        cin&gt;&gt;H[i].key;QPush(H[i].key);
    }
    int Q;cin&gt;&gt;Q;
    char opt[5];
    int allsum=0;
    while (Q--)
    {
        cin&gt;&gt;opt;
        if (opt[0]=='U')
        {
            int x,y;cin&gt;&gt;x&gt;&gt;y;
            x=GetRt(x);y=GetRt(y);//走到堆顶
            if (x!=y){//若不在同一可并堆，则合并，同时注意要修改全局堆
                int t=Merge(x,y);
                if (t==x) QDel(H[y].key);
                else QDel(H[x].key);
            }
        }
        if (opt[0]=='A')
        {
            if (opt[1]=='1')//单点修改
            {
                int x,v;cin&gt;&gt;x&gt;&gt;v;
                PushLazy(x);QDel(H[GetRt(x)].key);//先把堆顶删除

                int nrt=Merge(H[x].ls,H[x].rs),fa=H[x].fa;//合并左右儿子

                if (H[fa].ls==x) H[fa].ls=nrt;//将父亲原来的儿子指针指向新的儿子
                else if (H[fa].rs==x) H[fa].rs=nrt;
                H[x].fa=H[x].ls=H[x].rs=0;H[x].key+=v;//更新该点权值
                H[nrt].fa=fa;//将新儿子指向父亲

                nrt=GetRt(nrt);//得到堆顶
                nrt=Merge(x,nrt);//把修改后的点放回去
                QPush(H[nrt].key);//把新的堆顶放入全局堆
            }
            if (opt[1]=='2')//整块修改
            {
                int x,v;cin&gt;&gt;x&gt;&gt;v;
                x=GetRt(x);QDel(H[x].key);//得到根，并在全局堆中删除
                Mark(x,v);QPush(H[x].key);//修改，并加入全局堆
            }
            if (opt[1]=='3')//全局修改
            {
                int v;cin&gt;&gt;v;allsum+=v;
            }
        }
        if (opt[0]=='F')
        {
            if (opt[1]=='1')//单点询问
            {
                int x;cin&gt;&gt;x;
                PushLazy(x);//下放lazy标记
                printf("%d\n",H[x].key+allsum);
            }
            if (opt[1]=='2')//连通块最值查询
            {
                int x;cin&gt;&gt;x;
                x=GetRt(x);
                printf("%d\n",H[x].key+allsum);
            }
            if (opt[1]=='3')//全局最值查询
            {
                printf("%d\n",QTop()+allsum);
            }
        }
    }
    return 0;
}

int Merge(int r1,int r2)//左偏树合并
{
    if (r1==0) return r2;
    if (r2==0) return r1;
    PushDown(r1);PushDown(r2);
    if (H[r1].key&lt;H[r2].key) swap(r1,r2);
    H[r1].rs=Merge(H[r1].rs,r2);
    H[H[r1].rs].fa=r1;
    if (H[H[r1].ls].dis&lt;H[H[r1].rs].dis) swap(H[r1].ls,H[r1].rs);
    if (H[r1].rs) H[r1].dis=H[H[r1].rs].dis+1;
    else H[r1].dis=0;
    return r1;
}

void PushDown(int r)//标记下放
{
    if (H[r].lazy==0) return;
    if (H[r].ls) Mark(H[r].ls,H[r].lazy);
    if (H[r].rs) Mark(H[r].rs,H[r].lazy);
    H[r].lazy=0;return;
}

void Mark(int r,int lazy)
{
    H[r].key+=lazy;H[r].lazy+=lazy;
    return;
}

int GetRt(int x)
{
    while (H[x].fa) x=H[x].fa;
    return x;
}

int Stack[maxN];

void PushLazy(int x)
{
    int stacktop=0;
    while (x){
        Stack[++stacktop]=x;x=H[x].fa;
    }
    while (stacktop) PushDown(Stack[stacktop--]);
    return;
}

void QPush(int x)
{
    Q1.push(x);return;
}

void QDel(int x)
{
    Q2.push(x);
    while ((!Q1.empty())&amp;&amp;(!Q2.empty())&amp;&amp;(Q1.top()==Q2.top())) Q1.pop(),Q2.pop();
    return;
}

int QTop()
{
    while ((!Q1.empty())&amp;&amp;(!Q2.empty())&amp;&amp;(Q1.top()==Q2.top())) Q1.pop(),Q2.pop();
    return Q1.top();
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>539</wp:post_id>
		<wp:post_date><![CDATA[2018-02-23 20:17:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-02-23 12:17:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj2333-luogu3273scoi2011%e6%a3%98%e6%89%8b%e7%9a%84%e6%93%8d%e4%bd%9c%ef%bc%88%e5%8f%af%e5%b9%b6%e5%a0%86%ef%bc%8c%e5%b7%a6%e5%81%8f%e6%a0%91%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="post_tag" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="post_tag" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="post_tag" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<category domain="category" nicename="%e5%90%84%e7%9c%81%e7%9c%81%e9%80%89"><![CDATA[各省省选]]></category>
		<category domain="category" nicename="bzoj"><![CDATA[BZOJ]]></category>
		<category domain="category" nicename="luogu"><![CDATA[Luogu]]></category>
		<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="%e5%8f%af%e5%b9%b6%e5%a0%86"><![CDATA[可并堆]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[posturl_add_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[yes]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
